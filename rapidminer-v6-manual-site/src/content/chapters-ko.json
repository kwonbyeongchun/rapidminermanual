[
  {
    "id": "chapter-1",
    "number": "1",
    "title": "기본 용어",
    "slug": "chapter-1-fundamental-terms",
    "blocks": [
      {
        "type": "paragraph",
        "text": "이 장에서는 데이터 마이닝 활용에 대한 동기를 부여하고, 동시에 가장 중요한 용어들을 소개하고자 합니다. 이미 숙련된 데이터 마이닝 전문가이든 아니든, 이 장은 본 서적과 RapidMiner에서 사용되는 용어들을 이해하고 숙지하기 위해 읽어볼 가치가 있습니다.",
        "html": "이 장에서는 데이터 마이닝 활용에 대한 동기를 부여하고, 동시에 가장 중요한 용어들을 소개하고자 합니다. 이미 숙련된 데이터 마이닝 전문가이든 아니든, 이 장은 본 서적과 RapidMiner에서 사용되는 용어들을 이해하고 숙지하기 위해 읽어볼 가치가 있습니다. "
      }
    ],
    "sections": [
      {
        "id": "1-1-coincidence-or-not",
        "number": "1.1",
        "title": "우연인가, 아닌가?",
        "blocks": [
          {
            "type": "paragraph",
            "text": "본격적으로 시작하기 전에, 간단한 실험을 하나 해봅시다: • 1부터 10 사이의 숫자 하나를 생각하세요.",
            "html": "본격적으로 시작하기 전에, 간단한 실험을 하나 해봅시다: • 1부터 10 사이의 숫자 하나를 생각하세요. "
          },
          {
            "type": "paragraph",
            "text": "• 이 숫자에 9를 곱하세요.",
            "html": "• 이 숫자에 9를 곱하세요. "
          },
          {
            "type": "paragraph",
            "text": "• 결과의 각 자릿수를 합하세요(자릿수 합). • 그 결과에 4를 곱하세요.",
            "html": "• 결과의 각 자릿수를 합하세요(자릿수 합). • 그 결과에 4를 곱하세요. "
          },
          {
            "type": "paragraph",
            "text": "• 결과를 3으로 나누세요.",
            "html": "• 결과를 3으로 나누세요. "
          },
          {
            "type": "paragraph",
            "text": "• 10을 빼세요.",
            "html": "• 10을 빼세요. "
          },
          {
            "type": "paragraph",
            "text": "결과는 2입니다.",
            "html": "결과는 2입니다. "
          },
          {
            "type": "paragraph",
            "text": "우연을 믿으시나요? 분석가로서 이 질문에 부정적으로 대답하는 법을 배우게 되거나, 이미 그렇게 하고 계실 것입니다. 여러분이 상상할 수 있는 가장 단순한 무작위 사건인 동전 던지기를 예로 들어봅시다. \"아, 하지만 그것은 무작위 사건이고 동전을 던진 후 어느 면이 나올지 아무도 예측할 수 없잖아요\"라고 생각하실 수 있습니다. 그것은 맞을 수도 있지만, 아무도 예측할 수 없다는 사실이 원칙적으로 불가능하다는 것을 의미하지는 않습니다. 던지는 속도와 회전 각도, 동전과 바닥의 재질 특성, 질량 분포, 심지어 바람의 세기와 방향까지 모든 영향 요인을 정확히 알고 있다면, 시간과 노력을 들여 동전 던지기의 결과를 충분히 예측할 수 있을 것입니다. 이를 위한 물리 공식은 이미 모두 알려져 있습니다.",
            "html": "우연을 믿으시나요? 분석가로서 이 질문에 부정적으로 대답하는 법을 배우게 되거나, 이미 그렇게 하고 계실 것입니다. 여러분이 상상할 수 있는 가장 단순한 무작위 사건인 동전 던지기를 예로 들어봅시다. \"아, 하지만 그것은 무작위 사건이고 동전을 던진 후 어느 면이 나올지 아무도 예측할 수 없잖아요\"라고 생각하실 수 있습니다. 그것은 맞을 수도 있지만, 아무도 예측할 수 없다는 사실이 원칙적으로 불가능하다는 것을 의미하지는 않습니다. 던지는 속도와 회전 각도, 동전과 바닥의 재질 특성, 질량 분포, 심지어 바람의 세기와 방향까지 모든 영향 요인을 정확히 알고 있다면, 시간과 노력을 들여 동전 던지기의 결과를 충분히 예측할 수 있을 것입니다. 이를 위한 물리 공식은 이미 모두 알려져 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "이번에는 결과를 예측할 수 있는 다른 시나리오를 살펴봅시다: 유리잔이 일정 높이에서 특정 종류의 바닥으로 떨어지면 깨집니다. 유리잔이 떨어지는 그 찰나의 순간에도 우리는 이미 알고 있습니다: 유리 조각이 생길 것이라는 사실을요. 어떻게 이런 놀라운 예측이 가능할까요? 바로 이 순간 떨어지고 있는 그 유리잔이 깨지는 것을 이전에 본 적은 없으며, 유리의 파손을 설명하는 물리 공식은 대부분의 사람들에게 전혀 알려지지 않은 것입니다. 물론 개별 사례에서 유리잔이 \"우연히\" 온전할 수도 있지만, 그럴 가능성은 낮습니다. 유리잔이 깨지지 않는 것도 마찬가지로 우연이 아닐 것입니다. 이 결과 역시 물리 법칙을 따르기 때문입니다. 예를 들어, 이 경우에는 충격 에너지가 바닥으로 더 잘 전달되는 것입니다. 그렇다면 인간은 어떤 경우에는 다음에 무슨 일이 일어날지 알 수 있고, 동전 던지기와 같은 다른 경우에는 왜 알 수 없는 걸까요?",
            "html": "이번에는 결과를 예측할 수 있는 다른 시나리오를 살펴봅시다: 유리잔이 일정 높이에서 특정 종류의 바닥으로 떨어지면 깨집니다. 유리잔이 떨어지는 그 찰나의 순간에도 우리는 이미 알고 있습니다: 유리 조각이 생길 것이라는 사실을요. 어떻게 이런 놀라운 예측이 가능할까요? 바로 이 순간 떨어지고 있는 그 유리잔이 깨지는 것을 이전에 본 적은 없으며, 유리의 파손을 설명하는 물리 공식은 대부분의 사람들에게 전혀 알려지지 않은 것입니다. 물론 개별 사례에서 유리잔이 \"우연히\" 온전할 수도 있지만, 그럴 가능성은 낮습니다. 유리잔이 깨지지 않는 것도 마찬가지로 우연이 아닐 것입니다. 이 결과 역시 물리 법칙을 따르기 때문입니다. 예를 들어, 이 경우에는 충격 에너지가 바닥으로 더 잘 전달되는 것입니다. 그렇다면 인간은 어떤 경우에는 다음에 무슨 일이 일어날지 알 수 있고, 동전 던지기와 같은 다른 경우에는 왜 알 수 없는 걸까요? "
          },
          {
            "type": "paragraph",
            "text": "비전문가들이 가장 흔히 사용하는 설명은 한 시나리오를 \"우연\"으로, 다른 시나리오를 \"필연\"으로 구분하는 것입니다. 이 주제에 관한 흥미롭지만 다소 철학적인 논의에 깊이 들어가지는 않겠지만, 다음과 같은 명제를 제시하고자 합니다:",
            "html": "비전문가들이 가장 흔히 사용하는 설명은 한 시나리오를 \"우연\"으로, 다른 시나리오를 \"필연\"으로 구분하는 것입니다. 이 주제에 관한 흥미롭지만 다소 철학적인 논의에 깊이 들어가지는 않겠지만, 다음과 같은 명제를 제시하고자 합니다: "
          },
          {
            "type": "paragraph",
            "text": "우리가 인지할 수 있는 환경에서 일어나는 대다수의 과정은 우연의 결과가 아닙니다. 과정을 정확하게 기술하고 추론할 수 없는 이유는 오히려 필요한 영향 요인을 인식하거나 측정할 수 없거나, 이들을 상호 연관시킬 수 없기 때문입니다.",
            "html": "우리가 인지할 수 있는 환경에서 일어나는 대다수의 과정은 우연의 결과가 아닙니다. 과정을 정확하게 기술하고 추론할 수 없는 이유는 오히려 필요한 영향 요인을 인식하거나 측정할 수 없거나, 이들을 상호 연관시킬 수 없기 때문입니다. "
          },
          {
            "type": "paragraph",
            "text": "떨어지는 유리잔의 경우, 우리는 재질, 낙하 높이, 바닥의 특성과 같은 가장 중요한 특성들을 빠르게 인식하고, 유사한 경험에서의 유추를 통해 유리잔이 깨질 확률을 매우 짧은 시간 안에 추정할 수 있습니다. 그러나 동전 던지기에서는 이것이 불가능합니다. 아무리 많은 동전 던지기를 관찰하더라도, 무작위로 던져진 경우 필요한 요인들을 충분히 빠르게 인식하고 이에 따라 추론하는 것은 결코 불가능합니다.",
            "html": "떨어지는 유리잔의 경우, 우리는 재질, 낙하 높이, 바닥의 특성과 같은 가장 중요한 특성들을 빠르게 인식하고, 유사한 경험에서의 유추를 통해 유리잔이 깨질 확률을 매우 짧은 시간 안에 추정할 수 있습니다. 그러나 동전 던지기에서는 이것이 불가능합니다. 아무리 많은 동전 던지기를 관찰하더라도, 무작위로 던져진 경우 필요한 요인들을 충분히 빠르게 인식하고 이에 따라 추론하는 것은 결코 불가능합니다. "
          },
          {
            "type": "paragraph",
            "text": "그렇다면 충격 후 유리잔의 상태를 예측할 때 우리의 머릿속에서는 무슨 일이 일어났을까요? 우리는 이 사건의 특성들을 측정했습니다. 유리잔의 낙하를 설명하는 데이터를 수집했다고도 할 수 있습니다. 그런 다음 유사성 측정에 기반하여 이전에 떨어진 유리잔, 컵, 도자기 인형 또는 유사한 물건들과 매우 빠르게 유추했습니다. 이를 위해 두 가지가 필요합니다: 첫째, 이전 사건의 데이터도 갖고 있어야 하고, 둘째, 현재 데이터와 과거 데이터 사이의 유사성이 어떻게 정의되는지 알고 있어야 합니다. 궁극적으로 우리는 이미 발생한 가장 유사한 사건들을 살펴봄으로써 추정이나 예측을 할 수 있습니다. 이러한 경우에 떨어진 물건이 깨졌는지 아닌지를 살펴보는 것입니다. 먼저 가장 유사한 사건들을 찾아야 하는데, 이것은 일종의 최적화를 나타냅니다. 여기서 \"최적화\"라는 용어를 사용하는 이유는, 유사성을 최대화하든, 기업의 매출을 최대화하든, 그 외 무엇이든 간에 - 해당 변수, 여기서는 유사성이 항상 최적화되기 때문입니다. 위에서 설명한 유추 추론은 우리가 이미 관찰한 대다수의 유리잔이 깨졌다는 것을 알려주고, 바로 이 추정이 우리의 예측이 됩니다. 복잡하게 들릴 수 있지만, 이러한 유추 추론은 기본적으로 거의 모든 인간 학습 과정의 기초이며 놀라운 속도로 이루어집니다.",
            "html": "그렇다면 충격 후 유리잔의 상태를 예측할 때 우리의 머릿속에서는 무슨 일이 일어났을까요? 우리는 이 사건의 특성들을 측정했습니다. 유리잔의 낙하를 설명하는 데이터를 수집했다고도 할 수 있습니다. 그런 다음 유사성 측정에 기반하여 이전에 떨어진 유리잔, 컵, 도자기 인형 또는 유사한 물건들과 매우 빠르게 유추했습니다. 이를 위해 두 가지가 필요합니다: 첫째, 이전 사건의 데이터도 갖고 있어야 하고, 둘째, 현재 데이터와 과거 데이터 사이의 유사성이 어떻게 정의되는지 알고 있어야 합니다. 궁극적으로 우리는 이미 발생한 가장 유사한 사건들을 살펴봄으로써 추정이나 예측을 할 수 있습니다. 이러한 경우에 떨어진 물건이 깨졌는지 아닌지를 살펴보는 것입니다. 먼저 가장 유사한 사건들을 찾아야 하는데, 이것은 일종의 최적화를 나타냅니다. 여기서 \"최적화\"라는 용어를 사용하는 이유는, 유사성을 최대화하든, 기업의 매출을 최대화하든, 그 외 무엇이든 간에 - 해당 변수, 여기서는 유사성이 항상 최적화되기 때문입니다. 위에서 설명한 유추 추론은 우리가 이미 관찰한 대다수의 유리잔이 깨졌다는 것을 알려주고, 바로 이 추정이 우리의 예측이 됩니다. 복잡하게 들릴 수 있지만, 이러한 유추 추론은 기본적으로 거의 모든 인간 학습 과정의 기초이며 놀라운 속도로 이루어집니다. "
          },
          {
            "type": "paragraph",
            "text": "흥미로운 점은 우리가 방금 인간 데이터 마이닝 방법론으로서 행동했다는 것입니다. 데이터 분석은 일반적으로 사건이나 상태의 표현과 이로부터 나오는 데이터, 사건 간 유사성의 정의, 그리고 이 유사성의 최적화와 같은 문제를 다루기 때문입니다.",
            "html": "흥미로운 점은 우리가 방금 인간 데이터 마이닝 방법론으로서 행동했다는 것입니다. 데이터 분석은 일반적으로 사건이나 상태의 표현과 이로부터 나오는 데이터, 사건 간 유사성의 정의, 그리고 이 유사성의 최적화와 같은 문제를 다루기 때문입니다. "
          },
          {
            "type": "paragraph",
            "text": "그러나 위에서 설명한 유추 추론 절차는 동전 던지기에는 적용할 수 없습니다: 첫 번째 단계에서 이미 대개 불충분하며, 재질 특성이나",
            "html": "그러나 위에서 설명한 유추 추론 절차는 동전 던지기에는 적용할 수 없습니다: 첫 번째 단계에서 이미 대개 불충분하며, 재질 특성이나 "
          },
          {
            "type": "paragraph",
            "text": "바닥의 불균일함과 같은 요인의 데이터를 기록할 수 없습니다. 따라서 나중의 유추 추론을 위해 이를 준비해 둘 수 없습니다. 그렇다고 해서 동전 던지기라는 사건이 우연이라는 뜻은 전혀 아니며, 단지 우리 인간이 이러한 영향 요인들을 측정하고 과정을 기술할 수 없다는 것을 보여줄 뿐입니다. 다른 경우에는 영향 요인을 충분히 측정할 수 있지만, 이를 의미 있게 상호 연관시킬 수 없어서 유사성을 계산하거나 과정을 기술하는 것이 불가능한 경우도 있습니다.",
            "html": "바닥의 불균일함과 같은 요인의 데이터를 기록할 수 없습니다. 따라서 나중의 유추 추론을 위해 이를 준비해 둘 수 없습니다. 그렇다고 해서 동전 던지기라는 사건이 우연이라는 뜻은 전혀 아니며, 단지 우리 인간이 이러한 영향 요인들을 측정하고 과정을 기술할 수 없다는 것을 보여줄 뿐입니다. 다른 경우에는 영향 요인을 충분히 측정할 수 있지만, 이를 의미 있게 상호 연관시킬 수 없어서 유사성을 계산하거나 과정을 기술하는 것이 불가능한 경우도 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "유추 추론만이 이미 알려진 정보로부터 새로운 상황에 대한 예측을 도출하는 유일한 방법은 결코 아닙니다. 떨어지는 유리잔을 관찰한 사람에게 유리잔이 깨질 것을 어떻게 알았는지 물으면, \"1.5미터 이상 높이에서 유리잔이 떨어지는 것을 볼 때마다 항상 깨졌다\"와 같은 대답을 자주 듣게 됩니다. 여기서 두 가지 흥미로운 점이 있습니다: \"항상\"이라는 용어를 사용한 과거 경험과의 연관, 그리고 이러한 경험으로부터 규칙을 도출한다는 점입니다:",
            "html": "유추 추론만이 이미 알려진 정보로부터 새로운 상황에 대한 예측을 도출하는 유일한 방법은 결코 아닙니다. 떨어지는 유리잔을 관찰한 사람에게 유리잔이 깨질 것을 어떻게 알았는지 물으면, \"1.5미터 이상 높이에서 유리잔이 떨어지는 것을 볼 때마다 항상 깨졌다\"와 같은 대답을 자주 듣게 됩니다. 여기서 두 가지 흥미로운 점이 있습니다: \"항상\"이라는 용어를 사용한 과거 경험과의 연관, 그리고 이러한 경험으로부터 규칙을 도출한다는 점입니다: "
          },
          {
            "type": "paragraph",
            "text": "떨어지는 물건이 유리로 되어 있고 낙하 높이가 1.5미터 이상이면, 유리잔은 깨진다.",
            "html": "떨어지는 물건이 유리로 되어 있고 낙하 높이가 1.5미터 이상이면, 유리잔은 깨진다. "
          },
          {
            "type": "paragraph",
            "text": "1.5미터와 같은 임계값의 도입은 이 규칙 형성의 매력적인 측면입니다. 더 높은 높이에서 모든 유리잔이 즉시 깨지는 것은 아니고, 낮은 높이에서 반드시 온전하게 남는 것도 아니지만, 이 임계값을 도입함으로써 규칙은 항상은 아니더라도 대부분의 경우 상황을 올바르게 추정하게 해주는 경험 법칙으로 변환됩니다. 따라서 바로 유추 추론을 하는 대신 이 경험 법칙을 사용하면, 떨어지는 물건의 가장 가능한 미래에 대해 빠르게 결론에 도달할 수 있습니다. 유추 추론과 규칙 생성은 인간과 데이터 마이닝 방법이 새롭고 알려지지 않은 상황의 결과를 예측할 수 있는 첫 번째 두 가지 예입니다.",
            "html": "1.5미터와 같은 임계값의 도입은 이 규칙 형성의 매력적인 측면입니다. 더 높은 높이에서 모든 유리잔이 즉시 깨지는 것은 아니고, 낮은 높이에서 반드시 온전하게 남는 것도 아니지만, 이 임계값을 도입함으로써 규칙은 항상은 아니더라도 대부분의 경우 상황을 올바르게 추정하게 해주는 경험 법칙으로 변환됩니다. 따라서 바로 유추 추론을 하는 대신 이 경험 법칙을 사용하면, 떨어지는 물건의 가장 가능한 미래에 대해 빠르게 결론에 도달할 수 있습니다. 유추 추론과 규칙 생성은 인간과 데이터 마이닝 방법이 새롭고 알려지지 않은 상황의 결과를 예측할 수 있는 첫 번째 두 가지 예입니다. "
          },
          {
            "type": "paragraph",
            "text": "우리 머릿속에서, 그리고 컴퓨터상의 대부분의 데이터 마이닝 방법에서 일어나는 일에 대한 설명은 또 다른 흥미로운 통찰을 드러냅니다: 위에서 설명한 유추 추론은 유리잔이 왜 깨지는지를 설명하기 위해 어떤 물리 공식의 지식도 필요로 하지 않습니다. 위에서 설명한 경험 법칙도 마찬가지입니다. 따라서 과정에 대한 완전한 (물리적) 설명을 알지 못하더라도, 우리와 데이터 마이닝 방법은 동등하게",
            "html": "우리 머릿속에서, 그리고 컴퓨터상의 대부분의 데이터 마이닝 방법에서 일어나는 일에 대한 설명은 또 다른 흥미로운 통찰을 드러냅니다: 위에서 설명한 유추 추론은 유리잔이 왜 깨지는지를 설명하기 위해 어떤 물리 공식의 지식도 필요로 하지 않습니다. 위에서 설명한 경험 법칙도 마찬가지입니다. 따라서 과정에 대한 완전한 (물리적) 설명을 알지 못하더라도, 우리와 데이터 마이닝 방법은 동등하게 "
          },
          {
            "type": "paragraph",
            "text": "상황에 대한 추정이나 심지어 예측을 생성할 수 있습니다. 여기서는 인과관계 자체가 기술되지 않았을 뿐만 아니라, 데이터 수집마저도 피상적이고 대략적이었으며, 떨어지는 물건의 재질(유리)과 낙하 높이(약 2m) 등 몇 가지 요인만 표시되었고, 그마저도 상당히 부정확했습니다.",
            "html": "상황에 대한 추정이나 심지어 예측을 생성할 수 있습니다. 여기서는 인과관계 자체가 기술되지 않았을 뿐만 아니라, 데이터 수집마저도 피상적이고 대략적이었으며, 떨어지는 물건의 재질(유리)과 낙하 높이(약 2m) 등 몇 가지 요인만 표시되었고, 그마저도 상당히 부정확했습니다. "
          },
          {
            "type": "paragraph",
            "text": "따라서 인과 사슬은 우리가 알든 모르든 존재합니다. 후자의 경우 우리는 종종 이를 우연이라고 부르는 경향이 있습니다. 그리고 마찬가지로 놀라운 점은, 알려지지 않은 인과 사슬에 대해서도, 심지어 과거 사실이 불완전하고 부정확하게만 기술된 상황에서도, 향후 전개를 기술하는 것이 가능하다는 것입니다.",
            "html": "따라서 인과 사슬은 우리가 알든 모르든 존재합니다. 후자의 경우 우리는 종종 이를 우연이라고 부르는 경향이 있습니다. 그리고 마찬가지로 놀라운 점은, 알려지지 않은 인과 사슬에 대해서도, 심지어 과거 사실이 불완전하고 부정확하게만 기술된 상황에서도, 향후 전개를 기술하는 것이 가능하다는 것입니다. "
          },
          {
            "type": "paragraph",
            "text": "이 절에서는 본 서적에서 다루고자 하는 문제의 종류에 대한 개요를 제시했습니다. 우리는 수많은 영향 요인을 다루게 될 것이며, 그 중 일부는 불충분하게만 측정되거나 전혀 측정할 수 없는 것들입니다. 동시에 이러한 요인의 수가 너무 많아 전체를 파악하기 어려울 위험이 있습니다. 또한, 모델링에 사용하고자 하는 이미 발생한 사건들도 다루어야 하며, 그 수는 수백만 또는 수십억에 쉽게 이릅니다. 마지막으로 중요한 것은, 과정을 기술하는 것이 목표인지, 아니면 유추 추론만으로 예측을 하기에 충분한지를 자문해야 한다는 것입니다. 게다가 이 모든 것이 끊임없이 변화하는 조건하에서의 동적 환경에서, 가능한 한 빠르게 이루어져야 합니다. 인간에게는 불가능할까요? 맞습니다. 하지만 데이터 마이닝 방법에게는 불가능하지 않습니다.",
            "html": "이 절에서는 본 서적에서 다루고자 하는 문제의 종류에 대한 개요를 제시했습니다. 우리는 수많은 영향 요인을 다루게 될 것이며, 그 중 일부는 불충분하게만 측정되거나 전혀 측정할 수 없는 것들입니다. 동시에 이러한 요인의 수가 너무 많아 전체를 파악하기 어려울 위험이 있습니다. 또한, 모델링에 사용하고자 하는 이미 발생한 사건들도 다루어야 하며, 그 수는 수백만 또는 수십억에 쉽게 이릅니다. 마지막으로 중요한 것은, 과정을 기술하는 것이 목표인지, 아니면 유추 추론만으로 예측을 하기에 충분한지를 자문해야 한다는 것입니다. 게다가 이 모든 것이 끊임없이 변화하는 조건하에서의 동적 환경에서, 가능한 한 빠르게 이루어져야 합니다. 인간에게는 불가능할까요? 맞습니다. 하지만 데이터 마이닝 방법에게는 불가능하지 않습니다. "
          }
        ],
        "subsections": []
      },
      {
        "id": "1-2-fundamental-terms",
        "number": "1.2",
        "title": "기본 용어",
        "blocks": [
          {
            "type": "paragraph",
            "text": "이제 앞서 설명한 문제들을 더 쉽게 다룰 수 있도록 해주는 몇 가지 기본 용어를 소개하겠습니다. RapidMiner 소프트웨어에서도 이러한 용어들을 반복적으로 접하게 되므로, 숙련된 데이터 분석가라 하더라도 사용되는 용어에 익숙해지는 것이 좋습니다.",
            "html": "이제 앞서 설명한 문제들을 더 쉽게 다룰 수 있도록 해주는 몇 가지 기본 용어를 소개하겠습니다. RapidMiner 소프트웨어에서도 이러한 용어들을 반복적으로 접하게 되므로, 숙련된 데이터 분석가라 하더라도 사용되는 용어에 익숙해지는 것이 좋습니다. "
          },
          {
            "type": "paragraph",
            "text": "먼저 이전 절에서 살펴본 두 가지 예, 즉 동전 던지기와 떨어지는 유리잔의 공통점을 살펴봅시다. 각 상황의 결과를 예측할 수 있는지에 대한 논의에서 우리는",
            "html": "먼저 이전 절에서 살펴본 두 가지 예, 즉 동전 던지기와 떨어지는 유리잔의 공통점을 살펴봅시다. 각 상황의 결과를 예측할 수 있는지에 대한 논의에서 우리는 "
          },
          {
            "type": "paragraph",
            "text": "재질 특성이나 바닥의 특성과 같은 영향 요인을 가능한 한 정확하게 아는 것이 중요하다는 것을 깨달았습니다. 그리고 이 책이 여러분에게 도움이 될지 여부도, 독자인 여러분의 특성을 기록하고 이전 독자들의 설문조사 결과와 비교함으로써 답을 구할 수 있습니다. 이러한 측정된 독자 특성으로는 예를 들어 해당 인물의 교육 배경, 통계학에 대한 선호도, 다른 유사한 서적에 대한 선호도 및 설문조사의 일부로 측정할 수 있는 기타 특징들이 있을 수 있습니다. 만약 100명의 독자에 대해 이러한 특성을 알고 있고, 이들이 이 책을 좋아하는지 여부에 대한 정보도 추가로 가지고 있다면, 이후 과정은 거의 간단해집니다. 여러분에게도 설문조사의 질문들을 하여 동일한 특징을 측정하고, 위에서 설명한 유추 추론 등을 사용하여 여러분 개인의 취향에 대한 신뢰할 수 있는 예측을 생성할 수 있을 것입니다. \"이 책을 구매한 고객은 다음 책도 구매했습니다...\" 이런 문구가 익숙하시죠.",
            "html": "재질 특성이나 바닥의 특성과 같은 영향 요인을 가능한 한 정확하게 아는 것이 중요하다는 것을 깨달았습니다. 그리고 이 책이 여러분에게 도움이 될지 여부도, 독자인 여러분의 특성을 기록하고 이전 독자들의 설문조사 결과와 비교함으로써 답을 구할 수 있습니다. 이러한 측정된 독자 특성으로는 예를 들어 해당 인물의 교육 배경, 통계학에 대한 선호도, 다른 유사한 서적에 대한 선호도 및 설문조사의 일부로 측정할 수 있는 기타 특징들이 있을 수 있습니다. 만약 100명의 독자에 대해 이러한 특성을 알고 있고, 이들이 이 책을 좋아하는지 여부에 대한 정보도 추가로 가지고 있다면, 이후 과정은 거의 간단해집니다. 여러분에게도 설문조사의 질문들을 하여 동일한 특징을 측정하고, 위에서 설명한 유추 추론 등을 사용하여 여러분 개인의 취향에 대한 신뢰할 수 있는 예측을 생성할 수 있을 것입니다. \"이 책을 구매한 고객은 다음 책도 구매했습니다...\" 이런 문구가 익숙하시죠. "
          }
        ],
        "subsections": [
          {
            "id": "1-2-1-attributes-and-target-attributes",
            "number": "1.2.1",
            "title": "속성과 목표 속성",
            "blocks": [
              {
                "type": "paragraph",
                "text": "동전이든, 낙하하는 물건이든, 심지어 사람이든, 앞서 언급했듯이 모든 시나리오에서는 해당 상황의 특성이나 특징에 대한 질문이 있습니다. 이러한 시나리오를 설명하는 요인들을 지칭할 때, 이후로 항상 속성(attribute)이라는 용어를 사용하겠습니다. 이것은 이러한 설명적 특징이 나타날 때 RapidMiner 소프트웨어에서도 항상 사용되는 용어입니다. 이 용어에는 많은 동의어가 있으며, 여러분의 배경에 따라 \"속성\" 대신 다양한 용어를 접해보셨을 것입니다. 예를 들면",
                "html": "동전이든, 낙하하는 물건이든, 심지어 사람이든, 앞서 언급했듯이 모든 시나리오에서는 해당 상황의 특성이나 특징에 대한 질문이 있습니다. 이러한 시나리오를 설명하는 요인들을 지칭할 때, 이후로 항상 속성(attribute)이라는 용어를 사용하겠습니다. 이것은 이러한 설명적 특징이 나타날 때 RapidMiner 소프트웨어에서도 항상 사용되는 용어입니다. 이 용어에는 많은 동의어가 있으며, 여러분의 배경에 따라 \"속성\" 대신 다양한 용어를 접해보셨을 것입니다. 예를 들면 "
              },
              {
                "type": "paragraph",
                "text": "• 특성(Characteristic),",
                "html": "• 특성(Characteristic), "
              },
              {
                "type": "paragraph",
                "text": "• 특징(Feature),",
                "html": "• 특징(Feature), "
              },
              {
                "type": "paragraph",
                "text": "• 영향 요인(또는 단순히 요인),",
                "html": "• 영향 요인(또는 단순히 요인), "
              },
              {
                "type": "paragraph",
                "text": "• 지표(Indicator),",
                "html": "• 지표(Indicator), "
              },
              {
                "type": "paragraph",
                "text": "• 변수(Variable) 또는",
                "html": "• 변수(Variable) 또는 "
              },
              {
                "type": "paragraph",
                "text": "• 신호(Signal).",
                "html": "• 신호(Signal). "
              },
              {
                "type": "paragraph",
                "text": "속성에 의한 기술은 과정과 상황 모두에 대해 가능하다는 것을 알 수 있었습니다. 이것은 예를 들어 기술 프로세스의 기술에 필요하며, 떨어지는 유리잔의 사례와 크게 다르지 않습니다. 이러한 상황의 결과를 예측할 수 있다면, 생산된 부품의 품질은 왜 예측할 수 없겠습니까? 또는 기계의 임박한 고장은요? 기술적 연관이 없는 다른 과정이나 상황도 같은 방식으로 기술할 수 있습니다. 영업이나 마케팅 캠페인의 성공을 어떻게 예측할 수 있을까요? 고객이 다음에 어떤 상품을 구매할까요? 특정 고객이나 고객 그룹에 대해 보험 회사가 앞으로 얼마나 더 많은 사고를 보상해야 할까요?",
                "html": "속성에 의한 기술은 과정과 상황 모두에 대해 가능하다는 것을 알 수 있었습니다. 이것은 예를 들어 기술 프로세스의 기술에 필요하며, 떨어지는 유리잔의 사례와 크게 다르지 않습니다. 이러한 상황의 결과를 예측할 수 있다면, 생산된 부품의 품질은 왜 예측할 수 없겠습니까? 또는 기계의 임박한 고장은요? 기술적 연관이 없는 다른 과정이나 상황도 같은 방식으로 기술할 수 있습니다. 영업이나 마케팅 캠페인의 성공을 어떻게 예측할 수 있을까요? 고객이 다음에 어떤 상품을 구매할까요? 특정 고객이나 고객 그룹에 대해 보험 회사가 앞으로 얼마나 더 많은 사고를 보상해야 할까요? "
              },
              {
                "type": "paragraph",
                "text": "나머지 중요한 용어들을 소개하기 위해 이러한 고객 시나리오를 사용하겠습니다. 첫째, 사람은 다른 사람에 대한 예시를 더 잘 이해하기 때문입니다. 둘째, 모든 기업은 고객에 대한 정보, 즉 속성을 갖고 있으며, 대부분의 독자가 예시에 즉시 공감할 수 있기 때문입니다. 거의 모든 기업이 고객에 대해 최소한으로 보유하는 속성은 예를 들어 지리 데이터와 고객이 이미 구매한 제품 또는 서비스에 대한 정보입니다. 이렇게 적은 수의 속성으로도 어떤 예측이 가능한지 알면 놀라실 것입니다.",
                "html": "나머지 중요한 용어들을 소개하기 위해 이러한 고객 시나리오를 사용하겠습니다. 첫째, 사람은 다른 사람에 대한 예시를 더 잘 이해하기 때문입니다. 둘째, 모든 기업은 고객에 대한 정보, 즉 속성을 갖고 있으며, 대부분의 독자가 예시에 즉시 공감할 수 있기 때문입니다. 거의 모든 기업이 고객에 대해 최소한으로 보유하는 속성은 예를 들어 지리 데이터와 고객이 이미 구매한 제품 또는 서비스에 대한 정보입니다. 이렇게 적은 수의 속성으로도 어떤 예측이 가능한지 알면 놀라실 것입니다. "
              },
              {
                "type": "paragraph",
                "text": "(다소 인위적인) 예를 하나 살펴봅시다. 여러분이 고객의 요구에 더 잘 맞는 제품을 향후 제공하고자 하는 기업에서 근무한다고 가정합시다. 100명의 고객만을 대상으로 한 고객 조사에서 62명이 공유하는 몇 가지 요구사항이 분명해졌습니다. 연구개발 부서가 즉시 착수하여 이러한 새로운 요구를 더 잘 충족시킬 새 제품을 최단 시간 내에 개발했습니다. 해당 요구 프로필을 가진 62명 고객 대부분은 프로토타입에 확실히 감명을 받았고, 예상대로 나머지 참가자 대부분은 적은 관심만 보였습니다. 그래도 조사 대상 100명 고객 중 총 54명이 새 제품이 유용하다고 답했습니다. 따라서 프로토타입은 성공적으로 평가되어 생산에 들어갑니다 - 이제 기존 고객 또는 기타 잠재 고객 중에서 후속 마케팅 및 영업 활동이 가장 큰 성공을 약속하는 고객을 정확히 어떻게 골라낼 것인가 하는 문제만 남아 있습니다. 따라서 이 분야에서 효율성을 최적화하고 싶으시겠지요. 이는",
                "html": "(다소 인위적인) 예를 하나 살펴봅시다. 여러분이 고객의 요구에 더 잘 맞는 제품을 향후 제공하고자 하는 기업에서 근무한다고 가정합시다. 100명의 고객만을 대상으로 한 고객 조사에서 62명이 공유하는 몇 가지 요구사항이 분명해졌습니다. 연구개발 부서가 즉시 착수하여 이러한 새로운 요구를 더 잘 충족시킬 새 제품을 최단 시간 내에 개발했습니다. 해당 요구 프로필을 가진 62명 고객 대부분은 프로토타입에 확실히 감명을 받았고, 예상대로 나머지 참가자 대부분은 적은 관심만 보였습니다. 그래도 조사 대상 100명 고객 중 총 54명이 새 제품이 유용하다고 답했습니다. 따라서 프로토타입은 성공적으로 평가되어 생산에 들어갑니다 - 이제 기존 고객 또는 기타 잠재 고객 중에서 후속 마케팅 및 영업 활동이 가장 큰 성공을 약속하는 고객을 정확히 어떻게 골라낼 것인가 하는 문제만 남아 있습니다. 따라서 이 분야에서 효율성을 최적화하고 싶으시겠지요. 이는 "
              },
              {
                "type": "paragraph",
                "text": "특히 구매로 이어질 가능성이 낮은 노력을 처음부터 배제하는 것을 의미합니다. 하지만 어떻게 가능할까요? 대체 솔루션에 대한 요구와 따라서 새 제품에 대한 관심은 고객 조사에서 고객의 일부분에 대해 나타났습니다. 모든 고객에 대해 이 조사를 수행하는 것은 비용이 너무 많이 들므로 이 방법은 사용할 수 없습니다. 바로 이 지점에서 데이터 마이닝이 도움을 줄 수 있습니다. 먼저 고객에 대한 가능한 속성 목록을 살펴봅시다:",
                "html": "특히 구매로 이어질 가능성이 낮은 노력을 처음부터 배제하는 것을 의미합니다. 하지만 어떻게 가능할까요? 대체 솔루션에 대한 요구와 따라서 새 제품에 대한 관심은 고객 조사에서 고객의 일부분에 대해 나타났습니다. 모든 고객에 대해 이 조사를 수행하는 것은 비용이 너무 많이 들므로 이 방법은 사용할 수 없습니다. 바로 이 지점에서 데이터 마이닝이 도움을 줄 수 있습니다. 먼저 고객에 대한 가능한 속성 목록을 살펴봅시다: "
              },
              {
                "type": "paragraph",
                "text": "• 이름",
                "html": "• 이름 "
              },
              {
                "type": "paragraph",
                "text": "• 주소",
                "html": "• 주소 "
              },
              {
                "type": "paragraph",
                "text": "• 업종",
                "html": "• 업종 "
              },
              {
                "type": "paragraph",
                "text": "• 세부 업종",
                "html": "• 세부 업종 "
              },
              {
                "type": "paragraph",
                "text": "• 직원 수",
                "html": "• 직원 수 "
              },
              {
                "type": "paragraph",
                "text": "• 제품 그룹 1의 구매 건수",
                "html": "• 제품 그룹 1의 구매 건수 "
              },
              {
                "type": "paragraph",
                "text": "• 제품 그룹 2의 구매 건수",
                "html": "• 제품 그룹 2의 구매 건수 "
              },
              {
                "type": "paragraph",
                "text": "서로 다른 제품 그룹의 구매 건수는 과거에 해당 고객과 해당 제품 그룹에서 이루어진 거래를 의미합니다. 여러분의 경우에는 물론 이보다 더 많거나 적거나 완전히 다른 속성이 있을 수 있지만, 이 단계에서는 그것이 중요하지 않습니다. 이러한 속성에 대한 정보를 모든 고객에 대해 보유하고 있다고 가정합시다. 그러면 우리의 구체적인 시나리오에서 살펴볼 수 있는 또 다른 속성이 있습니다: 고객이 프로토타입을 좋아하는지 여부입니다. 이 속성은 물론 조사에 참여한 100명의 고객에 대해서만 사용할 수 있으며, 나머지 고객에 대해서는 이 속성의 정보가 단순히 알려져 있지 않습니다. 그럼에도 불구하고 이 속성도 속성 목록에 포함합니다:",
                "html": "서로 다른 제품 그룹의 구매 건수는 과거에 해당 고객과 해당 제품 그룹에서 이루어진 거래를 의미합니다. 여러분의 경우에는 물론 이보다 더 많거나 적거나 완전히 다른 속성이 있을 수 있지만, 이 단계에서는 그것이 중요하지 않습니다. 이러한 속성에 대한 정보를 모든 고객에 대해 보유하고 있다고 가정합시다. 그러면 우리의 구체적인 시나리오에서 살펴볼 수 있는 또 다른 속성이 있습니다: 고객이 프로토타입을 좋아하는지 여부입니다. 이 속성은 물론 조사에 참여한 100명의 고객에 대해서만 사용할 수 있으며, 나머지 고객에 대해서는 이 속성의 정보가 단순히 알려져 있지 않습니다. 그럼에도 불구하고 이 속성도 속성 목록에 포함합니다: "
              },
              {
                "type": "paragraph",
                "text": "• 프로토타입 긍정적 반응 여부",
                "html": "• 프로토타입 긍정적 반응 여부 "
              },
              {
                "type": "paragraph",
                "text": "• 이름",
                "html": "• 이름 "
              },
              {
                "type": "paragraph",
                "text": "• 주소",
                "html": "• 주소 "
              },
              {
                "type": "paragraph",
                "text": "• 업종",
                "html": "• 업종 "
              },
              {
                "type": "paragraph",
                "text": "• 세부 업종",
                "html": "• 세부 업종 "
              },
              {
                "type": "paragraph",
                "text": "• 직원 수",
                "html": "• 직원 수 "
              },
              {
                "type": "paragraph",
                "text": "• 제품 그룹 1의 구매 건수",
                "html": "• 제품 그룹 1의 구매 건수 "
              },
              {
                "type": "paragraph",
                "text": "• 제품 그룹 2의 구매 건수",
                "html": "• 제품 그룹 2의 구매 건수 "
              },
              {
                "type": "paragraph",
                "text": "총 수천 명의 고객이 있다고 가정하면, 이 중 100명에 대해서만 프로토타입을 긍정적으로 평가했는지 여부를 표시할 수 있습니다. 나머지 고객이 어떻게 생각하는지는 아직 모르지만, 알고 싶은 것입니다! 따라서 \"프로토타입 긍정적 반응 여부\" 속성은 현재 질문과 관련하여 모든 고객을 식별하므로 특별한 역할을 합니다. 이 특별한 속성을 레이블(label)이라고도 부릅니다. 셔츠의 브랜드 라벨이나 게시판의 메모처럼 고객에게 붙어서 이들을 식별하기 때문입니다. RapidMiner에서도 이 특별한 역할을 하는 속성을 \"label\"이라는 이름으로 찾을 수 있습니다. 우리 노력의 목표는 모든 고객의 전체 집합에 대해 이 특정 속성을 채우는 것입니다. 따라서 본 서적에서는 \"label\"이라는 용어 대신 목표 속성(target attribute)이라는 용어도 자주 사용할 것입니다. 문헌에서는 동일한 의미의 목표 변수(goal variable)라는 용어도 자주 발견하실 것입니다.",
                "html": "총 수천 명의 고객이 있다고 가정하면, 이 중 100명에 대해서만 프로토타입을 긍정적으로 평가했는지 여부를 표시할 수 있습니다. 나머지 고객이 어떻게 생각하는지는 아직 모르지만, 알고 싶은 것입니다! 따라서 \"프로토타입 긍정적 반응 여부\" 속성은 현재 질문과 관련하여 모든 고객을 식별하므로 특별한 역할을 합니다. 이 특별한 속성을 레이블(label)이라고도 부릅니다. 셔츠의 브랜드 라벨이나 게시판의 메모처럼 고객에게 붙어서 이들을 식별하기 때문입니다. RapidMiner에서도 이 특별한 역할을 하는 속성을 \"label\"이라는 이름으로 찾을 수 있습니다. 우리 노력의 목표는 모든 고객의 전체 집합에 대해 이 특정 속성을 채우는 것입니다. 따라서 본 서적에서는 \"label\"이라는 용어 대신 목표 속성(target attribute)이라는 용어도 자주 사용할 것입니다. 문헌에서는 동일한 의미의 목표 변수(goal variable)라는 용어도 자주 발견하실 것입니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "1-2-2-concepts-and-examples",
            "number": "1.2.2",
            "title": "개념과 예제",
            "blocks": [
              {
                "type": "paragraph",
                "text": "위에서 소개한 속성에 의한 고객 특성의 구조화는 이미 문제를 좀 더 분석적으로 다루는 데 도움이 됩니다. 이 방법을 통해 모든 고객이 동일한 방식으로 표현되도록 했습니다. 어떤 의미에서 우리는 \"고객\"이라는 유형 또는 개념(concept)을 정의한 것입니다. 이 개념은 \"낙하하는 물건\"과 같은 다른 개념과는 상당히 다릅니다. 고객은 일반적으로 재질 특성을 갖지 않으며, 낙하하는 물건은 제품 그룹 1에서 구매하는 경우가 거의 없을 것이기 때문입니다. 중요한 것은 본 서적(또는 여러분의 실무)의 각 문제에 대해 먼저 실제로 어떤 개념을 다루고 있으며, 이들이 어떤 속성에 의해 정의되는지를 먼저 설정하는 것입니다.",
                "html": "위에서 소개한 속성에 의한 고객 특성의 구조화는 이미 문제를 좀 더 분석적으로 다루는 데 도움이 됩니다. 이 방법을 통해 모든 고객이 동일한 방식으로 표현되도록 했습니다. 어떤 의미에서 우리는 \"고객\"이라는 유형 또는 개념(concept)을 정의한 것입니다. 이 개념은 \"낙하하는 물건\"과 같은 다른 개념과는 상당히 다릅니다. 고객은 일반적으로 재질 특성을 갖지 않으며, 낙하하는 물건은 제품 그룹 1에서 구매하는 경우가 거의 없을 것이기 때문입니다. 중요한 것은 본 서적(또는 여러분의 실무)의 각 문제에 대해 먼저 실제로 어떤 개념을 다루고 있으며, 이들이 어떤 속성에 의해 정의되는지를 먼저 설정하는 것입니다. "
              },
              {
                "type": "paragraph",
                "text": "위에서 이름, 주소, 업종 등의 속성과",
                "html": "위에서 이름, 주소, 업종 등의 속성과"
              },
              {
                "type": "paragraph",
                "text": "특히 개별 제품 그룹에서의 구매 거래를 표시함으로써, \"고객\"이라는 개념의 객체가 이러한 속성에 의해 기술된다는 것을 암묵적으로 정의했습니다. 그러나 이 개념은 아직까지 상당히 추상적인 상태로 남아 있으며, 아직 구체화되지 않았습니다. 이제 고객을 어떤 방식으로 기술할 수 있는지는 알지만, 특정 고객에 대해 이를 아직 수행하지 않았습니다. 예를 들어 다음 고객의 속성을 살펴봅시다:",
                "html": "특히 개별 제품 그룹에서의 구매 거래를 표시함으로써, \"고객\"이라는 개념의 객체가 이러한 속성에 의해 기술된다는 것을 암묵적으로 정의했습니다. 그러나 이 개념은 아직까지 상당히 추상적인 상태로 남아 있으며, 아직 구체화되지 않았습니다. 이제 고객을 어떤 방식으로 기술할 수 있는지는 알지만, 특정 고객에 대해 이를 아직 수행하지 않았습니다. 예를 들어 다음 고객의 속성을 살펴봅시다: "
              },
              {
                "type": "paragraph",
                "text": "• 프로토타입 긍정적 반응 여부: 예",
                "html": "• 프로토타입 긍정적 반응 여부: 예 "
              },
              {
                "type": "paragraph",
                "text": "• 이름: Doe Systems, Inc.",
                "html": "• 이름: Doe Systems, Inc. "
              },
              {
                "type": "paragraph",
                "text": "• 주소: 76 Any Street, Sunnyville, Massachusetts",
                "html": "• 주소: 76 Any Street, Sunnyville, Massachusetts "
              },
              {
                "type": "paragraph",
                "text": "• 업종: 기계",
                "html": "• 업종: 기계 "
              },
              {
                "type": "paragraph",
                "text": "• 세부 업종: 파이프 벤딩 기계",
                "html": "• 세부 업종: 파이프 벤딩 기계 "
              },
              {
                "type": "paragraph",
                "text": "• 직원 수: > 1000",
                "html": "• 직원 수: > 1000 "
              },
              {
                "type": "paragraph",
                "text": "• 제품 그룹 1의 구매 건수: 5",
                "html": "• 제품 그룹 1의 구매 건수: 5 "
              },
              {
                "type": "paragraph",
                "text": "• 제품 그룹 2의 구매 건수: 0",
                "html": "• 제품 그룹 2의 구매 건수: 0 "
              },
              {
                "type": "paragraph",
                "text": "이 특정 고객을 우리의 \"고객\" 개념에 대한 예제(example)라고 합니다. 각 예제는 속성에 의해 특성화될 수 있으며, 다른 예제의 값과 비교할 수 있는 구체적인 속성값을 갖습니다. 위에서 설명한 경우, Doe Systems, Inc.는 우리 조사에 참여한 고객의 예제이기도 합니다. 따라서 목표 속성 \"프로토타입 긍정적 반응 여부?\"에 대한 값이 존재합니다. Doe Systems는 만족했으며, 여기서 \"예\"라는 속성값을 갖습니다. 따라서 이를 양성 예제(positive example)라고도 합니다. 논리적으로, 음성 예제와 목표 속성에 대해 아무런 진술을 할 수 없는 예제도 있습니다.",
                "html": "이 특정 고객을 우리의 \"고객\" 개념에 대한 예제(example)라고 합니다. 각 예제는 속성에 의해 특성화될 수 있으며, 다른 예제의 값과 비교할 수 있는 구체적인 속성값을 갖습니다. 위에서 설명한 경우, Doe Systems, Inc.는 우리 조사에 참여한 고객의 예제이기도 합니다. 따라서 목표 속성 \"프로토타입 긍정적 반응 여부?\"에 대한 값이 존재합니다. Doe Systems는 만족했으며, 여기서 \"예\"라는 속성값을 갖습니다. 따라서 이를 양성 예제(positive example)라고도 합니다. 논리적으로, 음성 예제와 목표 속성에 대해 아무런 진술을 할 수 없는 예제도 있습니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "1-2-3-attribute-roles",
            "number": "1.2.3",
            "title": "속성 역할",
            "blocks": [
              {
                "type": "paragraph",
                "text": "이제 우리는 두 가지 다른 종류의 속성, 즉 단순히 예제를 기술하는 속성과 예제를 식별하는",
                "html": "이제 우리는 두 가지 다른 종류의 속성, 즉 단순히 예제를 기술하는 속성과 예제를 식별하는 "
              },
              {
                "type": "paragraph",
                "text": "속성에 대해 알게 되었습니다. 따라서 속성은 다양한 역할(role)을 가질 수 있습니다. 예제를 어떤 방식으로든 식별하며 아직 특성화되지 않은 새로운 예제에 대해 예측해야 하는 속성에 대해 \"레이블(label)\" 역할을 이미 소개했습니다. 위에서 설명한 시나리오에서 레이블은 (존재하는 경우) 프로토타입이 긍정적으로 수용되었는지 여부의 특성을 기술합니다.",
                "html": "속성에 대해 알게 되었습니다. 따라서 속성은 다양한 역할(role)을 가질 수 있습니다. 예제를 어떤 방식으로든 식별하며 아직 특성화되지 않은 새로운 예제에 대해 예측해야 하는 속성에 대해 \"레이블(label)\" 역할을 이미 소개했습니다. 위에서 설명한 시나리오에서 레이블은 (존재하는 경우) 프로토타입이 긍정적으로 수용되었는지 여부의 특성을 기술합니다. "
              },
              {
                "type": "paragraph",
                "text": "마찬가지로, 해당 속성이 예제를 고유하게 식별하는 역할도 있습니다. 이 경우 속성은 식별자(identifier) 역할을 하며, 줄여서 ID라고 합니다. RapidMiner 소프트웨어에서도 이 역할로 식별된 속성을 찾을 수 있습니다. 우리의 고객 시나리오에서는 \"이름\" 속성이 이러한 식별자 역할을 할 수 있습니다.",
                "html": "마찬가지로, 해당 속성이 예제를 고유하게 식별하는 역할도 있습니다. 이 경우 속성은 식별자(identifier) 역할을 하며, 줄여서 ID라고 합니다. RapidMiner 소프트웨어에서도 이 역할로 식별된 속성을 찾을 수 있습니다. 우리의 고객 시나리오에서는 \"이름\" 속성이 이러한 식별자 역할을 할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "레이블과 관련하여 예제의 가중치를 지정하는 속성과 같이 더 많은 역할이 있습니다. 이 경우 역할의 이름은 Weight입니다. 특별한 역할이 없는 속성, 즉 단순히 예제를 기술하는 속성은 일반 속성(regular attribute)이라고도 하며, 대부분의 경우 역할 지정을 생략합니다. 그 외에도 RapidMiner에서는 자체적인 역할을 할당하여 속성의 의미를 별도로 식별할 수 있습니다.",
                "html": "레이블과 관련하여 예제의 가중치를 지정하는 속성과 같이 더 많은 역할이 있습니다. 이 경우 역할의 이름은 Weight입니다. 특별한 역할이 없는 속성, 즉 단순히 예제를 기술하는 속성은 일반 속성(regular attribute)이라고도 하며, 대부분의 경우 역할 지정을 생략합니다. 그 외에도 RapidMiner에서는 자체적인 역할을 할당하여 속성의 의미를 별도로 식별할 수 있습니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "1-2-4-value-types",
            "number": "1.2.4",
            "title": "값 유형",
            "blocks": [
              {
                "type": "paragraph",
                "text": "속성의 다양한 역할 외에도 더 자세히 살펴볼 가치가 있는 속성의 두 번째 특성이 있습니다. 위의 Doe Systems 예제는 다양한 속성에 대한 각각의 값을 정의했습니다. 예를 들어 \"이름\" 속성에 대해 \"Doe Systems, Inc.\", 제품 그룹 1의 과거 구매 건수에 대해 \"5\"라는 값을 정의했습니다. \"이름\" 속성의 경우 이 예제의 구체적인 값은 어느 정도 임의의 자유 텍스트이며, \"제품 그룹 1의 구매 건수\" 속성의 경우에는 숫자를 지정해야 합니다. 속성의 값이 텍스트여야 하는지 숫자여야 하는지의 표시를 속성의 값 유형(Value Type)이라고 합니다.",
                "html": "속성의 다양한 역할 외에도 더 자세히 살펴볼 가치가 있는 속성의 두 번째 특성이 있습니다. 위의 Doe Systems 예제는 다양한 속성에 대한 각각의 값을 정의했습니다. 예를 들어 \"이름\" 속성에 대해 \"Doe Systems, Inc.\", 제품 그룹 1의 과거 구매 건수에 대해 \"5\"라는 값을 정의했습니다. \"이름\" 속성의 경우 이 예제의 구체적인 값은 어느 정도 임의의 자유 텍스트이며, \"제품 그룹 1의 구매 건수\" 속성의 경우에는 숫자를 지정해야 합니다. 속성의 값이 텍스트여야 하는지 숫자여야 하는지의 표시를 속성의 값 유형(Value Type)이라고 합니다. "
              },
              {
                "type": "paragraph",
                "text": "이후 장들에서 다양한 값 유형에 대해 알아보고, 이들이 다른 유형으로 변환될 수 있는 방법도 살펴볼 것입니다. 현재로서는",
                "html": "이후 장들에서 다양한 값 유형에 대해 알아보고, 이들이 다른 유형으로 변환될 수 있는 방법도 살펴볼 것입니다. 현재로서는 "
              },
              {
                "type": "paragraph",
                "text": "속성에 다양한 값 유형이 있다는 것, 자유 텍스트의 경우 텍스트(text) 값 유형, 숫자의 경우 수치(numerical) 값 유형, 가능한 값이 소수인 경우(목표 속성의 \"예\"와 \"아니오\" 두 가지 가능성과 같은) 명목(nominal) 값 유형이라고 한다는 것만 알면 됩니다. 위의 예에서 직원 수는 실제로는 수치 유형이지만, 1250명과 같은 정확한 수치 대신 \"> 1000\"과 같은 규모 등급이 사용되었으므로 오히려 명목형으로 정의되는 것이 적절합니다.",
                "html": "속성에 다양한 값 유형이 있다는 것, 자유 텍스트의 경우 텍스트(text) 값 유형, 숫자의 경우 수치(numerical) 값 유형, 가능한 값이 소수인 경우(목표 속성의 \"예\"와 \"아니오\" 두 가지 가능성과 같은) 명목(nominal) 값 유형이라고 한다는 것만 알면 됩니다. 위의 예에서 직원 수는 실제로는 수치 유형이지만, 1250명과 같은 정확한 수치 대신 \"> 1000\"과 같은 규모 등급이 사용되었으므로 오히려 명목형으로 정의되는 것이 적절합니다. "
              },
              {
                "type": "paragraph",
                "text": "다음 표는 RapidMiner에서 지원하는 모든 값 유형에 대한 개요를 제공합니다:",
                "html": "다음 표는 RapidMiner에서 지원하는 모든 값 유형에 대한 개요를 제공합니다: "
              },
              {
                "type": "table",
                "rows": [
                  [
                    "값 유형",
                    "RapidMiner 명칭",
                    "용도"
                  ],
                  [
                    "명목형",
                    "nominal",
                    "범주형 비수치 값으로, 일반적으로 유한한 수의 서로 다른 특성에 사용됨"
                  ],
                  [
                    "수치 값",
                    "numeric",
                    "일반적인 수치 값에 사용"
                  ],
                  [
                    "정수",
                    "integer",
                    "양수 및 음수의 정수"
                  ],
                  [
                    "실수",
                    "real",
                    "양수 및 음수의 실수"
                  ],
                  [
                    "텍스트",
                    "text",
                    "구조가 없는 임의의 자유 텍스트"
                  ],
                  [
                    "2값 명목형",
                    "binominal",
                    "두 개의 서로 다른 값만 허용되는 명목형의 특수한 경우"
                  ],
                  [
                    "다값 명목형",
                    "polynominal",
                    "두 개 이상의 서로 다른 값이 허용되는 명목형의 특수한 경우"
                  ],
                  [
                    "날짜 시간",
                    "date time",
                    "날짜와 시간 모두"
                  ],
                  [
                    "날짜",
                    "date",
                    "날짜만"
                  ],
                  [
                    "시간",
                    "time",
                    "시간만"
                  ]
                ]
              }
            ],
            "subsections": []
          },
          {
            "id": "1-2-5-data-and-meta-data",
            "number": "1.2.5",
            "title": "데이터와 메타 데이터",
            "blocks": [
              {
                "type": "paragraph",
                "text": "초기 상황을 한 번 더 정리해 봅시다. 우리는 \"고객\"이라는 개념(Concept)을 갖고 있으며, 이를 일련의 속성(Attribute)으로 기술합니다:",
                "html": "초기 상황을 한 번 더 정리해 봅시다. 우리는 \"고객\"이라는 개념(Concept)을 갖고 있으며, 이를 일련의 속성(Attribute)으로 기술합니다: "
              },
              {
                "type": "paragraph",
                "text": "• 프로토타입 긍정적 반응 여부? Label; Nominal",
                "html": "• 프로토타입 긍정적 반응 여부? Label; Nominal "
              },
              {
                "type": "paragraph",
                "text": "• 이름: Text",
                "html": "• 이름: Text "
              },
              {
                "type": "paragraph",
                "text": "• 주소: Text",
                "html": "• 주소: Text "
              },
              {
                "type": "paragraph",
                "text": "• 업종: Nominal",
                "html": "• 업종: Nominal "
              },
              {
                "type": "paragraph",
                "text": "• 세부 업종: Nominal",
                "html": "• 세부 업종: Nominal "
              },
              {
                "type": "paragraph",
                "text": "• 직원 수: Nominal",
                "html": "• 직원 수: Nominal "
              },
              {
                "type": "paragraph",
                "text": "• 제품 그룹 1의 구매 건수: Numerical",
                "html": "• 제품 그룹 1의 구매 건수: Numerical "
              },
              {
                "type": "paragraph",
                "text": "• 제품 그룹 2의 구매 건수: Numerical",
                "html": "• 제품 그룹 2의 구매 건수: Numerical "
              },
              {
                "type": "paragraph",
                "text": "\"프로토타입 긍정적 반응 여부?\" 속성은 속성들 중에서 특별한 역할(Role)을 합니다. 여기서 이 속성이 우리의 목표 속성(Target Attribute)입니다. 목표 속성의 값 유형(Value Type)은 Nominal이며, 이는 비교적 적은 수의 특성(이 경우 \"예\"와 \"아니오\")만 가능함을 의미합니다. 엄밀히 말하면 두 가지 서로 다른 특성만 허용되므로 binominal이기도 합니다. 나머지 속성들은 모두 특별한 역할이 없으며, 즉 일반 속성으로서 Numerical 또는 Text의 값 유형을 갖습니다. 다음 정의는 성공적인 전문 데이터 분석에서 핵심적인 역할을 하므로 매우 중요합니다:",
                "html": "\"프로토타입 긍정적 반응 여부?\" 속성은 속성들 중에서 특별한 역할(Role)을 합니다. 여기서 이 속성이 우리의 목표 속성(Target Attribute)입니다. 목표 속성의 값 유형(Value Type)은 Nominal이며, 이는 비교적 적은 수의 특성(이 경우 \"예\"와 \"아니오\")만 가능함을 의미합니다. 엄밀히 말하면 두 가지 서로 다른 특성만 허용되므로 binominal이기도 합니다. 나머지 속성들은 모두 특별한 역할이 없으며, 즉 일반 속성으로서 Numerical 또는 Text의 값 유형을 갖습니다. 다음 정의는 성공적인 전문 데이터 분석에서 핵심적인 역할을 하므로 매우 중요합니다: "
              },
              {
                "type": "paragraph",
                "text": "개념을 기술하는 이러한 정보의 총체를 메타 데이터(meta data)라고도 하는데, 이는 실제 데이터에 관한 데이터를 나타내기 때문입니다.",
                "html": "개념을 기술하는 이러한 정보의 총체를 메타 데이터(meta data)라고도 하는데, 이는 실제 데이터에 관한 데이터를 나타내기 때문입니다. "
              },
              {
                "type": "paragraph",
                "text": "우리의 가상 기업은 \"고객\" 개념에 대한 다수의 예제(Example)를 보유하고 있습니다. 즉, 기업이 고객 데이터베이스의 개별 속성에 대해 저장한 정보입니다. 목표는 이제 목표 속성에 대한 정보가 있는 예제들로부터, 나머지 고객들이 프로토타입을",
                "html": "우리의 가상 기업은 \"고객\" 개념에 대한 다수의 예제(Example)를 보유하고 있습니다. 즉, 기업이 고객 데이터베이스의 개별 속성에 대해 저장한 정보입니다. 목표는 이제 목표 속성에 대한 정보가 있는 예제들로부터, 나머지 고객들이 프로토타입을 "
              },
              {
                "type": "paragraph",
                "text": "긍정적으로 수용할 가능성이 높은지 아니면 거부할지를 예측해주는 예측 지침을 생성하는 것입니다. 이러한 예측 지침을 탐색하는 것이 데이터 마이닝으로 수행할 수 있는 과제 중 하나입니다.",
                "html": "긍정적으로 수용할 가능성이 높은지 아니면 거부할지를 예측해주는 예측 지침을 생성하는 것입니다. 이러한 예측 지침을 탐색하는 것이 데이터 마이닝으로 수행할 수 있는 과제 중 하나입니다. "
              },
              {
                "type": "paragraph",
                "text": "그러나 여기서 중요한 것은 개별 예제의 속성 정보가 정리된 형태로 있어서 데이터 마이닝 방법이 컴퓨터를 통해 접근할 수 있어야 한다는 것입니다. 여기서 테이블보다 더 적절한 것이 있을까요? 각 속성이 열을 정의하고, 각 예제와 그 다양한 속성값은 이 테이블의 행에 해당합니다. 우리의 시나리오에서는 예를 들어 표 1.1과 같이 보일 수 있습니다.",
                "html": "그러나 여기서 중요한 것은 개별 예제의 속성 정보가 정리된 형태로 있어서 데이터 마이닝 방법이 컴퓨터를 통해 접근할 수 있어야 한다는 것입니다. 여기서 테이블보다 더 적절한 것이 있을까요? 각 속성이 열을 정의하고, 각 예제와 그 다양한 속성값은 이 테이블의 행에 해당합니다. 우리의 시나리오에서는 예를 들어 표 1.1과 같이 보일 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "이러한 테이블을 예제 집합(Example Set)이라고 합니다. 이 테이블에는 예제들의 모든 속성 데이터가 포함되어 있기 때문입니다. 이후로 그리고 RapidMiner 내에서도 데이터(Data), 데이터 집합(Data Set) 및 예제 집합(Example Set)이라는 용어를 동의어로 사용합니다. 이 경우 항상 현재 예제들의 속성값에 대한 적절한 항목이 있는 테이블을 의미합니다. 데이터 분석 또는 데이터 마이닝이라는 이름을 붙여준 것도 바로 이러한 데이터 테이블입니다. 참고:",
                "html": "이러한 테이블을 예제 집합(Example Set)이라고 합니다. 이 테이블에는 예제들의 모든 속성 데이터가 포함되어 있기 때문입니다. 이후로 그리고 RapidMiner 내에서도 데이터(Data), 데이터 집합(Data Set) 및 예제 집합(Example Set)이라는 용어를 동의어로 사용합니다. 이 경우 항상 현재 예제들의 속성값에 대한 적절한 항목이 있는 테이블을 의미합니다. 데이터 분석 또는 데이터 마이닝이라는 이름을 붙여준 것도 바로 이러한 데이터 테이블입니다. 참고: "
              },
              {
                "type": "paragraph",
                "text": "데이터(Data)는 개념의 객체를 기술하고, 메타 데이터(Meta Data)는 개념(그리고 따라서 데이터)의 특성을 기술합니다.",
                "html": "데이터(Data)는 개념의 객체를 기술하고, 메타 데이터(Meta Data)는 개념(그리고 따라서 데이터)의 특성을 기술합니다. "
              },
              {
                "type": "paragraph",
                "text": "대부분의 데이터 마이닝 방법은 예제가 이러한 속성-값 테이블로 제공되기를 기대합니다. 다행히도 여기서는 그러한 형태이므로 추가적인 데이터 변환을 생략할 수 있습니다. 그러나 실무에서는 전혀 다르며, 데이터 분석 중 대부분의 작업 시간은 데이터를 데이터 마이닝에 적합한 형식으로 변환하는 데 소요됩니다. 이러한 변환에 대해서는 이후 장들에서 자세히 다루겠습니다.",
                "html": "대부분의 데이터 마이닝 방법은 예제가 이러한 속성-값 테이블로 제공되기를 기대합니다. 다행히도 여기서는 그러한 형태이므로 추가적인 데이터 변환을 생략할 수 있습니다. 그러나 실무에서는 전혀 다르며, 데이터 분석 중 대부분의 작업 시간은 데이터를 데이터 마이닝에 적합한 형식으로 변환하는 데 소요됩니다. 이러한 변환에 대해서는 이후 장들에서 자세히 다루겠습니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "1-2-6-modelling",
            "number": "1.2.6",
            "title": "모델링",
            "blocks": [
              {
                "type": "paragraph",
                "text": "고객에 관한 데이터가 잘 구조화된 형식으로 준비되면, 마침내 데이터 마이닝 방법을 사용하여 목표 속성의 알려지지 않은 값을 가장 가능성 높은 값의 예측으로 대체할 수 있습니다. 이를 위해 다양한 방법을 사용할 수 있으며, 그 중 다수는 처음에 설명한 유추 추론이나 경험 법칙 생성과 마찬가지로 인간의 행동에 기반합니다. 데이터 마이닝 방법의 사용을 모델이라 하며,",
                "html": "고객에 관한 데이터가 잘 구조화된 형식으로 준비되면, 마침내 데이터 마이닝 방법을 사용하여 목표 속성의 알려지지 않은 값을 가장 가능성 높은 값의 예측으로 대체할 수 있습니다. 이를 위해 다양한 방법을 사용할 수 있으며, 그 중 다수는 처음에 설명한 유추 추론이나 경험 법칙 생성과 마찬가지로 인간의 행동에 기반합니다. 데이터 마이닝 방법의 사용을 모델이라 하며, "
              },
              {
                "type": "paragraph",
                "text": "표 1.1: 예제 시나리오",
                "html": "표 1.1: 예제 시나리오 "
              },
              {
                "type": "table",
                "rows": [
                  [
                    ". . .",
                    "아니오",
                    "?",
                    "예",
                    "프로토타입 긍정적 반응 여부"
                  ],
                  [
                    ". . .",
                    "Williams & Sons",
                    "John Paper",
                    "Doe Systems, Inc.",
                    "이름"
                  ],
                  [
                    ". . .",
                    "5500 Park Street, Hartford, Connecticut",
                    "4456 Parkway Blvd, Salt Lake City, Utah",
                    "76 Any Street, Sunnyville, Massachusetts",
                    "주소"
                  ],
                  [
                    ". . .",
                    "무역",
                    "IT",
                    "기계",
                    "업종"
                  ],
                  [
                    ". . .",
                    "섬유",
                    "통신",
                    "파이프 벤딩 기계",
                    "세부 업종"
                  ],
                  [
                    ". . .",
                    "< 100",
                    "600-1000",
                    "> 1000",
                    "직원 수"
                  ],
                  [
                    ". . .",
                    "1",
                    "3",
                    "5",
                    "제품 그룹 1 구매 건수"
                  ],
                  [
                    ". . .",
                    "11",
                    "7",
                    "0",
                    "제품 그룹 2 구매 건수"
                  ],
                  [
                    ". . .",
                    ". . .",
                    ". . .",
                    ". . .",
                    ". . ."
                  ]
                ]
              },
              {
                "type": "paragraph",
                "text": "이러한 방법의 결과, 즉 예측 지침은 모델(model)입니다. 데이터 마이닝이 다양한 문제에 사용될 수 있는 것처럼 모델에도 동일하게 적용됩니다. 모델은 이해하기 쉬우며 기저 프로세스를 간단한 방식으로 설명할 수 있습니다. 또는 알 수 없는 상황에서의 예측에 유용할 수 있습니다. 때로는 둘 다 해당되는데, 예를 들어 데이터 마이닝 방법이 우리의 시나리오에 대해 제공할 수 있는 다음과 같은 모델이 그렇습니다:",
                "html": "이러한 방법의 결과, 즉 예측 지침은 모델(model)입니다. 데이터 마이닝이 다양한 문제에 사용될 수 있는 것처럼 모델에도 동일하게 적용됩니다. 모델은 이해하기 쉬우며 기저 프로세스를 간단한 방식으로 설명할 수 있습니다. 또는 알 수 없는 상황에서의 예측에 유용할 수 있습니다. 때로는 둘 다 해당되는데, 예를 들어 데이터 마이닝 방법이 우리의 시나리오에 대해 제공할 수 있는 다음과 같은 모델이 그렇습니다: "
              },
              {
                "type": "paragraph",
                "text": "\"고객이 도시 지역 출신이고, 500명 이상의 직원을 보유하며, 제품 그룹 1에서 최소 3건의 구매가 이루어졌다면, 이 고객이 새 제품에 관심을 가질 확률이 높다.\"",
                "html": "\"고객이 도시 지역 출신이고, 500명 이상의 직원을 보유하며, 제품 그룹 1에서 최소 3건의 구매가 이루어졌다면, 이 고객이 새 제품에 관심을 가질 확률이 높다.\" "
              },
              {
                "type": "paragraph",
                "text": "이러한 모델은 쉽게 이해할 수 있으며 고객의 기저 데이터와 의사결정 과정에 대한 더 깊은 통찰을 제공할 수 있습니다. 게다가 이것은 운영 모델(operational model), 즉 추가 고객에 대한 예측에 직접 사용할 수 있는 모델입니다. 예를 들어 \"John Paper\"라는 회사는 위 규칙의 조건을 충족하므로 새 제품에 관심을 가질 가능성이 높습니다 - 적어도 그럴 확률이 높습니다. 따라서 여러분의 목표에 도달한 것이며, 데이터 마이닝을 사용하여 마케팅 효율성을 높이는 데 사용할 수 있는 모델을 생성한 것입니다: 모든 기존 고객과 기타 후보자에게 무차별적으로 연락하는 대신, 유망한 고객에게 마케팅 노력을 집중할 수 있으며, 따라서 더 적은 시간과 노력으로 훨씬 높은 성공률을 달성할 수 있습니다. 한 걸음 더 나아가, 어떤 영업 채널이 어떤 고객에 대해 가장 좋은 결과를 낼 것인지 분석할 수도 있습니다.",
                "html": "이러한 모델은 쉽게 이해할 수 있으며 고객의 기저 데이터와 의사결정 과정에 대한 더 깊은 통찰을 제공할 수 있습니다. 게다가 이것은 운영 모델(operational model), 즉 추가 고객에 대한 예측에 직접 사용할 수 있는 모델입니다. 예를 들어 \"John Paper\"라는 회사는 위 규칙의 조건을 충족하므로 새 제품에 관심을 가질 가능성이 높습니다 - 적어도 그럴 확률이 높습니다. 따라서 여러분의 목표에 도달한 것이며, 데이터 마이닝을 사용하여 마케팅 효율성을 높이는 데 사용할 수 있는 모델을 생성한 것입니다: 모든 기존 고객과 기타 후보자에게 무차별적으로 연락하는 대신, 유망한 고객에게 마케팅 노력을 집중할 수 있으며, 따라서 더 적은 시간과 노력으로 훨씬 높은 성공률을 달성할 수 있습니다. 한 걸음 더 나아가, 어떤 영업 채널이 어떤 고객에 대해 가장 좋은 결과를 낼 것인지 분석할 수도 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "이후 장들에서는 데이터 마이닝의 추가적인 활용에 초점을 맞추는 동시에, 고객, 비즈니스 프로세스, 제품과 같은 개념을 속성, 예제, 데이터 집합으로 변환하는 연습을 하겠습니다. 이를 통해 추가적인 적용 가능성을 발견하는 안목을 크게 향상시킬 수 있으며, 이후의 분석가 생활을 훨씬 수월하게 만들어줄 것입니다. 하지만 먼저 RapidMiner에 대해 잠시 살펴보고 사용법에 대한 간단한 소개를 제공하여, 이후의 예제들을 즉시 구현할 수 있도록 하겠습니다.",
                "html": "이후 장들에서는 데이터 마이닝의 추가적인 활용에 초점을 맞추는 동시에, 고객, 비즈니스 프로세스, 제품과 같은 개념을 속성, 예제, 데이터 집합으로 변환하는 연습을 하겠습니다. 이를 통해 추가적인 적용 가능성을 발견하는 안목을 크게 향상시킬 수 있으며, 이후의 분석가 생활을 훨씬 수월하게 만들어줄 것입니다. 하지만 먼저 RapidMiner에 대해 잠시 살펴보고 사용법에 대한 간단한 소개를 제공하여, 이후의 예제들을 즉시 구현할 수 있도록 하겠습니다. "
              },
              {
                "type": "paragraph",
                "text": "2 첫 번째 단계",
                "html": "2 첫 번째 단계 "
              },
              {
                "type": "paragraph",
                "text": "RapidMiner Studio는 기술과 사용성을 결합하여 최신 및 기존 데이터 마이닝 기법의 사용자 친화적인 통합을 제공합니다. RapidMiner Studio에서 분석 프로세스를 정의하는 것은 오퍼레이터의 드래그 앤 드롭, 파라미터 설정 및 오퍼레이터 조합을 통해 이루어집니다.",
                "html": "RapidMiner Studio는 기술과 사용성을 결합하여 최신 및 기존 데이터 마이닝 기법의 사용자 친화적인 통합을 제공합니다. RapidMiner Studio에서 분석 프로세스를 정의하는 것은 오퍼레이터의 드래그 앤 드롭, 파라미터 설정 및 오퍼레이터 조합을 통해 이루어집니다. "
              },
              {
                "type": "paragraph",
                "text": "이후에 살펴보겠지만, 프로세스는 거의 임의로 중첩 가능한 다수의 오퍼레이터로 구성될 수 있으며, 최종적으로 소위 프로세스 그래프(flow design)로 표현됩니다. 프로세스 구조는 내부적으로 XML로 기술되며, 그래픽 사용자 인터페이스를 통해 개발됩니다. 백그라운드에서 RapidMiner Studio는 현재 개발 중인 프로세스의 구문 적합성을 지속적으로 검사하고, 문제가 발생하면 자동으로 제안을 합니다. 이는 소위 메타 데이터 변환에 의해 가능한 것으로, 설계 단계에서 기저 메타 데이터를 변환하여 결과의 형태를 이미 예견할 수 있고, 부적합한 오퍼레이터 조합의 경우 해결책을 식별할 수 있게 합니다(quick fixes). 또한, RapidMiner Studio는 중단점을 정의하여 거의 모든 중간 결과를 검사할 수 있는 기능도 제공합니다. 성공적인 오퍼레이터 조합은 빌딩 블록으로 묶어서 이후 프로세스에서 다시 사용할 수 있습니다.",
                "html": "이후에 살펴보겠지만, 프로세스는 거의 임의로 중첩 가능한 다수의 오퍼레이터로 구성될 수 있으며, 최종적으로 소위 프로세스 그래프(flow design)로 표현됩니다. 프로세스 구조는 내부적으로 XML로 기술되며, 그래픽 사용자 인터페이스를 통해 개발됩니다. 백그라운드에서 RapidMiner Studio는 현재 개발 중인 프로세스의 구문 적합성을 지속적으로 검사하고, 문제가 발생하면 자동으로 제안을 합니다. 이는 소위 메타 데이터 변환에 의해 가능한 것으로, 설계 단계에서 기저 메타 데이터를 변환하여 결과의 형태를 이미 예견할 수 있고, 부적합한 오퍼레이터 조합의 경우 해결책을 식별할 수 있게 합니다(quick fixes). 또한, RapidMiner Studio는 중단점을 정의하여 거의 모든 중간 결과를 검사할 수 있는 기능도 제공합니다. 성공적인 오퍼레이터 조합은 빌딩 블록으로 묶어서 이후 프로세스에서 다시 사용할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "RapidMiner Studio는 전문 데이터 분석의 모든 과제를 위해 총 1500개 이상의 오퍼레이션을 포함합니다. 데이터 분할부터 장바구니 분석, 속성 생성에 이르기까지, 데이터를 활용하는 데 필요한 모든 도구를 제공합니다. 또한 텍스트 마이닝, 웹 마이닝, 인터넷 토론 포럼의 자동 감성 분석(sentiment analysis, opinion mining) 및 시계열 분석과 예측 방법도 제공됩니다. RapidMiner",
                "html": "RapidMiner Studio는 전문 데이터 분석의 모든 과제를 위해 총 1500개 이상의 오퍼레이션을 포함합니다. 데이터 분할부터 장바구니 분석, 속성 생성에 이르기까지, 데이터를 활용하는 데 필요한 모든 도구를 제공합니다. 또한 텍스트 마이닝, 웹 마이닝, 인터넷 토론 포럼의 자동 감성 분석(sentiment analysis, opinion mining) 및 시계열 분석과 예측 방법도 제공됩니다. RapidMiner "
              },
              {
                "type": "paragraph",
                "text": "Studio를 사용하면 3D 그래프, 산점도 행렬, 자기 조직화 맵과 같은 강력한 시각화를 활용할 수 있습니다. 확대/축소, 이동, 크기 조정을 지원하는 완전히 사용자 정의 가능하고 내보낼 수 있는 차트로 데이터를 변환하여 최대의 시각적 효과를 얻을 수 있습니다.",
                "html": "Studio를 사용하면 3D 그래프, 산점도 행렬, 자기 조직화 맵과 같은 강력한 시각화를 활용할 수 있습니다. 확대/축소, 이동, 크기 조정을 지원하는 완전히 사용자 정의 가능하고 내보낼 수 있는 차트로 데이터를 변환하여 최대의 시각적 효과를 얻을 수 있습니다. "
              }
            ],
            "subsections": []
          }
        ]
      }
    ]
  },
  {
    "id": "chapter-2",
    "number": "2",
    "title": "첫 번째 단계",
    "slug": "chapter-2-first-steps",
    "blocks": [],
    "sections": [
      {
        "id": "2-1-installation-and-first-repository",
        "number": "2.1",
        "title": "설치 및 첫 번째 리포지토리",
        "blocks": [
          {
            "type": "paragraph",
            "text": "RapidMiner Studio로 작업하기 전에, 먼저 소프트웨어를 다운로드하고 설치해야 합니다. RapidMiner 웹사이트의 다운로드 영역에서 찾을 수 있습니다:",
            "html": "RapidMiner Studio로 작업하기 전에, 먼저 소프트웨어를 다운로드하고 설치해야 합니다. RapidMiner 웹사이트의 다운로드 영역에서 찾을 수 있습니다: "
          },
          {
            "type": "paragraph",
            "text": "http://www.rapidminer.com",
            "html": "http://www.rapidminer.com "
          },
          {
            "type": "paragraph",
            "text": "운영 체제에 맞는 설치 패키지를 다운로드하고 웹사이트의 안내에 따라 RapidMiner Studio를 설치하십시오. 모든 일반적인 Windows 버전뿐만 아니라 Macintosh, Linux 또는 Unix 시스템도 지원됩니다. 후자의 경우 최신 Java Runtime(최소 버전 7)이 필요하다는 점에 유의하십시오.",
            "html": "운영 체제에 맞는 설치 패키지를 다운로드하고 웹사이트의 안내에 따라 RapidMiner Studio를 설치하십시오. 모든 일반적인 Windows 버전뿐만 아니라 Macintosh, Linux 또는 Unix 시스템도 지원됩니다. 후자의 경우 최신 Java Runtime(최소 버전 7)이 필요하다는 점에 유의하십시오. "
          },
          {
            "type": "paragraph",
            "text": "RapidMiner Studio를 처음 시작하면 새 리포지토리를 생성하라는 메시지가 표시됩니다(그림 2.1). 우선 컴퓨터의 로컬 리포지토리로 제한하겠습니다. 나중에 네트워크에서 리포지토리를 정의하여 다른 사람과 공유할 수도 있습니다:",
            "html": "RapidMiner Studio를 처음 시작하면 새 리포지토리를 생성하라는 메시지가 표시됩니다(그림 2.1). 우선 컴퓨터의 로컬 리포지토리로 제한하겠습니다. 나중에 네트워크에서 리포지토리를 정의하여 다른 사람과 공유할 수도 있습니다: "
          },
          {
            "type": "paragraph",
            "text": "로컬 리포지토리의 경우 이름(별칭)을 지정하고 하드 드라이브의 임의의 디렉토리를 정의하기만 하면 됩니다(그림 2.2). 오른쪽의 폴더 아이콘을 클릭하여 디렉토리를 직접 선택할 수 있습니다. 나타나는 파일 대화 상자에서 편리한 위치에 새 디렉토리를 만들고 이 새 디렉토리를 로컬 리포지토리의 기반으로 사용하는 것이 좋습니다. 이 리포지토리는 데이터 및 분석 프로세스의 중앙 저장 위치로 사용되며 앞으로 계속 활용하게 될 것입니다.",
            "html": "로컬 리포지토리의 경우 이름(별칭)을 지정하고 하드 드라이브의 임의의 디렉토리를 정의하기만 하면 됩니다(그림 2.2). 오른쪽의 폴더 아이콘을 클릭하여 디렉토리를 직접 선택할 수 있습니다. 나타나는 파일 대화 상자에서 편리한 위치에 새 디렉토리를 만들고 이 새 디렉토리를 로컬 리포지토리의 기반으로 사용하는 것이 좋습니다. 이 리포지토리는 데이터 및 분석 프로세스의 중앙 저장 위치로 사용되며 앞으로 계속 활용하게 될 것입니다. "
          },
          {
            "type": "image",
            "src": "/images/image13.png"
          },
          {
            "type": "paragraph",
            "text": "그림 2.1: RapidMiner Studio를 처음 사용할 때 컴퓨터에 로컬 리포지토리를 생성합니다.",
            "html": "그림 2.1: RapidMiner Studio를 처음 사용할 때 컴퓨터에 로컬 리포지토리를 생성합니다. "
          }
        ],
        "subsections": []
      },
      {
        "id": "2-2-perspectives-and-views",
        "number": "2.2",
        "title": "퍼스펙티브와 뷰",
        "blocks": [
          {
            "type": "paragraph",
            "text": "리포지토리를 선택하면 Home Perspective로 안내됩니다(그림 2.3). 인터넷에 연결되어 있는 경우 오른쪽 섹션에 RapidMiner에 관한 최신 뉴스가 표시됩니다. 중앙의 목록에는 RapidMiner Studio를 시작한 후 자주 수행하게 될 일반적인 작업이 표시됩니다. 각 항목에 대한 자세한 내용은 다음과 같습니다:",
            "html": "리포지토리를 선택하면 Home Perspective로 안내됩니다(그림 2.3). 인터넷에 연결되어 있는 경우 오른쪽 섹션에 RapidMiner에 관한 최신 뉴스가 표시됩니다. 중앙의 목록에는 RapidMiner Studio를 시작한 후 자주 수행하게 될 일반적인 작업이 표시됩니다. 각 항목에 대한 자세한 내용은 다음과 같습니다: "
          },
          {
            "type": "paragraph",
            "text": "1. New Process: Design Perspective를 열고 새 분석 프로세스를 생성합니다.",
            "html": "1. New Process: Design Perspective를 열고 새 분석 프로세스를 생성합니다. "
          },
          {
            "type": "paragraph",
            "text": "2. Open: 버튼을 클릭하면 리포지토리 브라우저가 열립니다. Design Perspective에서 기존 프로세스를 선택하여 열 수 있습니다. 오른쪽의 화살표 버튼을 클릭하면 최근에 열었던 프로세스 목록이 나타납니다. 하나를 선택하면 Design Perspective에서 열립니다.",
            "html": "2. Open: 버튼을 클릭하면 리포지토리 브라우저가 열립니다. Design Perspective에서 기존 프로세스를 선택하여 열 수 있습니다. 오른쪽의 화살표 버튼을 클릭하면 최근에 열었던 프로세스 목록이 나타납니다. 하나를 선택하면 Design Perspective에서 열립니다. "
          },
          {
            "type": "image",
            "src": "/images/image15.png"
          },
          {
            "type": "paragraph",
            "text": "그림 2.2: 데이터 및 분석 프로세스를 저장하기 위한 새 로컬 리포지토리 정의. 새 디렉토리를 기반으로 생성하는 것이 좋습니다.",
            "html": "그림 2.2: 데이터 및 분석 프로세스를 저장하기 위한 새 로컬 리포지토리 정의. 새 디렉토리를 기반으로 생성하는 것이 좋습니다. "
          },
          {
            "type": "paragraph",
            "text": "어느 쪽이든 RapidMiner Studio는 자동으로 Design Perspective로 전환됩니다.",
            "html": "어느 쪽이든 RapidMiner Studio는 자동으로 Design Perspective로 전환됩니다. "
          },
          {
            "type": "paragraph",
            "text": "3. Application Wizard: Application Wizard를 사용하여 세 단계로 데이터의 일반적인 데이터 마이닝 문제를 해결할 수 있습니다. Direct Marketing Wizard를 사용하면 가장 높은 전환율을 가진 마케팅 활동을 찾을 수 있습니다. Predictive Maintenance Wizard는 필요한 유지보수 활동을 예측합니다. Churn Analysis Wizard를 사용하면 어떤 고객이 이탈할 가능성이 가장 높은지와 그 이유를 파악할 수 있습니다. Sentiment Analysis Wizard는 소셜 미디어 스트림을 분석하여 고객의 생각에 대한 통찰력을 제공합니다.",
            "html": "3. Application Wizard: Application Wizard를 사용하여 세 단계로 데이터의 일반적인 데이터 마이닝 문제를 해결할 수 있습니다. Direct Marketing Wizard를 사용하면 가장 높은 전환율을 가진 마케팅 활동을 찾을 수 있습니다. Predictive Maintenance Wizard는 필요한 유지보수 활동을 예측합니다. Churn Analysis Wizard를 사용하면 어떤 고객이 이탈할 가능성이 가장 높은지와 그 이유를 파악할 수 있습니다. Sentiment Analysis Wizard는 소셜 미디어 스트림을 분석하여 고객의 생각에 대한 통찰력을 제공합니다. "
          },
          {
            "type": "paragraph",
            "text": "4. Tutorials: 첫 번째 분석 프로세스 생성부터 데이터 변환까지 사용 가능한 여러 튜토리얼을 보여주는 튜토리얼 창을 시작합니다. 각 튜토리얼은 RapidMiner Studio 내에서 직접 사용할 수 있으며 선택된 분석 프로세스를 사용하여 일부 데이터 마이닝 개념에 대한 소개를 제공합니다.",
            "html": "4. Tutorials: 첫 번째 분석 프로세스 생성부터 데이터 변환까지 사용 가능한 여러 튜토리얼을 보여주는 튜토리얼 창을 시작합니다. 각 튜토리얼은 RapidMiner Studio 내에서 직접 사용할 수 있으며 선택된 분석 프로세스를 사용하여 일부 데이터 마이닝 개념에 대한 소개를 제공합니다. "
          },
          {
            "type": "image",
            "src": "/images/image14.png",
            "caption": "그림 2.3: RapidMiner Studio의 Home Perspective."
          },
          {
            "type": "paragraph",
            "text": "RapidMiner Studio 상단 섹션의 도구 모음 오른쪽에 네 개의 아이콘이 있으며, 이를 통해 개별 RapidMiner Studio 퍼스펙티브 간에 전환할 수 있습니다. 퍼스펙티브는 자유롭게 구성할 수 있는 개별 사용자 인터페이스 요소, 즉 뷰의 모음으로 구성됩니다. 뷰는 원하는 대로 배치할 수 있습니다.",
            "html": "RapidMiner Studio 상단 섹션의 도구 모음 오른쪽에 네 개의 아이콘이 있으며, 이를 통해 개별 RapidMiner Studio 퍼스펙티브 간에 전환할 수 있습니다. 퍼스펙티브는 자유롭게 구성할 수 있는 개별 사용자 인터페이스 요소, 즉 뷰의 모음으로 구성됩니다. 뷰는 원하는 대로 배치할 수 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "Home Perspective에는 최소한 하나의 프리셋, 즉 지금 보고 있는 홈 화면이라는 뷰가 하나만 있습니다. \"View\" 메뉴에 접근하여 추가 뷰를 활성화할 수 있습니다(그림 2.4):",
            "html": "Home Perspective에는 최소한 하나의 프리셋, 즉 지금 보고 있는 홈 화면이라는 뷰가 하나만 있습니다. \"View\" 메뉴에 접근하여 추가 뷰를 활성화할 수 있습니다(그림 2.4): "
          },
          {
            "type": "paragraph",
            "text": "하위 항목 \"Show View\"에서 RapidMiner Studio의 모든 사용 가능한 뷰를 찾을 수 있습니다. 현재 퍼스펙티브에 표시되는 뷰는 체크 표시로 표시됩니다. 예를 들어 \"Log\"라는 이름의 뷰를 선택하여 추가 뷰를 활성화합니다. 그림 2.5에서 이 이름의 두 번째 뷰가 Home Perspective에 추가된 것을 볼 수 있습니다.",
            "html": "하위 항목 \"Show View\"에서 RapidMiner Studio의 모든 사용 가능한 뷰를 찾을 수 있습니다. 현재 퍼스펙티브에 표시되는 뷰는 체크 표시로 표시됩니다. 예를 들어 \"Log\"라는 이름의 뷰를 선택하여 추가 뷰를 활성화합니다. 그림 2.5에서 이 이름의 두 번째 뷰가 Home Perspective에 추가된 것을 볼 수 있습니다. "
          },
          {
            "type": "image",
            "src": "/images/image8.png"
          },
          {
            "type": "paragraph",
            "text": "그림 2.4: View 메뉴.",
            "html": "그림 2.4: View 메뉴. "
          },
          {
            "type": "image",
            "src": "/images/image7.png",
            "caption": "그림 2.5: 뷰 간 크기 변경"
          },
          {
            "type": "paragraph",
            "text": "익숙한 Home View와 하단의 새로운 Log View를 볼 수 있습니다. 두 뷰 사이의 강조 표시된 영역으로 마우스를 이동하면 커서 모양이 변경되어 드래그, 즉 마우스 버튼을 누른 상태에서 커서를 이동하여 뷰의 크기를 변경할 수 있음을 나타냅니다. 자유롭게 시도해 보십시오.",
            "html": "익숙한 Home View와 하단의 새로운 Log View를 볼 수 있습니다. 두 뷰 사이의 강조 표시된 영역으로 마우스를 이동하면 커서 모양이 변경되어 드래그, 즉 마우스 버튼을 누른 상태에서 커서를 이동하여 뷰의 크기를 변경할 수 있음을 나타냅니다. 자유롭게 시도해 보십시오. "
          },
          {
            "type": "paragraph",
            "text": "이미 언급한 것처럼 뷰의 위치도 원하는 대로 변경할 수 있습니다. 이렇게 하려면 뷰의 이름 영역에 커서를 놓고 뷰를 다른 위치로 드래그하면 됩니다. 마우스 버튼을 놓은 후 뷰가 배치될 위치는 반투명 회색 영역으로 강조 표시됩니다:",
            "html": "이미 언급한 것처럼 뷰의 위치도 원하는 대로 변경할 수 있습니다. 이렇게 하려면 뷰의 이름 영역에 커서를 놓고 뷰를 다른 위치로 드래그하면 됩니다. 마우스 버튼을 놓은 후 뷰가 배치될 위치는 반투명 회색 영역으로 강조 표시됩니다: "
          },
          {
            "type": "image",
            "src": "/images/image12.png"
          },
          {
            "type": "paragraph",
            "text": "그림 2.6: 하단의 Log View를 중앙으로 드래그하고 새 위치를 강조 표시합니다.",
            "html": "그림 2.6: 하단의 Log View를 중앙으로 드래그하고 새 위치를 강조 표시합니다. "
          },
          {
            "type": "paragraph",
            "text": "이 방법으로 개별 뷰를 결합하여 여러 파일 카드를 만들 수 있으며, 이는 한 번에 하나만 표시됨을 의미합니다. 또는 Log View를 아래에서 오른쪽 영역으로 드래그하여 분할이 수평이 아닌 수직으로 진행되도록 할 수 있습니다. 뷰를 완전히 분리하여 RapidMiner Studio 창 밖으로 이동할 수도 있습니다. 잠시 동안 뷰를 전체 화면으로 보고 싶다면 뷰를 최대화한 후 나중에 다시 최소화할 수 있습니다. 이는 뷰의 이름 영역을 마우스 오른쪽 버튼으로 클릭하고 최대화 작업을 선택하여 수행할 수도 있습니다. 그림 2.7에 표시된 것처럼 각 뷰는 Close, Maximize, Minimize 및 Detach 작업을 제공합니다.",
            "html": "이 방법으로 개별 뷰를 결합하여 여러 파일 카드를 만들 수 있으며, 이는 한 번에 하나만 표시됨을 의미합니다. 또는 Log View를 아래에서 오른쪽 영역으로 드래그하여 분할이 수평이 아닌 수직으로 진행되도록 할 수 있습니다. 뷰를 완전히 분리하여 RapidMiner Studio 창 밖으로 이동할 수도 있습니다. 잠시 동안 뷰를 전체 화면으로 보고 싶다면 뷰를 최대화한 후 나중에 다시 최소화할 수 있습니다. 이는 뷰의 이름 영역을 마우스 오른쪽 버튼으로 클릭하고 최대화 작업을 선택하여 수행할 수도 있습니다. 그림 2.7에 표시된 것처럼 각 뷰는 Close, Maximize, Minimize 및 Detach 작업을 제공합니다. "
          },
          {
            "type": "image",
            "src": "/images/image10.png"
          },
          {
            "type": "paragraph",
            "text": "그림 2.7: 뷰에 대한 작업",
            "html": "그림 2.7: 뷰에 대한 작업 "
          },
          {
            "type": "paragraph",
            "text": "이러한 작업은 모든 RapidMiner Studio 뷰에서 사용할 수 있습니다. 다른 작업은 자명합니다:",
            "html": "이러한 작업은 모든 RapidMiner Studio 뷰에서 사용할 수 있습니다. 다른 작업은 자명합니다: "
          },
          {
            "type": "paragraph",
            "text": "1. Close: 현재 퍼스펙티브에서 뷰를 닫습니다. \"View\" - \"Show View\" 메뉴를 통해 현재 또는 다른 퍼스펙티브에서 뷰를 다시 열 수 있습니다.",
            "html": "1. Close: 현재 퍼스펙티브에서 뷰를 닫습니다. \"View\" - \"Show View\" 메뉴를 통해 현재 또는 다른 퍼스펙티브에서 뷰를 다시 열 수 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "2. Maximize: 현재 퍼스펙티브에서 뷰를 최대화합니다.",
            "html": "2. Maximize: 현재 퍼스펙티브에서 뷰를 최대화합니다. "
          },
          {
            "type": "paragraph",
            "text": "3. Minimize: 현재 퍼스펙티브에서 뷰를 최소화합니다. 뷰는 퍼스펙티브의 왼쪽에 표시되며 거기에서 다시 최대화하거나 잠시 볼 수 있습니다.",
            "html": "3. Minimize: 현재 퍼스펙티브에서 뷰를 최소화합니다. 뷰는 퍼스펙티브의 왼쪽에 표시되며 거기에서 다시 최대화하거나 잠시 볼 수 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "4. Detach: 현재 퍼스펙티브에서 뷰를 분리하고 원하는 위치로 이동할 수 있는 별도의 창에 표시합니다.",
            "html": "4. Detach: 현재 퍼스펙티브에서 뷰를 분리하고 원하는 위치로 이동할 수 있는 별도의 창에 표시합니다. "
          },
          {
            "type": "paragraph",
            "text": "이제 두 개의 뷰를 다양한 방법으로 배치해 보십시오. 뷰를 정확히 원하는 위치에 놓으려면 약간의 연습이 필요할 수 있습니다. 그러나 화면 해상도와 개인 취향에 따라 다른 설정이 작업을 훨씬 더 효율적으로 만들 수 있으므로 배치를 조금 실험해 보는 것이 좋습니다.",
            "html": "이제 두 개의 뷰를 다양한 방법으로 배치해 보십시오. 뷰를 정확히 원하는 위치에 놓으려면 약간의 연습이 필요할 수 있습니다. 그러나 화면 해상도와 개인 취향에 따라 다른 설정이 작업을 훨씬 더 효율적으로 만들 수 있으므로 배치를 조금 실험해 보는 것이 좋습니다. "
          },
          {
            "type": "paragraph",
            "text": "때때로 실수로 뷰를 삭제하거나 퍼스펙티브가 의도치 않게 특히 불리한 위치로 이동될 수 있습니다. 이 경우 \"View\" 메뉴가 도움이 됩니다. \"Show View\"를 통해 닫힌 뷰를 다시 열 수 있을 뿐만 아니라, \"Restore Default Perspective\"를 통해 언제든지 원래 상태를 복구할 수도 있습니다.",
            "html": "때때로 실수로 뷰를 삭제하거나 퍼스펙티브가 의도치 않게 특히 불리한 위치로 이동될 수 있습니다. 이 경우 \"View\" 메뉴가 도움이 됩니다. \"Show View\"를 통해 닫힌 뷰를 다시 열 수 있을 뿐만 아니라, \"Restore Default Perspective\"를 통해 언제든지 원래 상태를 복구할 수도 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "또한 \"New Perspective\" 작업(그림 2.4)으로 자유롭게 선택한 이름으로 자신만의 퍼스펙티브를 저장할 수 있는 옵션이 있습니다. \"View\" 메뉴 또는 도구 모음의 오른쪽에서 저장된 퍼스펙티브와 사전 정의된 퍼스펙티브 간에 전환할 수 있습니다.",
            "html": "또한 \"New Perspective\" 작업(그림 2.4)으로 자유롭게 선택한 이름으로 자신만의 퍼스펙티브를 저장할 수 있는 옵션이 있습니다. \"View\" 메뉴 또는 도구 모음의 오른쪽에서 저장된 퍼스펙티브와 사전 정의된 퍼스펙티브 간에 전환할 수 있습니다. "
          }
        ],
        "subsections": []
      },
      {
        "id": "2-3-design-perspective",
        "number": "2.3",
        "title": "Design Perspective",
        "blocks": [
          {
            "type": "paragraph",
            "text": "앞서 언급한 바와 같이, 도구 모음의 오른쪽 영역에서 각 (사전 정의된) 퍼스펙티브에 대한 아이콘을 찾을 수 있습니다:",
            "html": "앞서 언급한 바와 같이, 도구 모음의 오른쪽 영역에서 각 (사전 정의된) 퍼스펙티브에 대한 아이콘을 찾을 수 있습니다: "
          },
          {
            "type": "image",
            "src": "/images/image4.png"
          },
          {
            "type": "paragraph",
            "text": "그림 2.8: 퍼스펙티브 도구 모음 아이콘",
            "html": "그림 2.8: 퍼스펙티브 도구 모음 아이콘 "
          },
          {
            "type": "paragraph",
            "text": "여기에 표시된 아이콘들은 다음 퍼스펙티브로 이동합니다:",
            "html": "여기에 표시된 아이콘들은 다음 퍼스펙티브로 이동합니다: "
          },
          {
            "type": "paragraph",
            "text": "Home Perspective: 앞서 설명한 Welcome Perspective로, 프로그램 시작 후 RapidMiner가 사용자를 맞이하는 화면입니다.",
            "html": "Home Perspective: 앞서 설명한 Welcome Perspective로, 프로그램 시작 후 RapidMiner가 사용자를 맞이하는 화면입니다. "
          },
          {
            "type": "paragraph",
            "text": "Design Perspective: 모든 분석 프로세스를 생성, 편집 및 관리하는 RapidMiner Studio의 중앙 퍼스펙티브입니다.",
            "html": "Design Perspective: 모든 분석 프로세스를 생성, 편집 및 관리하는 RapidMiner Studio의 중앙 퍼스펙티브입니다. "
          },
          {
            "type": "paragraph",
            "text": "Result Perspective: 프로세스가 데이터, 모델 등의 형태로 결과를 제공하면 RapidMiner Studio가 이 퍼스펙티브로 이동합니다. 통계, 차트, 고급 차트 등을 제공합니다.",
            "html": "Result Perspective: 프로세스가 데이터, 모델 등의 형태로 결과를 제공하면 RapidMiner Studio가 이 퍼스펙티브로 이동합니다. 통계, 차트, 고급 차트 등을 제공합니다. "
          },
          {
            "type": "paragraph",
            "text": "Wizard Perspective: 데이터에 일반적인 데이터 마이닝 문제를 적용할 수 있도록 Application Wizard를 보여주는 퍼스펙티브입니다.",
            "html": "Wizard Perspective: 데이터에 일반적인 데이터 마이닝 문제를 적용할 수 있도록 Application Wizard를 보여주는 퍼스펙티브입니다. "
          },
          {
            "type": "paragraph",
            "text": "도구 모음 내부를 클릭하거나 메뉴 항목 \"View\" - \"Perspectives\"를 통해 원하는 퍼스펙티브를 선택하여 전환할 수 있습니다. RapidMiner Studio는 적절하다고 판단되면 자동으로 다른 퍼스펙티브로 전환합니다. 예를 들어, 분석 프로세스가 완료되면 Result Perspective로 전환됩니다.",
            "html": "도구 모음 내부를 클릭하거나 메뉴 항목 \"View\" - \"Perspectives\"를 통해 원하는 퍼스펙티브를 선택하여 전환할 수 있습니다. RapidMiner Studio는 적절하다고 판단되면 자동으로 다른 퍼스펙티브로 전환합니다. 예를 들어, 분석 프로세스가 완료되면 Result Perspective로 전환됩니다. "
          },
          {
            "type": "paragraph",
            "text": "이제 도구 모음에서 클릭하여 Design Perspective로 전환하십시오. 이 섹션에서 자세히 다루게 됩니다. Result Perspective는 4장에서 다룹니다. 이제 그림 2.9와 같은 화면이 표시되어야 합니다.",
            "html": "이제 도구 모음에서 클릭하여 Design Perspective로 전환하십시오. 이 섹션에서 자세히 다루게 됩니다. Result Perspective는 4장에서 다룹니다. 이제 그림 2.9와 같은 화면이 표시되어야 합니다. "
          },
          {
            "type": "paragraph",
            "text": "Design Perspective는 RapidMiner Studio의 중앙 작업 환경이므로, Design Perspective의 모든 부분을 다음에서 개별적으로 설명하고",
            "html": "Design Perspective는 RapidMiner Studio의 중앙 작업 환경이므로, Design Perspective의 모든 부분을 다음에서 개별적으로 설명하고 "
          },
          {
            "type": "image",
            "src": "/images/image2.png",
            "caption": "관련 뷰의 기본 기능에 대해 논의하겠습니다. 그림 2.9: RapidMiner의 Design Perspective"
          }
        ],
        "subsections": [
          {
            "id": "2-3-1-operators-and-repositories-view",
            "number": "2.3.1",
            "title": "Operators 및 Repositories View",
            "blocks": [
              {
                "type": "paragraph",
                "text": "이 영역에는 최소한 기본 설정에서 매우 중요한 두 개의 뷰가 있으며, 다음에서 설명합니다.",
                "html": "이 영역에는 최소한 기본 설정에서 매우 중요한 두 개의 뷰가 있으며, 다음에서 설명합니다. "
              },
              {
                "type": "paragraph",
                "text": "Operators View",
                "html": "Operators View "
              },
              {
                "type": "paragraph",
                "text": "RapidMiner Studio에서 사용 가능한 모든 작업 단계(오퍼레이터)가 그룹별로 제공되며, 현재 프로세스에 포함시킬 수 있습니다. 그룹 내에서 간단하게 탐색하고 제공되는 오퍼레이터를 자유롭게 살펴볼 수 있습니다. RapidMiner Studio가 사용 가능한 확장 기능 중 하나로 확장된 경우, 추가 오퍼레이터도 여기에서 찾을 수 있습니다.",
                "html": "RapidMiner Studio에서 사용 가능한 모든 작업 단계(오퍼레이터)가 그룹별로 제공되며, 현재 프로세스에 포함시킬 수 있습니다. 그룹 내에서 간단하게 탐색하고 제공되는 오퍼레이터를 자유롭게 살펴볼 수 있습니다. RapidMiner Studio가 사용 가능한 확장 기능 중 하나로 확장된 경우, 추가 오퍼레이터도 여기에서 찾을 수 있습니다. "
              },
              {
                "type": "image",
                "src": "/images/image5.png",
                "caption": "그림 2.10: RapidMiner의 Design 오퍼레이터"
              },
              {
                "type": "paragraph",
                "text": "확장 기능 없이도 트리 구조에서 최소한 다음 오퍼레이터 그룹을 찾을 수 있습니다.",
                "html": "확장 기능 없이도 트리 구조에서 최소한 다음 오퍼레이터 그룹을 찾을 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "Process Control: 프로세스 흐름을 제어할 수 있는 루프나 조건 분기와 같은 오퍼레이터입니다.",
                "html": "Process Control: 프로세스 흐름을 제어할 수 있는 루프나 조건 분기와 같은 오퍼레이터입니다. "
              },
              {
                "type": "paragraph",
                "text": "Utility: 하위 프로세스를 그룹화하는 \"Subprocess\" 오퍼레이터와 함께, 중요한 매크로 오퍼레이터 및 로깅 오퍼레이터를 포함하는 보조 오퍼레이터입니다.",
                "html": "Utility: 하위 프로세스를 그룹화하는 \"Subprocess\" 오퍼레이터와 함께, 중요한 매크로 오퍼레이터 및 로깅 오퍼레이터를 포함하는 보조 오퍼레이터입니다. "
              },
              {
                "type": "paragraph",
                "text": "Repository Access: 리포지토리에서 읽기 및 쓰기 접근을 위한 오퍼레이터를 포함합니다.",
                "html": "Repository Access: 리포지토리에서 읽기 및 쓰기 접근을 위한 오퍼레이터를 포함합니다. "
              },
              {
                "type": "paragraph",
                "text": "Import: 파일, 데이터베이스 등의 외부 형식에서 데이터와 객체를 읽기 위한 다수의 오퍼레이터를 포함합니다.",
                "html": "Import: 파일, 데이터베이스 등의 외부 형식에서 데이터와 객체를 읽기 위한 다수의 오퍼레이터를 포함합니다. "
              },
              {
                "type": "paragraph",
                "text": "Export: 파일, 데이터베이스 등의 외부 형식으로 데이터와 객체를 쓰기 위한 다수의 오퍼레이터를 포함합니다.",
                "html": "Export: 파일, 데이터베이스 등의 외부 형식으로 데이터와 객체를 쓰기 위한 다수의 오퍼레이터를 포함합니다. "
              },
              {
                "type": "paragraph",
                "text": "Data Transformation: 분석에서 규모와 관련성 측면에서 아마도 가장 중요한 그룹입니다. 데이터와 메타 데이터를 변환하기 위한 모든 오퍼레이터가 여기에 위치합니다.",
                "html": "Data Transformation: 분석에서 규모와 관련성 측면에서 아마도 가장 중요한 그룹입니다. 데이터와 메타 데이터를 변환하기 위한 모든 오퍼레이터가 여기에 위치합니다. "
              },
              {
                "type": "paragraph",
                "text": "Modeling: 분류 방법, 회귀 방법, 클러스터링, 가중치, 연관 규칙 방법, 상관관계 및 유사도 분석과 같은 실제 데이터 마이닝 프로세스를 포함하며, 생성된 모델을 새로운 데이터 세트에 적용하기 위한 오퍼레이터도 포함합니다.",
                "html": "Modeling: 분류 방법, 회귀 방법, 클러스터링, 가중치, 연관 규칙 방법, 상관관계 및 유사도 분석과 같은 실제 데이터 마이닝 프로세스를 포함하며, 생성된 모델을 새로운 데이터 세트에 적용하기 위한 오퍼레이터도 포함합니다. "
              },
              {
                "type": "paragraph",
                "text": "Evaluation: 모델의 품질을 계산할 수 있는 오퍼레이터로, 교차 검증, 부트스트래핑 등을 통해 새로운 데이터에 대한 품질을 평가합니다.",
                "html": "Evaluation: 모델의 품질을 계산할 수 있는 오퍼레이터로, 교차 검증, 부트스트래핑 등을 통해 새로운 데이터에 대한 품질을 평가합니다. "
              },
              {
                "type": "paragraph",
                "text": "Operators View에서 오퍼레이터를 선택하고 드래그 앤 드롭으로 프로세스의 원하는 위치에 추가할 수 있습니다. 오퍼레이터의 출력 포트와 입력 포트 사이에 선을 그려 오퍼레이터를 연결합니다. 삽입 시 오퍼레이터가 자동으로 연결되도록 할지 선택할 수 있습니다. 뷰 도구 모음의 왼쪽에 있는 플러그 기호(그림 2.11)를 선택하고 나가는 연결 및/또는 들어오는 연결이 자동으로 생성되도록 정의하십시오.",
                "html": "Operators View에서 오퍼레이터를 선택하고 드래그 앤 드롭으로 프로세스의 원하는 위치에 추가할 수 있습니다. 오퍼레이터의 출력 포트와 입력 포트 사이에 선을 그려 오퍼레이터를 연결합니다. 삽입 시 오퍼레이터가 자동으로 연결되도록 할지 선택할 수 있습니다. 뷰 도구 모음의 왼쪽에 있는 플러그 기호(그림 2.11)를 선택하고 나가는 연결 및/또는 들어오는 연결이 자동으로 생성되도록 정의하십시오. "
              },
              {
                "type": "image",
                "src": "/images/image1.png"
              },
              {
                "type": "paragraph",
                "text": "그림 2.11: Operators View의 동작 및 필터",
                "html": "그림 2.11: Operators View의 동작 및 필터 "
              },
              {
                "type": "paragraph",
                "text": "작업을 최대한 쉽게 하기 위해 Operators View는 필터도 지원하며, 오퍼레이터 이름의 일부 또는 전체 이름을 검색하는 데 사용할 수 있습니다. 검색어를 필터 필드에 입력하기만 하면 됩니다. 검색 결과가 총 10개 미만이 되면 트리가 열려 모든 검색 결과가 표시됩니다. 따라서 매번 전체 계층 구조를 탐색할 필요가 없습니다. 검색 필드 옆의 빨간색 십자 표시를 클릭하면 현재 입력된 내용이 지워지고 트리가 다시 접힙니다.",
                "html": "작업을 최대한 쉽게 하기 위해 Operators View는 필터도 지원하며, 오퍼레이터 이름의 일부 또는 전체 이름을 검색하는 데 사용할 수 있습니다. 검색어를 필터 필드에 입력하기만 하면 됩니다. 검색 결과가 총 10개 미만이 되면 트리가 열려 모든 검색 결과가 표시됩니다. 따라서 매번 전체 계층 구조를 탐색할 필요가 없습니다. 검색 필드 옆의 빨간색 십자 표시를 클릭하면 현재 입력된 내용이 지워지고 트리가 다시 접힙니다. "
              },
              {
                "type": "paragraph",
                "text": "검색 필드 바로 옆의 아이콘으로 사용 중단된(deprecated) 오퍼레이터를 필터링하고, 가장 많이 사용된 오퍼레이터 순으로 정렬할 수 있습니다.",
                "html": "검색 필드 바로 옆의 아이콘으로 사용 중단된(deprecated) 오퍼레이터를 필터링하고, 가장 많이 사용된 오퍼레이터 순으로 정렬할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "팁: 전문가들은 시간이 지남에 따라 필요한 오퍼레이터의 이름을 점점 더 많이 알게 됩니다. (전체) 이름 검색 외에도, 검색 필드는 이니셜 기반 검색(소위 카멜 케이스 검색)도 지원합니다. \"Read Excel\"에 대해 \"REx\"를, \"Date to Nominal\"과 \"Date to Numerical\"에 대해 \"DN\"을 입력해 보십시오. 이렇게 하면 검색 속도가 크게 향상됩니다.",
                "html": "팁: 전문가들은 시간이 지남에 따라 필요한 오퍼레이터의 이름을 점점 더 많이 알게 됩니다. (전체) 이름 검색 외에도, 검색 필드는 이니셜 기반 검색(소위 카멜 케이스 검색)도 지원합니다. \"Read Excel\"에 대해 \"REx\"를, \"Date to Nominal\"과 \"Date to Numerical\"에 대해 \"DN\"을 입력해 보십시오. 이렇게 하면 검색 속도가 크게 향상됩니다. "
              },
              {
                "type": "paragraph",
                "text": "Repositories View",
                "html": "Repositories View "
              },
              {
                "type": "paragraph",
                "text": "리포지토리는 버전 5에서 도입된 RapidMiner Studio의 핵심 구성 요소입니다. 분석 프로세스를 프로젝트로 관리하고 구조화하는 데 사용되며, 동시에 데이터와 관련 메타 데이터의 원본 역할을 합니다. 다음 장에서 리포지토리 사용 방법을 자세히 설명할 것이므로, 이 단계에서는 다음 사항만 언급하겠습니다.",
                "html": "리포지토리는 버전 5에서 도입된 RapidMiner Studio의 핵심 구성 요소입니다. 분석 프로세스를 프로젝트로 관리하고 구조화하는 데 사용되며, 동시에 데이터와 관련 메타 데이터의 원본 역할을 합니다. 다음 장에서 리포지토리 사용 방법을 자세히 설명할 것이므로, 이 단계에서는 다음 사항만 언급하겠습니다. "
              },
              {
                "type": "paragraph",
                "text": "경고: RapidMiner Studio 지원 기능의 대부분은 프로세스 설계를 위해 메타 데이터를 활용하므로, RapidMiner 리포지토리를 사용할 것을 강력히 권장합니다. 그렇지 않으면 (예: 파일이나 데이터베이스에서 데이터를 직접 읽는 경우) 메타 데이터를 사용할 수 없게 되어 많은 지원 기능이 제공되지 않습니다.",
                "html": "경고: RapidMiner Studio 지원 기능의 대부분은 프로세스 설계를 위해 메타 데이터를 활용하므로, RapidMiner 리포지토리를 사용할 것을 강력히 권장합니다. 그렇지 않으면 (예: 파일이나 데이터베이스에서 데이터를 직접 읽는 경우) 메타 데이터를 사용할 수 없게 되어 많은 지원 기능이 제공되지 않습니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "2-3-2-process-view",
            "number": "2.3.2",
            "title": "Process View",
            "blocks": [
              {
                "type": "paragraph",
                "text": "Process View(그림 2.12)는 분석 프로세스 내의 개별 단계와 그 연결을 보여줍니다. 현재 프로세스에 여러 가지 방법으로 새 단계를 추가할 수 있습니다. 이러한 단계 간의 연결을 정의하고 다시 분리할 수 있습니다. 마지막으로, 이 퍼스펙티브에서 단계의 순서를 정의하는 것도 가능합니다. 다음 섹션에서 Process View의 사용 방법을 보여드립니다.",
                "html": "Process View(그림 2.12)는 분석 프로세스 내의 개별 단계와 그 연결을 보여줍니다. 현재 프로세스에 여러 가지 방법으로 새 단계를 추가할 수 있습니다. 이러한 단계 간의 연결을 정의하고 다시 분리할 수 있습니다. 마지막으로, 이 퍼스펙티브에서 단계의 순서를 정의하는 것도 가능합니다. 다음 섹션에서 Process View의 사용 방법을 보여드립니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "2-3-3-operators-and-processes",
            "number": "2.3.3",
            "title": "오퍼레이터와 프로세스",
            "blocks": [
              {
                "type": "paragraph",
                "text": "RapidMiner Studio로 작업하는 것은 기본적으로 개별 작업 단계의 연속을 지정하여 분석 프로세스를 정의하는 것으로 구성됩니다. RapidMiner Studio에서",
                "html": "RapidMiner Studio로 작업하는 것은 기본적으로 개별 작업 단계의 연속을 지정하여 분석 프로세스를 정의하는 것으로 구성됩니다. RapidMiner Studio에서 "
              },
              {
                "type": "image",
                "src": "/images/image3.png"
              },
              {
                "type": "paragraph",
                "text": "그림 2.12: Process View에서 RapidMiner의 구성 요소인 소위 오퍼레이터들이 연결됩니다",
                "html": "그림 2.12: Process View에서 RapidMiner의 구성 요소인 소위 오퍼레이터들이 연결됩니다 "
              },
              {
                "type": "paragraph",
                "text": "이러한 프로세스 구성 요소를 오퍼레이터라고 합니다. 오퍼레이터는 다음 여러 가지로 정의됩니다:",
                "html": "이러한 프로세스 구성 요소를 오퍼레이터라고 합니다. 오퍼레이터는 다음 여러 가지로 정의됩니다: "
              },
              {
                "type": "paragraph",
                "text": "• 예상 입력에 대한 설명,",
                "html": "• 예상 입력에 대한 설명, "
              },
              {
                "type": "paragraph",
                "text": "• 제공되는 출력에 대한 설명,",
                "html": "• 제공되는 출력에 대한 설명, "
              },
              {
                "type": "paragraph",
                "text": "• 입력에 대해 오퍼레이터가 수행하는 동작으로, 최종적으로 출력의 제공으로 이어지는 동작,",
                "html": "• 입력에 대해 오퍼레이터가 수행하는 동작으로, 최종적으로 출력의 제공으로 이어지는 동작, "
              },
              {
                "type": "paragraph",
                "text": "• 수행되는 동작을 제어할 수 있는 다수의 파라미터.",
                "html": "• 수행되는 동작을 제어할 수 있는 다수의 파라미터. "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터의 입력과 출력은 포트를 통해 생성되거나 소비됩니다. 포트는 특정 유형의 입력을 기대합니다. RapidMiner에서 오퍼레이터가",
                "html": "오퍼레이터의 입력과 출력은 포트를 통해 생성되거나 소비됩니다. 포트는 특정 유형의 입력을 기대합니다. RapidMiner에서 오퍼레이터가 "
              },
              {
                "type": "paragraph",
                "text": "Studio에서 다음과 같은 모듈 형태로 표현되며, 입력 포트는 왼쪽에, 출력 포트는 오른쪽에 배치됩니다:",
                "html": "Studio에서 다음과 같은 모듈 형태로 표현되며, 입력 포트는 왼쪽에, 출력 포트는 오른쪽에 배치됩니다: "
              },
              {
                "type": "image",
                "src": "/images/image9.png"
              },
              {
                "type": "paragraph",
                "text": "그림 2.13: 오퍼레이터는 입력 포트(왼쪽)와 출력 포트(오른쪽)를 통해 연결할 수 있습니다.",
                "html": "그림 2.13: 오퍼레이터는 입력 포트(왼쪽)와 출력 포트(오른쪽)를 통해 연결할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "이러한 오퍼레이터는 예를 들어 리포지토리, 데이터베이스 또는 파일에서 데이터를 가져올 수 있습니다. 이 경우 입력 포트는 없지만, 최소한 데이터 위치를 지정하는 파라미터가 있습니다. 다른 오퍼레이터는 입력을 변환하고 동일한 유형의 객체를 반환합니다. 데이터를 변환하는 오퍼레이터가 이 그룹에 속합니다. 또 다른 오퍼레이터는 입력을 소비하고 완전히 새로운 객체로 변환합니다: 많은 데이터 마이닝 방법이 이 범주에 해당하며, 예를 들어 주어진 입력 데이터에 대한 모델을 제공합니다.",
                "html": "이러한 오퍼레이터는 예를 들어 리포지토리, 데이터베이스 또는 파일에서 데이터를 가져올 수 있습니다. 이 경우 입력 포트는 없지만, 최소한 데이터 위치를 지정하는 파라미터가 있습니다. 다른 오퍼레이터는 입력을 변환하고 동일한 유형의 객체를 반환합니다. 데이터를 변환하는 오퍼레이터가 이 그룹에 속합니다. 또 다른 오퍼레이터는 입력을 소비하고 완전히 새로운 객체로 변환합니다: 많은 데이터 마이닝 방법이 이 범주에 해당하며, 예를 들어 주어진 입력 데이터에 대한 모델을 제공합니다. "
              },
              {
                "type": "paragraph",
                "text": "포트의 색상은 포트에 제공해야 하는 입력 유형을 나타냅니다. 예를 들어, 푸른색은 예제 세트가 필요함을 나타냅니다. 포트의 윗부분과 포트 이름이 빨간색이면 문제가 있음을 나타냅니다. 이 문제는 그림 2.13의 오퍼레이터에서 쉽게 확인할 수 있습니다: 연결되어 있지 않으며 입력 포트에 적합한 소스와의 연결이 여전히 필요합니다.",
                "html": "포트의 색상은 포트에 제공해야 하는 입력 유형을 나타냅니다. 예를 들어, 푸른색은 예제 세트가 필요함을 나타냅니다. 포트의 윗부분과 포트 이름이 빨간색이면 문제가 있음을 나타냅니다. 이 문제는 그림 2.13의 오퍼레이터에서 쉽게 확인할 수 있습니다: 연결되어 있지 않으며 입력 포트에 적합한 소스와의 연결이 여전히 필요합니다. "
              },
              {
                "type": "paragraph",
                "text": "출력 포트는 결과가 불분명하거나 현재 구성에서 (아직) 제공할 수 없는 경우 흰색입니다. 모든 필요한 구성이 완료되면, 즉 모든 필요한 파라미터가 정의되고 모든 필요한 입력 포트가 연결되면 출력 포트는 해당 유형에 따라 색상이 지정됩니다.",
                "html": "출력 포트는 결과가 불분명하거나 현재 구성에서 (아직) 제공할 수 없는 경우 흰색입니다. 모든 필요한 구성이 완료되면, 즉 모든 필요한 파라미터가 정의되고 모든 필요한 입력 포트가 연결되면 출력 포트는 해당 유형에 따라 색상이 지정됩니다. "
              },
              {
                "type": "image",
                "src": "/images/image11.png"
              },
              {
                "type": "paragraph",
                "text": "그림 2.14: 오퍼레이터의 상태 표시기",
                "html": "그림 2.14: 오퍼레이터의 상태 표시기 "
              },
              {
                "type": "paragraph",
                "text": "포트뿐만 아니라 전체 오퍼레이터도 다양한 상태 표시기를 통해 상태를 시각화할 수 있습니다(그림 2.14). 왼쪽에서 오른쪽으로 다음과 같습니다:",
                "html": "포트뿐만 아니라 전체 오퍼레이터도 다양한 상태 표시기를 통해 상태를 시각화할 수 있습니다(그림 2.14). 왼쪽에서 오른쪽으로 다음과 같습니다: "
              },
              {
                "type": "paragraph",
                "text": "상태등: 아직 설정되지 않은 파라미터나 연결되지 않은 입력 포트와 같은 문제가 있는지(빨간색), 구성은 기본적으로 완료되었지만 그 이후 오퍼레이터가 아직 실행되지 않았는지(노란색), 또는 모든 것이 정상이고 오퍼레이터가 이미 성공적으로 실행되었는지(녹색)를 나타냅니다.",
                "html": "상태등: 아직 설정되지 않은 파라미터나 연결되지 않은 입력 포트와 같은 문제가 있는지(빨간색), 구성은 기본적으로 완료되었지만 그 이후 오퍼레이터가 아직 실행되지 않았는지(노란색), 또는 모든 것이 정상이고 오퍼레이터가 이미 성공적으로 실행되었는지(녹색)를 나타냅니다. "
              },
              {
                "type": "paragraph",
                "text": "경고 삼각형: 이 오퍼레이터에 대한 상태 메시지가 있을 때 표시됩니다.",
                "html": "경고 삼각형: 이 오퍼레이터에 대한 상태 메시지가 있을 때 표시됩니다. "
              },
              {
                "type": "paragraph",
                "text": "중단점(Breakpoint): 분석가가 중간 결과를 검토할 수 있도록 이 오퍼레이터 전이나 후에 프로세스 실행을 중지할지 여부를 나타냅니다.",
                "html": "중단점(Breakpoint): 분석가가 중간 결과를 검토할 수 있도록 이 오퍼레이터 전이나 후에 프로세스 실행을 중지할지 여부를 나타냅니다. "
              },
              {
                "type": "paragraph",
                "text": "주석(Comment): 이 오퍼레이터에 대한 주석이 입력된 경우, 이 아이콘으로 표시됩니다.",
                "html": "주석(Comment): 이 오퍼레이터에 대한 주석이 입력된 경우, 이 아이콘으로 표시됩니다. "
              },
              {
                "type": "paragraph",
                "text": "서브프로세스(Subprocess): 일부 오퍼레이터에는 하나 이상의 서브프로세스가 있으므로 매우 중요한 표시입니다. 이 표시로 서브프로세스가 있는지 확인할 수 있습니다. 해당 오퍼레이터를 더블클릭하면 서브프로세스로 이동할 수 있습니다.",
                "html": "서브프로세스(Subprocess): 일부 오퍼레이터에는 하나 이상의 서브프로세스가 있으므로 매우 중요한 표시입니다. 이 표시로 서브프로세스가 있는지 확인할 수 있습니다. 해당 오퍼레이터를 더블클릭하면 서브프로세스로 이동할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "여러 오퍼레이터가 상호 연결되면, 이를 분석 프로세스 또는 간단히 프로세스라고 합니다. 이러한 단계의 연속은 예를 들어 데이터 세트를 로드하고, 데이터를 변환하고, 모델을 계산하고, 모델을 다른 데이터 세트에 적용할 수 있습니다. 이러한 프로세스는 RapidMiner Studio에서 그림 2.15와 같이 표시될 수 있습니다.",
                "html": "여러 오퍼레이터가 상호 연결되면, 이를 분석 프로세스 또는 간단히 프로세스라고 합니다. 이러한 단계의 연속은 예를 들어 데이터 세트를 로드하고, 데이터를 변환하고, 모델을 계산하고, 모델을 다른 데이터 세트에 적용할 수 있습니다. 이러한 프로세스는 RapidMiner Studio에서 그림 2.15와 같이 표시될 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "이러한 프로세스는 RapidMiner Studio에서 수백 개의 오퍼레이터 규모로 쉽게 커질 수 있으며, 여러 레벨 또는 서브프로세스에 걸칠 수 있습니다. 백그라운드에서 지속적으로 수행되는 프로세스 검사와 아래에 표시된 프로세스 탐색 지원 기능은 더 복잡한 작업에서도 전체적인 흐름을 놓치지 않고 올바른 프로세스를 정의할 수 있도록 보장합니다.",
                "html": "이러한 프로세스는 RapidMiner Studio에서 수백 개의 오퍼레이터 규모로 쉽게 커질 수 있으며, 여러 레벨 또는 서브프로세스에 걸칠 수 있습니다. 백그라운드에서 지속적으로 수행되는 프로세스 검사와 아래에 표시된 프로세스 탐색 지원 기능은 더 복잡한 작업에서도 전체적인 흐름을 놓치지 않고 올바른 프로세스를 정의할 수 있도록 보장합니다. "
              },
              {
                "type": "image",
                "src": "/images/image6.png"
              },
              {
                "type": "paragraph",
                "text": "그림 2.15: 여러 오퍼레이터로 구성된 분석 프로세스. 데이터 흐름의 색상 코딩은 전달되는 객체의 유형을 보여줍니다.",
                "html": "그림 2.15: 여러 오퍼레이터로 구성된 분석 프로세스. 데이터 흐름의 색상 코딩은 전달되는 객체의 유형을 보여줍니다. "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터 삽입",
                "html": "오퍼레이터 삽입 "
              },
              {
                "type": "paragraph",
                "text": "프로세스에 새 오퍼레이터를 다양한 방법으로 삽입할 수 있습니다. 각 방법에 대한 세부 사항은 다음과 같습니다:",
                "html": "프로세스에 새 오퍼레이터를 다양한 방법으로 삽입할 수 있습니다. 각 방법에 대한 세부 사항은 다음과 같습니다: "
              },
              {
                "type": "paragraph",
                "text": "• 위에서 설명한 대로 Operators View에서 드래그 앤 드롭으로, • Operators View에서 오퍼레이터를 더블클릭하여,",
                "html": "• 위에서 설명한 대로 Operators View에서 드래그 앤 드롭으로, • Operators View에서 오퍼레이터를 더블클릭하여, "
              },
              {
                "type": "paragraph",
                "text": "• 메뉴 항목 \"Edit\" - \"New Operator...\" (Ctrl-I)로 열리는 대화 상자를 통해,",
                "html": "• 메뉴 항목 \"Edit\" - \"New Operator...\" (Ctrl-I)로 열리는 대화 상자를 통해, "
              },
              {
                "type": "paragraph",
                "text": "• 흰색 프로세스 영역의 빈 공간에서 컨텍스트 메뉴를 통해 \"New Operator\" 하위 메뉴에서 오퍼레이터를 선택하여.",
                "html": "• 흰색 프로세스 영역의 빈 공간에서 컨텍스트 메뉴를 통해 \"New Operator\" 하위 메뉴에서 오퍼레이터를 선택하여. "
              },
              {
                "type": "paragraph",
                "text": "각 경우에 새 오퍼레이터는 Operators View의 설정에 따라 적합한 오퍼레이터와 자동으로 연결되거나, 사용자가 수동으로 연결을 만들거나 수정해야 합니다.",
                "html": "각 경우에 새 오퍼레이터는 Operators View의 설정에 따라 적합한 오퍼레이터와 자동으로 연결되거나, 사용자가 수동으로 연결을 만들거나 수정해야 합니다. "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터 연결",
                "html": "오퍼레이터 연결 "
              },
              {
                "type": "paragraph",
                "text": "새 오퍼레이터를 삽입한 후, 삽입된 오퍼레이터를 상호 연결할 수 있습니다. 기본적으로 세 가지 방법이 있으며, 다음에서 설명합니다.",
                "html": "새 오퍼레이터를 삽입한 후, 삽입된 오퍼레이터를 상호 연결할 수 있습니다. 기본적으로 세 가지 방법이 있으며, 다음에서 설명합니다. "
              },
              {
                "type": "paragraph",
                "text": "연결 1: 삽입 시 자동 연결",
                "html": "연결 1: 삽입 시 자동 연결 "
              },
              {
                "type": "paragraph",
                "text": "Operators View의 플러그 기호 아래에서 자동 연결 옵션을 활성화한 경우, RapidMiner은 삽입 후 적합한 출력 포트와 오퍼레이터를 연결하려고 시도합니다. 예를 들어, 새 오퍼레이터에 예제 세트가 필요한 입력 포트가 있으면 RapidMiner은 이미 그러한 예제 세트를 생성할 수 있는 오퍼레이터를 찾으려고 합니다. 옵션이 하나뿐이면 선택이 명확하고 오퍼레이터가 연결됩니다. 그러나 여러 옵션이 있는 경우 RapidMiner은 현재 마우스 위치의 왼쪽 위에서 가장 가까운 옵션을 선택하려고 합니다. 관련 오퍼레이터는 그림 2.16과 같이 프레임과 그림자로 표시됩니다. 이렇게 하면 삽입 중에 올바른 연결을 미리 설정할 수 있습니다.",
                "html": "Operators View의 플러그 기호 아래에서 자동 연결 옵션을 활성화한 경우, RapidMiner은 삽입 후 적합한 출력 포트와 오퍼레이터를 연결하려고 시도합니다. 예를 들어, 새 오퍼레이터에 예제 세트가 필요한 입력 포트가 있으면 RapidMiner은 이미 그러한 예제 세트를 생성할 수 있는 오퍼레이터를 찾으려고 합니다. 옵션이 하나뿐이면 선택이 명확하고 오퍼레이터가 연결됩니다. 그러나 여러 옵션이 있는 경우 RapidMiner은 현재 마우스 위치의 왼쪽 위에서 가장 가까운 옵션을 선택하려고 합니다. 관련 오퍼레이터는 그림 2.16과 같이 프레임과 그림자로 표시됩니다. 이렇게 하면 삽입 중에 올바른 연결을 미리 설정할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "팁: 최소한 입력 포트에 대해서는 자동 연결 옵션을 활성화하는 것이 좋습니다. 메타 데이터를 기반으로 한 연결 알고리즘이 때때로 잘못된 연결을 만들더라도, 올바른 연결이 자동으로 인식되는 모든 경우에 많은 작업을 절약할 수 있습니다.",
                "html": "팁: 최소한 입력 포트에 대해서는 자동 연결 옵션을 활성화하는 것이 좋습니다. 메타 데이터를 기반으로 한 연결 알고리즘이 때때로 잘못된 연결을 만들더라도, 올바른 연결이 자동으로 인식되는 모든 경우에 많은 작업을 절약할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "연결 2: 수동 연결",
                "html": "연결 2: 수동 연결 "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터를 수동으로 상호 연결할 수도 있으며, 더 복잡한 프로세스에서는 이것이 필요합니다. 이를 위해 출력 포트를 클릭하십시오. 그림 2.17과 같이 주황색 선이 그려집니다. 입력 포트를 클릭하여 선택한 출력 포트와 이 입력 포트를 연결하십시오. 프로세스를 취소하려면 마우스를 멈추고 오른쪽 마우스 버튼을 클릭하십시오. 주황색 선이 사라지고 정상적으로 작업을 계속할 수 있습니다.",
                "html": "오퍼레이터를 수동으로 상호 연결할 수도 있으며, 더 복잡한 프로세스에서는 이것이 필요합니다. 이를 위해 출력 포트를 클릭하십시오. 그림 2.17과 같이 주황색 선이 그려집니다. 입력 포트를 클릭하여 선택한 출력 포트와 이 입력 포트를 연결하십시오. 프로세스를 취소하려면 마우스를 멈추고 오른쪽 마우스 버튼을 클릭하십시오. 주황색 선이 사라지고 정상적으로 작업을 계속할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "연결 3: 완전 자동 연결",
                "html": "연결 3: 완전 자동 연결 "
              },
              {
                "type": "paragraph",
                "text": "때때로 (서브)프로세스에 많은 오퍼레이터가 이미 있지만 아직 연결되지 않은 경우가 있습니다. 이 경우 \"Auto-Wire\"와 \"Re-Wire\" 옵션이 유용합니다.",
                "html": "때때로 (서브)프로세스에 많은 오퍼레이터가 이미 있지만 아직 연결되지 않은 경우가 있습니다. 이 경우 \"Auto-Wire\"와 \"Re-Wire\" 옵션이 유용합니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 2.16: 드래그 과정에서 두 번째 오퍼레이터가 강조 표시되며(프레임과 그림자), 새 오퍼레이터가 드롭되고 예제 세트를 기대하는 경우 이 오퍼레이터와 우선적으로 연결됩니다.",
                "html": "그림 2.16: 드래그 과정에서 두 번째 오퍼레이터가 강조 표시되며(프레임과 그림자), 새 오퍼레이터가 드롭되고 예제 세트를 기대하는 경우 이 오퍼레이터와 우선적으로 연결됩니다. "
              },
              {
                "type": "paragraph",
                "text": "이 옵션은 Process View의 플러그 기호 뒤에 숨겨져 있습니다. 프로세스가 생성될 때 비교적 순차적인 접근 방식을 취하고 오퍼레이터가 순서대로 적절히 배치된 경우, 즉 삽입 중에 이전 오퍼레이터가 항상 프레임과 그림자로 표시된 경우에 특히 잘 작동합니다. 그러나 특히 더 복잡한 프로세스의 경우 의도하지 않은 연결이 발생할 수 있으므로, 완전 자동 연결 후에는 항상 수동 검토를 수행하는 것이 좋습니다.",
                "html": "이 옵션은 Process View의 플러그 기호 뒤에 숨겨져 있습니다. 프로세스가 생성될 때 비교적 순차적인 접근 방식을 취하고 오퍼레이터가 순서대로 적절히 배치된 경우, 즉 삽입 중에 이전 오퍼레이터가 항상 프레임과 그림자로 표시된 경우에 특히 잘 작동합니다. 그러나 특히 더 복잡한 프로세스의 경우 의도하지 않은 연결이 발생할 수 있으므로, 완전 자동 연결 후에는 항상 수동 검토를 수행하는 것이 좋습니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 2.17: 출력 포트를 클릭하여 연결하고, 오른쪽 클릭으로 취소합니다.",
                "html": "그림 2.17: 출력 포트를 클릭하여 연결하고, 오른쪽 클릭으로 취소합니다. "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터 선택",
                "html": "오퍼레이터 선택 "
              },
              {
                "type": "paragraph",
                "text": "파라미터를 편집하려면 개별 오퍼레이터를 선택해야 합니다. 현재 선택된 오퍼레이터는 주황색 프레임과 그림자로 식별할 수 있습니다.",
                "html": "파라미터를 편집하려면 개별 오퍼레이터를 선택해야 합니다. 현재 선택된 오퍼레이터는 주황색 프레임과 그림자로 식별할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "여러 오퍼레이터에 대해 이동이나 삭제 등의 작업을 동시에 수행하려면, 해당 오퍼레이터 주위에 프레임을 드래그하여 선택하십시오.",
                "html": "여러 오퍼레이터에 대해 이동이나 삭제 등의 작업을 동시에 수행하려면, 해당 오퍼레이터 주위에 프레임을 드래그하여 선택하십시오. "
              },
              {
                "type": "paragraph",
                "text": "현재 선택에 개별 오퍼레이터를 추가하거나 현재 선택에서 개별 오퍼레이터를 제외하려면, CTRL 키를 누른 상태에서 해당 오퍼레이터를 클릭하거나 프레임을 드래그하여 추가 오퍼레이터를 추가하십시오.",
                "html": "현재 선택에 개별 오퍼레이터를 추가하거나 현재 선택에서 개별 오퍼레이터를 제외하려면, CTRL 키를 누른 상태에서 해당 오퍼레이터를 클릭하거나 프레임을 드래그하여 추가 오퍼레이터를 추가하십시오. "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터 이동",
                "html": "오퍼레이터 이동 "
              },
              {
                "type": "paragraph",
                "text": "위에서 설명한 대로 하나 이상의 오퍼레이터를 선택하십시오. 이제 선택된 오퍼레이터 중 하나 위로 커서를 이동하고 버튼을 누른 상태에서 마우스를 드래그하십시오. 선택된 모든 오퍼레이터가 마우스 이동에 따라 새 위치로 이동합니다.",
                "html": "위에서 설명한 대로 하나 이상의 오퍼레이터를 선택하십시오. 이제 선택된 오퍼레이터 중 하나 위로 커서를 이동하고 버튼을 누른 상태에서 마우스를 드래그하십시오. 선택된 모든 오퍼레이터가 마우스 이동에 따라 새 위치로 이동합니다. "
              },
              {
                "type": "paragraph",
                "text": "이 이동 중에 흰색 영역의 가장자리에 도달하면, 해당 영역이 자동으로 확대됩니다. 보이는 영역의 가장자리에 도달하면, 이 영역도 자동으로 함께 이동합니다.",
                "html": "이 이동 중에 흰색 영역의 가장자리에 도달하면, 해당 영역이 자동으로 확대됩니다. 보이는 영역의 가장자리에 도달하면, 이 영역도 자동으로 함께 이동합니다. "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터 복사",
                "html": "오퍼레이터 복사 "
              },
              {
                "type": "paragraph",
                "text": "위에서 설명한 대로 하나 이상의 오퍼레이터를 선택하십시오. 이제 Ctrl+C를 눌러 선택된 오퍼레이터를 복사하고 Ctrl+V를 눌러 붙여넣으십시오. 선택된 모든 오퍼레이터가 원래 오퍼레이터 옆의 새 위치에 배치되며, 추가로 이동할 수 있습니다.",
                "html": "위에서 설명한 대로 하나 이상의 오퍼레이터를 선택하십시오. 이제 Ctrl+C를 눌러 선택된 오퍼레이터를 복사하고 Ctrl+V를 눌러 붙여넣으십시오. 선택된 모든 오퍼레이터가 원래 오퍼레이터 옆의 새 위치에 배치되며, 추가로 이동할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터 삭제",
                "html": "오퍼레이터 삭제 "
              },
              {
                "type": "paragraph",
                "text": "위에서 설명한 대로 하나 이상의 오퍼레이터를 선택하십시오. 이제 다음 방법으로 선택된 오퍼레이터를 삭제할 수 있습니다:",
                "html": "위에서 설명한 대로 하나 이상의 오퍼레이터를 선택하십시오. 이제 다음 방법으로 선택된 오퍼레이터를 삭제할 수 있습니다: "
              },
              {
                "type": "paragraph",
                "text": "• DELETE 키를 눌러,",
                "html": "• DELETE 키를 눌러, "
              },
              {
                "type": "paragraph",
                "text": "• 선택된 오퍼레이터 중 하나의 컨텍스트 메뉴에서 \"Delete\" 동작을 선택하여,",
                "html": "• 선택된 오퍼레이터 중 하나의 컨텍스트 메뉴에서 \"Delete\" 동작을 선택하여, "
              },
              {
                "type": "paragraph",
                "text": "• 메뉴 항목 \"Edit\" - \"Delete\"를 통해.",
                "html": "• 메뉴 항목 \"Edit\" - \"Delete\"를 통해. "
              },
              {
                "type": "paragraph",
                "text": "연결 삭제",
                "html": "연결 삭제 "
              },
              {
                "type": "paragraph",
                "text": "ALT 키를 누른 상태에서 두 포트 중 하나를 클릭하여 연결을 삭제할 수 있습니다. 또는 해당 포트의 컨텍스트 메뉴를 통해서도",
                "html": "ALT 키를 누른 상태에서 두 포트 중 하나를 클릭하여 연결을 삭제할 수 있습니다. 또는 해당 포트의 컨텍스트 메뉴를 통해서도 "
              },
              {
                "type": "paragraph",
                "text": "연결을 삭제할 수 있습니다.",
                "html": "연결을 삭제할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "프로세스 내 탐색",
                "html": "프로세스 내 탐색 "
              },
              {
                "type": "paragraph",
                "text": "Process View의 도구 모음을 살펴보면, 지금까지 하나의 동작만 사용했음을 알 수 있습니다. 이 섹션에서는 도구 모음 왼쪽에 있는 다음 네 가지 요소에 대해 설명합니다: 왼쪽 화살표, 오른쪽 화살표, 위쪽 화살표 및 탐색 바(브레드크럼).",
                "html": "Process View의 도구 모음을 살펴보면, 지금까지 하나의 동작만 사용했음을 알 수 있습니다. 이 섹션에서는 도구 모음 왼쪽에 있는 다음 네 가지 요소에 대해 설명합니다: 왼쪽 화살표, 오른쪽 화살표, 위쪽 화살표 및 탐색 바(브레드크럼). "
              },
              {
                "type": "paragraph",
                "text": "그림 2.18: Process View의 동작들",
                "html": "그림 2.18: Process View의 동작들 "
              },
              {
                "type": "paragraph",
                "text": "개별 동작들:",
                "html": "개별 동작들: "
              },
              {
                "type": "paragraph",
                "text": "왼쪽 화살표: 인터넷 브라우저에서 익숙한 탐색과 유사한 방식으로 마지막 편집 위치로 돌아갑니다. 팝업 메뉴를 통해 개별 단계를 건너뛸 수도 있습니다.",
                "html": "왼쪽 화살표: 인터넷 브라우저에서 익숙한 탐색과 유사한 방식으로 마지막 편집 위치로 돌아갑니다. 팝업 메뉴를 통해 개별 단계를 건너뛸 수도 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "오른쪽 화살표: 인터넷 브라우저에서 익숙한 탐색과 유사한 방식으로 기록에서 가장 최근의 편집 위치로 돌아갑니다. 팝업 메뉴를 통해 개별 단계를 건너뛸 수도 있습니다.",
                "html": "오른쪽 화살표: 인터넷 브라우저에서 익숙한 탐색과 유사한 방식으로 기록에서 가장 최근의 편집 위치로 돌아갑니다. 팝업 메뉴를 통해 개별 단계를 건너뛸 수도 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "위쪽 화살표: 현재 서브프로세스를 떠나 상위 프로세스로 돌아갑니다.",
                "html": "위쪽 화살표: 현재 서브프로세스를 떠나 상위 프로세스로 돌아갑니다. "
              },
              {
                "type": "paragraph",
                "text": "탐색 바: 탐색 바는 메인 프로세스에서 현재 서브프로세스까지 거쳐온 모든 레벨의 경로를 보여줍니다. 오퍼레이터 중 하나를 한 번 클릭하면 해당 프로세스가 표시됩니다. 오른쪽을 가리키는 작은 화살표를 사용하여 더 아래로 탐색할 수 있습니다.",
                "html": "탐색 바: 탐색 바는 메인 프로세스에서 현재 서브프로세스까지 거쳐온 모든 레벨의 경로를 보여줍니다. 오퍼레이터 중 하나를 한 번 클릭하면 해당 프로세스가 표시됩니다. 오른쪽을 가리키는 작은 화살표를 사용하여 더 아래로 탐색할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "따라서 서브프로세스로 내려가려면 오른쪽 하단에 서브프로세스 아이콘이 있는 오퍼레이터를 더블클릭해야 합니다. 한 레벨 위로 올라가려면 화살표를 사용하여 위쪽으로 탐색할 수 있습니다. 현재 경로는",
                "html": "따라서 서브프로세스로 내려가려면 오른쪽 하단에 서브프로세스 아이콘이 있는 오퍼레이터를 더블클릭해야 합니다. 한 레벨 위로 올라가려면 화살표를 사용하여 위쪽으로 탐색할 수 있습니다. 현재 경로는 "
              },
              {
                "type": "paragraph",
                "text": "탐색 바(그림 2.19)에 의해 표시되며, 양방향으로 탐색하는 데 사용할 수도 있습니다.",
                "html": "탐색 바(그림 2.19)에 의해 표시되며, 양방향으로 탐색하는 데 사용할 수도 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 2.19: \"Validation\"이라는 이름의 서브프로세스로, 위쪽 화살표나 탐색 바를 사용하여 다시 빠져나갈 수 있습니다.",
                "html": "그림 2.19: \"Validation\"이라는 이름의 서브프로세스로, 위쪽 화살표나 탐색 바를 사용하여 다시 빠져나갈 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "실행 순서 정의",
                "html": "실행 순서 정의 "
              },
              {
                "type": "paragraph",
                "text": "거의 모든 경우에 RapidMiner은 오퍼레이터의 올바른 실행 순서를 자동으로 결정하는 데 성공합니다. 이를 위해 RapidMiner은 연결 정보와 결과가 다른 오퍼레이터에 의해 사용될 오퍼레이터가 후자보다 먼저 실행되어야 한다는 사실을 활용합니다.",
                "html": "거의 모든 경우에 RapidMiner은 오퍼레이터의 올바른 실행 순서를 자동으로 결정하는 데 성공합니다. 이를 위해 RapidMiner은 연결 정보와 결과가 다른 오퍼레이터에 의해 사용될 오퍼레이터가 후자보다 먼저 실행되어야 한다는 사실을 활용합니다. "
              },
              {
                "type": "paragraph",
                "text": "그러나 완전히 병렬적인 서브프로세스와 같이 순서를 자동으로 정의할 수 없는 경우나, 매크로가 후속 오퍼레이터의 파라미터로 사용되기 전에 먼저 계산되어야 하는 경우와 같이 자동 순서가 올바르지 않은 경우가 있습니다. 하지만 더 효율적인 데이터 처리나 실행의 정확한 순서(예: 리포팅) 등의 다른 이유도 중요한 역할을 하는 경우가 많습니다.",
                "html": "그러나 완전히 병렬적인 서브프로세스와 같이 순서를 자동으로 정의할 수 없는 경우나, 매크로가 후속 오퍼레이터의 파라미터로 사용되기 전에 먼저 계산되어야 하는 경우와 같이 자동 순서가 올바르지 않은 경우가 있습니다. 하지만 더 효율적인 데이터 처리나 실행의 정확한 순서(예: 리포팅) 등의 다른 이유도 중요한 역할을 하는 경우가 많습니다. "
              },
              {
                "type": "paragraph",
                "text": "이를 위해 RapidMiner은 오퍼레이터의 순서를 표시하고 실행 순서를 편리하게 편집할 수 있는 우아한 방법을 제공합니다. Process View 도구 모음(그림 2.18)에서 물음표가 있는 위아래 이중 화살표 아이콘을 클릭하면 프로세스 뷰에 오퍼레이터의 순서 정의가 표시됩니다. 각 오퍼레이터의 아이콘 대신 실행 번호가 표시됩니다. 그림 2.20에 표시된 것처럼 투명한 주황색 선이 이 순서대로 오퍼레이터를 연결합니다.",
                "html": "이를 위해 RapidMiner은 오퍼레이터의 순서를 표시하고 실행 순서를 편리하게 편집할 수 있는 우아한 방법을 제공합니다. Process View 도구 모음(그림 2.18)에서 물음표가 있는 위아래 이중 화살표 아이콘을 클릭하면 프로세스 뷰에 오퍼레이터의 순서 정의가 표시됩니다. 각 오퍼레이터의 아이콘 대신 실행 번호가 표시됩니다. 그림 2.20에 표시된 것처럼 투명한 주황색 선이 이 순서대로 오퍼레이터를 연결합니다. "
              },
              {
                "type": "paragraph",
                "text": "이러한 실행 순서를 변경하려면, 오퍼레이터의 아무 곳이나 클릭하여 선택할 수 있습니다. 이 오퍼레이터까지의 경로는 변경할 수 없지만, 다른 오퍼레이터를 다시 클릭하면 두 번째 오퍼레이터가 첫 번째 오퍼레이터 직후에 가능한 한 빨리 실행되도록 순서를 변경하려고 시도합니다. 나머지 오퍼레이터 위로 마우스를 이동하면 이 오퍼레이터까지는 현재 선택이 주황색으로, 이 오퍼레이터부터는 회색으로 표시됩니다. 불가능한 선택은 빨간색 숫자로 표시됩니다. 오른쪽 클릭으로 현재 선택을 취소할 수 있습니다. 이러한 방식으로, 그림 2.21에 표시된 것처럼 위에서 설명한 프로세스의 순서를 몇 번의 클릭만으로 다음과 같이 변경할 수 있습니다.",
                "html": "이러한 실행 순서를 변경하려면, 오퍼레이터의 아무 곳이나 클릭하여 선택할 수 있습니다. 이 오퍼레이터까지의 경로는 변경할 수 없지만, 다른 오퍼레이터를 다시 클릭하면 두 번째 오퍼레이터가 첫 번째 오퍼레이터 직후에 가능한 한 빨리 실행되도록 순서를 변경하려고 시도합니다. 나머지 오퍼레이터 위로 마우스를 이동하면 이 오퍼레이터까지는 현재 선택이 주황색으로, 이 오퍼레이터부터는 회색으로 표시됩니다. 불가능한 선택은 빨간색 숫자로 표시됩니다. 오른쪽 클릭으로 현재 선택을 취소할 수 있습니다. 이러한 방식으로, 그림 2.21에 표시된 것처럼 위에서 설명한 프로세스의 순서를 몇 번의 클릭만으로 다음과 같이 변경할 수 있습니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "2-3-4-further-options-of-the-process-view",
            "number": "2.3.4",
            "title": "Process View의 추가 옵션",
            "blocks": [
              {
                "type": "paragraph",
                "text": "RapidMiner Design Perspective의 이 중앙 요소의 거의 모든 옵션을 논의한 후, 이제 그림 2.18에서 볼 수 있는 도구 모음의 나머지 동작과 Process View의 추가 가능성에 대해 설명하겠습니다.",
                "html": "RapidMiner Design Perspective의 이 중앙 요소의 거의 모든 옵션을 논의한 후, 이제 그림 2.18에서 볼 수 있는 도구 모음의 나머지 동작과 Process View의 추가 가능성에 대해 설명하겠습니다. "
              },
              {
                "type": "paragraph",
                "text": "Process View 도구 모음 오른쪽의 다섯 가지 아이콘은 다음 동작을 수행합니다:",
                "html": "Process View 도구 모음 오른쪽의 다섯 가지 아이콘은 다음 동작을 수행합니다: "
              },
              {
                "type": "paragraph",
                "text": "연결 자동 설정 및 재설정 플러그 기호를 통해 오퍼레이터 간의 연결을 자동 설정(Auto-wire) 및 재설정(Re-wire)할 수 있습니다.",
                "html": "연결 자동 설정 및 재설정 플러그 기호를 통해 오퍼레이터 간의 연결을 자동 설정(Auto-wire) 및 재설정(Re-wire)할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "자동 배치: 현재 프로세스의 모든 오퍼레이터를 연결과 현재 실행 순서에 따라 재배치합니다.",
                "html": "자동 배치: 현재 프로세스의 모든 오퍼레이터를 연결과 현재 실행 순서에 따라 재배치합니다. "
              },
              {
                "type": "paragraph",
                "text": "실행 순서 표시 및 변경 이 동작을 통해 오퍼레이터의 실행",
                "html": "실행 순서 표시 및 변경 이 동작을 통해 오퍼레이터의 실행"
              },
              {
                "type": "paragraph",
                "text": "그림 2.20: 실행 순서의 표현. 그러나 이 순서는 동시에 더 많은 데이터 세트를 처리해야 하므로 비효율적입니다.",
                "html": "그림 2.20: 실행 순서의 표현. 그러나 이 순서는 동시에 더 많은 데이터 세트를 처리해야 하므로 비효율적입니다. "
              },
              {
                "type": "paragraph",
                "text": "순서를 확인하고 변경할 수 있습니다.",
                "html": "순서를 확인하고 변경할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "자동 크기: 현재 배치된 모든 오퍼레이터가 딱 맞을 정도로 흰색 작업 영역의 크기를 변경합니다. 이는",
                "html": "자동 크기: 현재 배치된 모든 오퍼레이터가 딱 맞을 정도로 흰색 작업 영역의 크기를 변경합니다. 이는 "
              },
              {
                "type": "paragraph",
                "text": "그림 2.21: 일부 변경 후의 새로운 순서.",
                "html": "그림 2.21: 일부 변경 후의 새로운 순서. "
              },
              {
                "type": "paragraph",
                "text": "자동 축소(크기 최적화)에 특히 유용합니다.",
                "html": "자동 축소(크기 최적화)에 특히 유용합니다. "
              },
              {
                "type": "paragraph",
                "text": "예상 메타 데이터 업데이트: 클릭하면, 포트의 예상 메타 데이터 정보가 오퍼레이터 실행 후 실제 데이터와 일치하도록 업데이트됩니다.",
                "html": "예상 메타 데이터 업데이트: 클릭하면, 포트의 예상 메타 데이터 정보가 오퍼레이터 실행 후 실제 데이터와 일치하도록 업데이트됩니다. "
              },
              {
                "type": "paragraph",
                "text": "추가로, 컨텍스트 메뉴를 통해 프로세스를 PDF 및 기타",
                "html": "추가로, 컨텍스트 메뉴를 통해 프로세스를 PDF 및 기타"
              },
              {
                "type": "paragraph",
                "text": "형식으로 내보내고 인쇄할 수 있습니다.",
                "html": "형식으로 내보내고 인쇄할 수 있습니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "2-3-5-parameters-view",
            "number": "2.3.5",
            "title": "Parameters View",
            "blocks": [
              {
                "type": "paragraph",
                "text": "그림 2.22: 현재 선택된 오퍼레이터의 파라미터는 Parameters View에서 설정됩니다.",
                "html": "그림 2.22: 현재 선택된 오퍼레이터의 파라미터는 Parameters View에서 설정됩니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 2.22는 RapidMiner의 Parameters View를 보여줍니다. 많은 오퍼레이터는 올바른 기능을 위해 하나 이상의 파라미터를 지정해야 합니다. 예를 들어, 파일에서 데이터를 읽는 오퍼레이터는 파일 경로를 지정해야 합니다. 그러나 훨씬 더 많은 경우에 파라미터가 반드시 필요한 것은 아니지만, 특정 파라미터 값을 지정하여 오퍼레이터의 실행을 제어할 수 있으며, 모델링의 경우에는 자주 최적화할 수도 있습니다.",
                "html": "그림 2.22는 RapidMiner의 Parameters View를 보여줍니다. 많은 오퍼레이터는 올바른 기능을 위해 하나 이상의 파라미터를 지정해야 합니다. 예를 들어, 파일에서 데이터를 읽는 오퍼레이터는 파일 경로를 지정해야 합니다. 그러나 훨씬 더 많은 경우에 파라미터가 반드시 필요한 것은 아니지만, 특정 파라미터 값을 지정하여 오퍼레이터의 실행을 제어할 수 있으며, 모델링의 경우에는 자주 최적화할 수도 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "파라미터를 제공하는 오퍼레이터가 Process View에서 선택된 후, 해당 파라미터가 Parameters View에 표시됩니다. 다른 뷰와 마찬가지로 이 뷰에도",
                "html": "파라미터를 제공하는 오퍼레이터가 Process View에서 선택된 후, 해당 파라미터가 Parameters View에 표시됩니다. 다른 뷰와 마찬가지로 이 뷰에도 "
              },
              {
                "type": "paragraph",
                "text": "자체 툴바가 있으며 아래에서 설명합니다. 툴바 아래에는 현재 선택된 오퍼레이터의 아이콘과 이름이 표시되고, 그 다음에 실제 파라미터가 표시됩니다. 굵은 글꼴은 해당 파라미터가 반드시 정의되어야 하며 기본값이 없음을 의미합니다. 기울임꼴은 해당 파라미터가 전문가 파라미터로 분류되어 있으며 데이터 분석 초보자가 반드시 변경할 필요는 없음을 의미합니다. 그림 2.23은 Parameters View를 자세히 보여줍니다.",
                "html": "자체 툴바가 있으며 아래에서 설명합니다. 툴바 아래에는 현재 선택된 오퍼레이터의 아이콘과 이름이 표시되고, 그 다음에 실제 파라미터가 표시됩니다. 굵은 글꼴은 해당 파라미터가 반드시 정의되어야 하며 기본값이 없음을 의미합니다. 기울임꼴은 해당 파라미터가 전문가 파라미터로 분류되어 있으며 데이터 분석 초보자가 반드시 변경할 필요는 없음을 의미합니다. 그림 2.23은 Parameters View를 자세히 보여줍니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 2.23: \"nominal to date\" 오퍼레이터의 파라미터.",
                "html": "그림 2.23: \"nominal to date\" 오퍼레이터의 파라미터. "
              },
              {
                "type": "paragraph",
                "text": "일부 파라미터는 다른 파라미터가 특정 값을 가질 때만 표시된다는 점에 유의하십시오. 예를 들어, \"sampling\" 오퍼레이터에서 샘플링 유형으로 \"absolute\"가 선택된 경우에만 원하는 예제의 절대 수를 지정할 수 있습니다.",
                "html": "일부 파라미터는 다른 파라미터가 특정 값을 가질 때만 표시된다는 점에 유의하십시오. 예를 들어, \"sampling\" 오퍼레이터에서 샘플링 유형으로 \"absolute\"가 선택된 경우에만 원하는 예제의 절대 수를 지정할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "툴바의 작업은 파라미터와 마찬가지로 현재 선택된 오퍼레이터를 대상으로 합니다.",
                "html": "툴바의 작업은 파라미터와 마찬가지로 현재 선택된 오퍼레이터를 대상으로 합니다. "
              },
              {
                "type": "paragraph",
                "text": "Expert Mode: 왼쪽의 아이콘은 전문가 모드와 초보자",
                "html": "Expert Mode: 왼쪽의 아이콘은 전문가 모드와 초보자"
              },
              {
                "type": "paragraph",
                "text": "모드 간에 전환합니다. 전문가 모드에서만 모든 파라미터가 표시되며, 초보자 모드에서는 전문가 파라미터로 분류된 파라미터가 표시되지 않습니다.",
                "html": "모드 간에 전환합니다. 전문가 모드에서만 모든 파라미터가 표시되며, 초보자 모드에서는 전문가 파라미터로 분류된 파라미터가 표시되지 않습니다. "
              },
              {
                "type": "paragraph",
                "text": "Operator Info: 예상 입력 또는 설명과 같은 해당 오퍼레이터에 대한 기본 정보를 표시합니다. 이 대화 상자는 선택 후 F1을 눌러 표시하거나, Process View의 컨텍스트 메뉴를 통해, 또는 \"Edit\" – \"Show Operator Info. . . \" 메뉴 항목을 통해서도 표시할 수 있습니다.",
                "html": "Operator Info: 예상 입력 또는 설명과 같은 해당 오퍼레이터에 대한 기본 정보를 표시합니다. 이 대화 상자는 선택 후 F1을 눌러 표시하거나, Process View의 컨텍스트 메뉴를 통해, 또는 \"Edit\" – \"Show Operator Info. . . \" 메뉴 항목을 통해서도 표시할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "Enable/Disable: 오퍼레이터를 (일시적으로) 비활성화할 수 있습니다. 연결이 해제되고 더 이상 실행되지 않습니다. 비활성화된 오퍼레이터는 회색으로 표시됩니다. 오퍼레이터는 Process View의 컨텍스트 메뉴 또는 \"Edit\" – \"Enable Operator\" 메뉴 항목을 통해서도 활성화/비활성화할 수 있습니다.",
                "html": "Enable/Disable: 오퍼레이터를 (일시적으로) 비활성화할 수 있습니다. 연결이 해제되고 더 이상 실행되지 않습니다. 비활성화된 오퍼레이터는 회색으로 표시됩니다. 오퍼레이터는 Process View의 컨텍스트 메뉴 또는 \"Edit\" – \"Enable Operator\" 메뉴 항목을 통해서도 활성화/비활성화할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "Rename: 오퍼레이터의 이름을 변경하는 방법 중 하나입니다. 다른 방법으로는 선택 후 F2를 누르거나, Process View에서 오퍼레이터의 컨텍스트 메뉴에서 \"Rename\"을 선택하거나, \"Edit\" – \"Rename\" 메뉴 항목을 사용하는 것이 있습니다.",
                "html": "Rename: 오퍼레이터의 이름을 변경하는 방법 중 하나입니다. 다른 방법으로는 선택 후 F2를 누르거나, Process View에서 오퍼레이터의 컨텍스트 메뉴에서 \"Rename\"을 선택하거나, \"Edit\" – \"Rename\" 메뉴 항목을 사용하는 것이 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "Delete: 오퍼레이터를 삭제하는 방법 중 하나입니다. 다른 방법으로는 선택 후 DELETE 키를 누르거나, Process View에서 오퍼레이터의 컨텍스트 메뉴에서 \"Delete\"를 선택하거나, \"Edit\" – \"Delete\" 메뉴 항목을 사용하는 것이 있습니다.",
                "html": "Delete: 오퍼레이터를 삭제하는 방법 중 하나입니다. 다른 방법으로는 선택 후 DELETE 키를 누르거나, Process View에서 오퍼레이터의 컨텍스트 메뉴에서 \"Delete\"를 선택하거나, \"Edit\" – \"Delete\" 메뉴 항목을 사용하는 것이 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "Toggle Breakpoints: 오퍼레이터 실행 전후에 중단점을 설정할 수 있으며, 이 지점에서 프로세스 실행이 중단되고 중간 결과를 검토할 수 있습니다. Process View에서 오퍼레이터의 컨텍스트 메뉴 또는 \"Edit\" 메뉴에서도 이 기능을 사용할 수 있습니다. 오퍼레이터 실행 후 중단점은 F7 키로도 활성화 및 비활성화할 수 있습니다.",
                "html": "Toggle Breakpoints: 오퍼레이터 실행 전후에 중단점을 설정할 수 있으며, 이 지점에서 프로세스 실행이 중단되고 중간 결과를 검토할 수 있습니다. Process View에서 오퍼레이터의 컨텍스트 메뉴 또는 \"Edit\" 메뉴에서도 이 기능을 사용할 수 있습니다. 오퍼레이터 실행 후 중단점은 F7 키로도 활성화 및 비활성화할 수 있습니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "2-3-6-help-and-comment-view",
            "number": "2.3.6",
            "title": "Help View 및 Comment View",
            "blocks": [
              {
                "type": "paragraph",
                "text": "Help View",
                "html": "Help View "
              },
              {
                "type": "paragraph",
                "text": "Operators View 또는 Process View에서 오퍼레이터를 선택할 때마다 Help View 내의 도움말 창에 해당 오퍼레이터에 대한 설명이 표시됩니다. 이",
                "html": "Operators View 또는 Process View에서 오퍼레이터를 선택할 때마다 Help View 내의 도움말 창에 해당 오퍼레이터에 대한 설명이 표시됩니다. 이 "
              },
              {
                "type": "paragraph",
                "text": "그림 2.24: 도움말 텍스트는 Operators View에서 현재 선택된 오퍼레이터와 Process View에서 현재 선택된 오퍼레이터 모두에 대해 표시됩니다.",
                "html": "그림 2.24: 도움말 텍스트는 Operators View에서 현재 선택된 오퍼레이터와 Process View에서 현재 선택된 오퍼레이터 모두에 대해 표시됩니다. "
              },
              {
                "type": "paragraph",
                "text": "설명에는 오퍼레이터의 기능을 한두 문장으로 요약한 짧은 개요, 오퍼레이터 기능에 대한 상세한 설명, 그리고 파라미터에 대한 간단한 설명, 기본값(사용 가능한 경우), 전문가 파라미터 여부에 대한 표시 및 파라미터 종속성 표시를 포함한 모든 파라미터 목록이 포함됩니다.",
                "html": "설명에는 오퍼레이터의 기능을 한두 문장으로 요약한 짧은 개요, 오퍼레이터 기능에 대한 상세한 설명, 그리고 파라미터에 대한 간단한 설명, 기본값(사용 가능한 경우), 전문가 파라미터 여부에 대한 표시 및 파라미터 종속성 표시를 포함한 모든 파라미터 목록이 포함됩니다. "
              },
              {
                "type": "paragraph",
                "text": "Comment View",
                "html": "Comment View "
              },
              {
                "type": "paragraph",
                "text": "Help View와 달리, Comment View는 미리 정의된 설명이 아니라 프로세스의 개별 단계에 대한 사용자 자신의 코멘트를 위한 것입니다. 오퍼레이터를 선택하고 코멘트 필드에 원하는 텍스트를 작성하기만 하면 됩니다. 이 내용은 프로세스 정의와 함께 저장되며, 나중에 설계의 개별 단계를 추적하는 데 유용할 수 있습니다. 오퍼레이터에 코멘트가 있다는 사실은",
                "html": "Help View와 달리, Comment View는 미리 정의된 설명이 아니라 프로세스의 개별 단계에 대한 사용자 자신의 코멘트를 위한 것입니다. 오퍼레이터를 선택하고 코멘트 필드에 원하는 텍스트를 작성하기만 하면 됩니다. 이 내용은 프로세스 정의와 함께 저장되며, 나중에 설계의 개별 단계를 추적하는 데 유용할 수 있습니다. 오퍼레이터에 코멘트가 있다는 사실은 "
              },
              {
                "type": "paragraph",
                "text": "오퍼레이터 하단 가장자리에 있는 작은 텍스트 아이콘으로 표시됩니다.",
                "html": "오퍼레이터 하단 가장자리에 있는 작은 텍스트 아이콘으로 표시됩니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "2-3-7-overview-view",
            "number": "2.3.7",
            "title": "Overview View",
            "blocks": [
              {
                "type": "paragraph",
                "text": "특히 대규모 프로세스의 경우, 흰색 작업 영역이 더 이상 충분하지 않게 되어 Process View의 컨텍스트 메뉴를 통해, Ctrl 키와 좌우상하 화살표 키 조합을 사용하여, 또는 단순히 오퍼레이터를 가장자리로 끌어서 확장하게 됩니다. 그러나 이 경우 전체 작업 영역을 동시에 볼 수 없게 되고 프로세스 내의 탐색이 어려워집니다. 전체 개요를 개선하고 동시에 편리한 탐색 방법을 제공하기 위해, RapidMiner Studio는 Overview View(그림 2.25)를 제공합니다. 이 뷰는 전체 작업 영역을 보여주고 현재 표시된 부분을 작은 상자로 강조 표시합니다.",
                "html": "특히 대규모 프로세스의 경우, 흰색 작업 영역이 더 이상 충분하지 않게 되어 Process View의 컨텍스트 메뉴를 통해, Ctrl 키와 좌우상하 화살표 키 조합을 사용하여, 또는 단순히 오퍼레이터를 가장자리로 끌어서 확장하게 됩니다. 그러나 이 경우 전체 작업 영역을 동시에 볼 수 없게 되고 프로세스 내의 탐색이 어려워집니다. 전체 개요를 개선하고 동시에 편리한 탐색 방법을 제공하기 위해, RapidMiner Studio는 Overview View(그림 2.25)를 제공합니다. 이 뷰는 전체 작업 영역을 보여주고 현재 표시된 부분을 작은 상자로 강조 표시합니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 2.25: Overview View는 전체 프로세스를 보여주고 표시되는 부분을 강조 표시합니다.",
                "html": "그림 2.25: Overview View는 전체 프로세스를 보여주고 표시되는 부분을 강조 표시합니다. "
              },
              {
                "type": "paragraph",
                "text": "스크롤할 때 Process View 내에서 섹션이 이동하는 것을 볼 수 있습니다 - 스크롤바를 사용하거나 단순히 오퍼레이터를 섹션 가장자리로 끌어서 이동할 수 있습니다. 또는 이 개요에서 강조 표시된 영역을 원하는 위치로 끌어다 놓으면 Process View가 자동으로 조정됩니다.",
                "html": "스크롤할 때 Process View 내에서 섹션이 이동하는 것을 볼 수 있습니다 - 스크롤바를 사용하거나 단순히 오퍼레이터를 섹션 가장자리로 끌어서 이동할 수 있습니다. 또는 이 개요에서 강조 표시된 영역을 원하는 위치로 끌어다 놓으면 Process View가 자동으로 조정됩니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "2-3-8-problems-and-log-view",
            "number": "2.3.8",
            "title": "Problems View 및 Log View",
            "blocks": [
              {
                "type": "paragraph",
                "text": "Problems View",
                "html": "Problems View "
              },
              {
                "type": "paragraph",
                "text": "분석 프로세스 설계 중 매우 핵심적인 요소이자 귀중한 도움말 소스인 또 다른 것은 Problems View입니다. 모든 경고 및 오류 메시지가 여기에 표 형태로 명확하게 표시됩니다(그림 2.26).",
                "html": "분석 프로세스 설계 중 매우 핵심적인 요소이자 귀중한 도움말 소스인 또 다른 것은 Problems View입니다. 모든 경고 및 오류 메시지가 여기에 표 형태로 명확하게 표시됩니다(그림 2.26). "
              },
              {
                "type": "paragraph",
                "text": "그림 2.26: 모든 현재 문제의 표시.",
                "html": "그림 2.26: 모든 현재 문제의 표시. "
              },
              {
                "type": "paragraph",
                "text": "\"Message\"라는 이름의 첫 번째 열에서 문제에 대한 간단한 요약을 찾을 수 있습니다. 이 경우 데이터 마이닝 방법 \"Gaussian Process\"는 다항(다중 값 범주형) 속성을 처리할 수 없습니다. \"location\"이라는 마지막 열은 오퍼레이터 이름과 관련 입력 포트 이름의 형태로 문제가 발생하는 위치를 보여줍니다. Problems View 툴바 왼쪽에 있는 아이콘은 현재 선택된 오퍼레이터의 문제만 표시하는 필터를 활성화합니다. 이는 여러 오류 소스가 있는 대규모 프로세스에서 유용합니다.",
                "html": "\"Message\"라는 이름의 첫 번째 열에서 문제에 대한 간단한 요약을 찾을 수 있습니다. 이 경우 데이터 마이닝 방법 \"Gaussian Process\"는 다항(다중 값 범주형) 속성을 처리할 수 없습니다. \"location\"이라는 마지막 열은 오퍼레이터 이름과 관련 입력 포트 이름의 형태로 문제가 발생하는 위치를 보여줍니다. Problems View 툴바 왼쪽에 있는 아이콘은 현재 선택된 오퍼레이터의 문제만 표시하는 필터를 활성화합니다. 이는 여러 오류 소스가 있는 대규모 프로세스에서 유용합니다. "
              },
              {
                "type": "paragraph",
                "text": "이러한 문제에 대해 제안된 해결 방법을 직접 구현할 수도 있습니다. 이러한 해결 방법을 Quick Fixes라고 합니다. 두 번째 열은 해결 가능성이 하나뿐인 경우 직접 텍스트로, 또는 문제를 해결하기 위한 다양한 가능성이 몇 가지 존재하는지에 대한 표시로 이러한 가능한 해결책의 개요를 제공합니다. 위의 예에서 두 번째 문제를 처리하기 위한 두 가지 다른 가능성이 있습니다. 그런데 왜 이 해결 제안을 \"quick fix\"라고 부를까요? 이 경우 표에서 관련 quick fix 필드를 더블 클릭해 보십시오. 첫 번째 경우에는 해결 제안이 직접 실행되고 관련 오퍼레이터가 자동으로 구성 및 삽입되어",
                "html": "이러한 문제에 대해 제안된 해결 방법을 직접 구현할 수도 있습니다. 이러한 해결 방법을 Quick Fixes라고 합니다. 두 번째 열은 해결 가능성이 하나뿐인 경우 직접 텍스트로, 또는 문제를 해결하기 위한 다양한 가능성이 몇 가지 존재하는지에 대한 표시로 이러한 가능한 해결책의 개요를 제공합니다. 위의 예에서 두 번째 문제를 처리하기 위한 두 가지 다른 가능성이 있습니다. 그런데 왜 이 해결 제안을 \"quick fix\"라고 부를까요? 이 경우 표에서 관련 quick fix 필드를 더블 클릭해 보십시오. 첫 번째 경우에는 해결 제안이 직접 실행되고 관련 오퍼레이터가 자동으로 구성 및 삽입되어 "
              },
              {
                "type": "paragraph",
                "text": "필요한 전처리가 수행됩니다. 여러 해결 가능성이 있는 두 번째 경우에는 원하는 해결 방법을 선택하도록 요청하는 대화 상자가 나타납니다. 이 경우, 하나 이상의 필요한 오퍼레이터가 문제가 더 이상 발생하지 않도록 구성 및 삽입됩니다. 이러한 방식으로 문제를 매우 초기에 인식하고, 단 몇 번의 클릭만으로 설계 프로세스 중에 매우 편리하게 문제를 제거할 수 있습니다.",
                "html": "필요한 전처리가 수행됩니다. 여러 해결 가능성이 있는 두 번째 경우에는 원하는 해결 방법을 선택하도록 요청하는 대화 상자가 나타납니다. 이 경우, 하나 이상의 필요한 오퍼레이터가 문제가 더 이상 발생하지 않도록 구성 및 삽입됩니다. 이러한 방식으로 문제를 매우 초기에 인식하고, 단 몇 번의 클릭만으로 설계 프로세스 중에 매우 편리하게 문제를 제거할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "참고: 잠재적 문제의 판별 및 Quick Fixes의 생성은 메타 데이터가 올바르게 제공되는 것에 의존하는 RapidMiner Studio의 기능 중 하나입니다. 리포지토리를 사용하는 것을 강력히 권장합니다. 그렇지 않으면(예: 파일이나 데이터베이스에서 직접 데이터를 읽는 경우) 메타 데이터를 사용할 수 없으며 이러한 지원 기능이 제공되지 않습니다.",
                "html": "참고: 잠재적 문제의 판별 및 Quick Fixes의 생성은 메타 데이터가 올바르게 제공되는 것에 의존하는 RapidMiner Studio의 기능 중 하나입니다. 리포지토리를 사용하는 것을 강력히 권장합니다. 그렇지 않으면(예: 파일이나 데이터베이스에서 직접 데이터를 읽는 경우) 메타 데이터를 사용할 수 없으며 이러한 지원 기능이 제공되지 않습니다. "
              },
              {
                "type": "paragraph",
                "text": "Log View",
                "html": "Log View "
              },
              {
                "type": "paragraph",
                "text": "설계 중, 특히 프로세스 실행 중에 동시에 많은 메시지가 기록되며, 특히 오류 발생 시 변경된 프로세스 설계를 통해 오류를 제거하는 방법에 대한 정보를 제공할 수 있습니다.",
                "html": "설계 중, 특히 프로세스 실행 중에 동시에 많은 메시지가 기록되며, 특히 오류 발생 시 변경된 프로세스 설계를 통해 오류를 제거하는 방법에 대한 정보를 제공할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 2.27: 프로세스 실행 및 오류 발생 시에 대한 추가 정보는 Log View에서 확인할 수 있습니다.",
                "html": "그림 2.27: 프로세스 실행 및 오류 발생 시에 대한 추가 정보는 Log View에서 확인할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "Log View(그림 2.27) 내의 텍스트를 일반적인 방법으로 복사하여",
                "html": "Log View(그림 2.27) 내의 텍스트를 일반적인 방법으로 복사하여"
              },
              {
                "type": "paragraph",
                "text": "다른 응용 프로그램에서 추가로 처리할 수 있습니다. 또한 툴바의 작업을 사용하여 텍스트를 파일로 저장하거나, 전체 내용을 삭제하거나, 텍스트를 검색할 수 있습니다.",
                "html": "다른 응용 프로그램에서 추가로 처리할 수 있습니다. 또한 툴바의 작업을 사용하여 텍스트를 파일로 저장하거나, 전체 내용을 삭제하거나, 텍스트를 검색할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "3 분석 프로세스의",
                "html": "3 분석 프로세스의 "
              },
              {
                "type": "paragraph",
                "text": "설계",
                "html": "설계 "
              },
              {
                "type": "paragraph",
                "text": "지난 장에서 퍼스펙티브와 뷰 등 RapidMiner Studio 그래픽 사용자 인터페이스의 기본 요소에 대해 알아보고, RapidMiner Studio의 Design Perspective에서 가장 중요한 측면에 대해 논의했습니다. 이제 새로운 기능을 활용하여 초기의 간단한 분석 프로세스를 정의하고 실행해 보겠습니다. RapidMiner Studio에서는 변경 사항의 효과를 확인하기 위해 매번 프로세스를 다시 수행할 필요가 없다는 것이 얼마나 실용적인지 곧 알게 될 것입니다. 하지만 이에 대해서는 나중에 더 자세히 다루겠습니다.",
                "html": "지난 장에서 퍼스펙티브와 뷰 등 RapidMiner Studio 그래픽 사용자 인터페이스의 기본 요소에 대해 알아보고, RapidMiner Studio의 Design Perspective에서 가장 중요한 측면에 대해 논의했습니다. 이제 새로운 기능을 활용하여 초기의 간단한 분석 프로세스를 정의하고 실행해 보겠습니다. RapidMiner Studio에서는 변경 사항의 효과를 확인하기 위해 매번 프로세스를 다시 수행할 필요가 없다는 것이 얼마나 실용적인지 곧 알게 될 것입니다. 하지만 이에 대해서는 나중에 더 자세히 다루겠습니다. "
              }
            ],
            "subsections": []
          }
        ]
      }
    ]
  },
  {
    "id": "chapter-3",
    "number": "3",
    "title": "분석 프로세스의 설계",
    "slug": "chapter-3-design-of-analysis-processes",
    "blocks": [],
    "sections": [
      {
        "id": "3-1-creating-a-new-process",
        "number": "3.1",
        "title": "새 프로세스 만들기",
        "blocks": [
          {
            "type": "paragraph",
            "text": "Home Perspective에서 \"New\" 액션을 선택하든, RapidMiner Studio 메인 툴바 왼쪽의 \"New\" 아이콘을 선택하든, \"File\" 메뉴의 관련 항목을 선택하든 상관없이, 어떤 방법으로든 새로운 분석 프로세스가 생성되며 이후 작업을 진행할 수 있습니다.",
            "html": "Home Perspective에서 \"New\" 액션을 선택하든, RapidMiner Studio 메인 툴바 왼쪽의 \"New\" 아이콘을 선택하든, \"File\" 메뉴의 관련 항목을 선택하든 상관없이, 어떤 방법으로든 새로운 분석 프로세스가 생성되며 이후 작업을 진행할 수 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "팁: 프로세스가 생성되면 리포지토리에 저장하는 것을 권장합니다. 53",
            "html": "팁: 프로세스가 생성되면 리포지토리에 저장하는 것을 권장합니다. 53"
          }
        ],
        "subsections": []
      },
      {
        "id": "3-2-repository-actions",
        "number": "3.2",
        "title": "리포지토리 액션",
        "blocks": [
          {
            "type": "paragraph",
            "text": "원칙적으로 리포지토리의 구조는 완전히 자유롭게 설정할 수 있습니다. 리포지토리 브라우저의 항목에 대한 컨텍스트 메뉴와 리포지토리 뷰에서 데이터 및 프로세스 관리에 필요한 모든 항목을 찾을 수 있으며, 이는 그림 3.1에서 확인할 수 있습니다.",
            "html": "원칙적으로 리포지토리의 구조는 완전히 자유롭게 설정할 수 있습니다. 리포지토리 브라우저의 항목에 대한 컨텍스트 메뉴와 리포지토리 뷰에서 데이터 및 프로세스 관리에 필요한 모든 항목을 찾을 수 있으며, 이는 그림 3.1에서 확인할 수 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "그림 3.1: 리포지토리 브라우저와 리포지토리 뷰 모두에서 리포지토리 항목의 컨텍스트 메뉴는 관리에 필요한 모든 옵션을 제공합니다.",
            "html": "그림 3.1: 리포지토리 브라우저와 리포지토리 뷰 모두에서 리포지토리 항목의 컨텍스트 메뉴는 관리에 필요한 모든 옵션을 제공합니다. "
          },
          {
            "type": "paragraph",
            "text": "Store Process Here: 현재 프로세스를 지정된 위치에 저장합니다 54",
            "html": "Store Process Here: 현재 프로세스를 지정된 위치에 저장합니다 54"
          },
          {
            "type": "paragraph",
            "text": "Rename: 항목 또는 디렉토리의 이름을 변경합니다",
            "html": "Rename: 항목 또는 디렉토리의 이름을 변경합니다 "
          },
          {
            "type": "paragraph",
            "text": "Create Folder: 해당 위치에 새 디렉토리를 생성합니다",
            "html": "Create Folder: 해당 위치에 새 디렉토리를 생성합니다 "
          },
          {
            "type": "paragraph",
            "text": "Copy: 선택한 항목을 복사하여 다른 위치에 붙여넣을 수 있도록 합니다 Paste: 이전에 복사한 항목을 해당 위치에 붙여넣습니다",
            "html": "Copy: 선택한 항목을 복사하여 다른 위치에 붙여넣을 수 있도록 합니다 Paste: 이전에 복사한 항목을 해당 위치에 붙여넣습니다 "
          },
          {
            "type": "paragraph",
            "text": "Copy Location to Clipboard: 이 항목의 고유 식별자를 클립보드에 복사합니다. 이를 통해 오퍼레이터의 파라미터, 웹 인터페이스 등에서 사용할 수 있습니다",
            "html": "Copy Location to Clipboard: 이 항목의 고유 식별자를 클립보드에 복사합니다. 이를 통해 오퍼레이터의 파라미터, 웹 인터페이스 등에서 사용할 수 있습니다 "
          },
          {
            "type": "paragraph",
            "text": "Delete: 선택한 리포지토리 항목 또는 디렉토리를 삭제합니다",
            "html": "Delete: 선택한 리포지토리 항목 또는 디렉토리를 삭제합니다 "
          },
          {
            "type": "paragraph",
            "text": "Refresh: 표시를 갱신합니다",
            "html": "Refresh: 표시를 갱신합니다 "
          },
          {
            "type": "paragraph",
            "text": "Open in file browser: 파일 브라우저에서 리포지토리를 표시합니다. 이 방법은 권장하지 않습니다.",
            "html": "Open in file browser: 파일 브라우저에서 리포지토리를 표시합니다. 이 방법은 권장하지 않습니다. "
          },
          {
            "type": "paragraph",
            "text": "그림 3.2: 프로젝트별로 구조화되고, 각 프로젝트 내에서 데이터, 프로세스, 결과로 분류된 리포지토리.",
            "html": "그림 3.2: 프로젝트별로 구조화되고, 각 프로젝트 내에서 데이터, 프로세스, 결과로 분류된 리포지토리. "
          },
          {
            "type": "paragraph",
            "text": "개별 분석 프로젝트를 위해 리포지토리에 새 디렉토리를 만들고 적절한 이름을 지정하는 것이 좋습니다. 프로젝트 내부를 추가로 구조화하는 것도 도움이 됩니다. 예를 들어, 프로젝트별 데이터, 데이터 변환 및 분석의 여러 단계, 또는 결과를 위한 하위 디렉토리로 구성할 수 있습니다. 이렇게 하면 리포지토리는 그림 3.2와 같은 구조를 가질 수 있습니다.",
            "html": "개별 분석 프로젝트를 위해 리포지토리에 새 디렉토리를 만들고 적절한 이름을 지정하는 것이 좋습니다. 프로젝트 내부를 추가로 구조화하는 것도 도움이 됩니다. 예를 들어, 프로젝트별 데이터, 데이터 변환 및 분석의 여러 단계, 또는 결과를 위한 하위 디렉토리로 구성할 수 있습니다. 이렇게 하면 리포지토리는 그림 3.2와 같은 구조를 가질 수 있습니다. "
          }
        ],
        "subsections": []
      },
      {
        "id": "3-3-the-first-analysis-process",
        "number": "3.3",
        "title": "첫 번째 분석 프로세스",
        "blocks": [
          {
            "type": "paragraph",
            "text": "프로세스를 생성하면 RapidMiner Studio는 자동으로 Design Perspective로 전환되며, 프로세스 설계를 시작할 수 있습니다. 이후 장에서 RapidMiner Studio에서 데이터를 로드하고 리포지토리에 저장하는 방법에 대해 자세히 설명하겠습니다. 그러나 이 절에서는 프로세스의 기본적인 실행이 더 중요하므로, 실제 데이터 분석은 잠시 뒤로 미루겠습니다.",
            "html": "프로세스를 생성하면 RapidMiner Studio는 자동으로 Design Perspective로 전환되며, 프로세스 설계를 시작할 수 있습니다. 이후 장에서 RapidMiner Studio에서 데이터를 로드하고 리포지토리에 저장하는 방법에 대해 자세히 설명하겠습니다. 그러나 이 절에서는 프로세스의 기본적인 실행이 더 중요하므로, 실제 데이터 분석은 잠시 뒤로 미루겠습니다. "
          },
          {
            "type": "paragraph",
            "text": "그림 3.3: 새 프로세스 생성 직후의 기본 Design Perspective.",
            "html": "그림 3.3: 새 프로세스 생성 직후의 기본 Design Perspective. "
          },
          {
            "type": "paragraph",
            "text": "Design Perspective의 개별 뷰 선택과 위치를 변경하지 않았다면, 화면은 그림 3.3과 대략적으로 같을 것입니다.",
            "html": "Design Perspective의 개별 뷰 선택과 위치를 변경하지 않았다면, 화면은 그림 3.3과 대략적으로 같을 것입니다. "
          },
          {
            "type": "paragraph",
            "text": "이제 작업할 수 있는 데이터를 생성하는 것부터 새 프로세스를 시작하겠습니다. 앞서 말씀드렸듯이, 이후 장에서 리포지토리의 데이터를 사용하거나 오퍼레이터를 이용하여 데이터베이스나 파일 같은 다른 데이터 소스에서 직접 데이터를 가져오는 방법을 살펴보겠습니다. 하지만 지금은 이를 제쳐두고 작은 합성 데이터 세트를 생성하겠습니다.",
            "html": "이제 작업할 수 있는 데이터를 생성하는 것부터 새 프로세스를 시작하겠습니다. 앞서 말씀드렸듯이, 이후 장에서 리포지토리의 데이터를 사용하거나 오퍼레이터를 이용하여 데이터베이스나 파일 같은 다른 데이터 소스에서 직접 데이터를 가져오는 방법을 살펴보겠습니다. 하지만 지금은 이를 제쳐두고 작은 합성 데이터 세트를 생성하겠습니다. "
          },
          {
            "type": "paragraph",
            "text": "Operators View에서 \"Utility\" 그룹을 펼친 다음 \"Data Generation\" 그룹을 펼쳐 주십시오. 각 그룹 옆의 괄호 안 숫자는 해당 그룹의 오퍼레이터 수를 나타냅니다. 인공 데이터 세트를 생성하는 데 사용할 수 있는 여러 오퍼레이터를 볼 수 있을 것입니다. 여기에는 \"Generate Sales Data\" 오퍼레이터가 포함됩니다. 이 오퍼레이터를 마우스 버튼을 누른 채로 흰색 영역으로 드래그한 다음 놓으십시오. 오퍼레이터가 삽입되며, Operators View의 자동 연결 설정에 따라 자동으로 연결됩니다. 자동으로 연결되지 않는 경우, 새 오퍼레이터의 출력 포트를 흰색 작업 영역 오른쪽에 있는 전체 프로세스의 첫 번째 결과 포트에 수동으로 연결할 수 있습니다. 또한, 이전 장에서 설명한 대로 New Operator 대화상자를 사용하여 오퍼레이터를 삽입할 수도 있습니다. 어느 방법이든 결과는 대략 그림 3.4와 같을 것입니다.",
            "html": "Operators View에서 \"Utility\" 그룹을 펼친 다음 \"Data Generation\" 그룹을 펼쳐 주십시오. 각 그룹 옆의 괄호 안 숫자는 해당 그룹의 오퍼레이터 수를 나타냅니다. 인공 데이터 세트를 생성하는 데 사용할 수 있는 여러 오퍼레이터를 볼 수 있을 것입니다. 여기에는 \"Generate Sales Data\" 오퍼레이터가 포함됩니다. 이 오퍼레이터를 마우스 버튼을 누른 채로 흰색 영역으로 드래그한 다음 놓으십시오. 오퍼레이터가 삽입되며, Operators View의 자동 연결 설정에 따라 자동으로 연결됩니다. 자동으로 연결되지 않는 경우, 새 오퍼레이터의 출력 포트를 흰색 작업 영역 오른쪽에 있는 전체 프로세스의 첫 번째 결과 포트에 수동으로 연결할 수 있습니다. 또한, 이전 장에서 설명한 대로 New Operator 대화상자를 사용하여 오퍼레이터를 삽입할 수도 있습니다. 어느 방법이든 결과는 대략 그림 3.4와 같을 것입니다. "
          },
          {
            "type": "paragraph",
            "text": "아마 눈치채셨겠지만, 이 오퍼레이터의 전체 이름인 \"Generate Sales Data\"는 너무 길어서 처음 몇 글자 이후에 잘립니다. 마우스를 이 오퍼레이터 위에 올리고 잠시 기다리면, 이름이 작은 애니메이션으로 전체 표시됩니다. 물론, 오퍼레이터의 이름을 변경하여 더 짧은 이름을 지정할 수도 있습니다.",
            "html": "아마 눈치채셨겠지만, 이 오퍼레이터의 전체 이름인 \"Generate Sales Data\"는 너무 길어서 처음 몇 글자 이후에 잘립니다. 마우스를 이 오퍼레이터 위에 올리고 잠시 기다리면, 이름이 작은 애니메이션으로 전체 표시됩니다. 물론, 오퍼레이터의 이름을 변경하여 더 짧은 이름을 지정할 수도 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "보시다시피, 오퍼레이터 왼쪽 하단의 상태 표시등이 노란색입니다. 이는 오퍼레이터에 오류가 발생하지 않았지만, 아직 성공적으로 실행되지도 않았음을 의미합니다. 따라서 지금까지는 오퍼레이터를 완전히 구성한 것뿐이며, 이것이 직접 실행되었다는 것을 의미하지는 않습니다. 상태 표시등이 녹색으로 변하면 실행이 완료되었음을 쉽게 알 수 있습니다. 이미 오퍼레이터를 구성했다는 것을 눈치채지 못하셨나요? 사실,",
            "html": "보시다시피, 오퍼레이터 왼쪽 하단의 상태 표시등이 노란색입니다. 이는 오퍼레이터에 오류가 발생하지 않았지만, 아직 성공적으로 실행되지도 않았음을 의미합니다. 따라서 지금까지는 오퍼레이터를 완전히 구성한 것뿐이며, 이것이 직접 실행되었다는 것을 의미하지는 않습니다. 상태 표시등이 녹색으로 변하면 실행이 완료되었음을 쉽게 알 수 있습니다. 이미 오퍼레이터를 구성했다는 것을 눈치채지 못하셨나요? 사실, "
          },
          {
            "type": "paragraph",
            "text": "그림 3.4: 데이터를 생성하고 결과를 Result Perspective에 표시하는, 처음이지만 매우 단순한 프로세스.",
            "html": "그림 3.4: 데이터를 생성하고 결과를 Result Perspective에 표시하는, 처음이지만 매우 단순한 프로세스. "
          },
          {
            "type": "paragraph",
            "text": "이 특정 경우에는 구성이 매우 간단했습니다. 오퍼레이터 파라미터를 설정할 필요가 전혀 없었습니다. 빨간색 상태 표시등과 Problems View의 항목이 있었다면 그러한 구성이 필요했음을 나타냈을 것입니다.",
            "html": "이 특정 경우에는 구성이 매우 간단했습니다. 오퍼레이터 파라미터를 설정할 필요가 전혀 없었습니다. 빨간색 상태 표시등과 Problems View의 항목이 있었다면 그러한 구성이 필요했음을 나타냈을 것입니다. "
          }
        ],
        "subsections": [
          {
            "id": "3-3-1-transforming-meta-data",
            "number": "3.3.1",
            "title": "메타 데이터 변환",
            "blocks": [
              {
                "type": "paragraph",
                "text": "이제 RapidMiner Studio의 가장 매력적인 기능 중 하나를 다루겠습니다. 바로 오퍼레이터나 프로세스의 출력을 사전에 계산하는 기능이며, 이는 설계 시점에서 실제 데이터를 로드하거나 프로세스를 실행하지 않고도 가능합니다. 이것은 RapidMiner Studio의 이른바 메타 데이터 변환에 의해 가능합니다.",
                "html": "이제 RapidMiner Studio의 가장 매력적인 기능 중 하나를 다루겠습니다. 바로 오퍼레이터나 프로세스의 출력을 사전에 계산하는 기능이며, 이는 설계 시점에서 실제 데이터를 로드하거나 프로세스를 실행하지 않고도 가능합니다. 이것은 RapidMiner Studio의 이른바 메타 데이터 변환에 의해 가능합니다. "
              },
              {
                "type": "paragraph",
                "text": "물론, 각 오퍼레이터는 수신한 입력 데이터가 어떻게 변환되는지를 정의합니다. 이것이 결국 오퍼레이터의 역할입니다. 그러나 RapidMiner Studio의 특별한 점은 이 변환이 실제 데이터뿐만 아니라 해당 데이터에 대한 메타 데이터에 대해서도 수행될 수 있다는 것입니다. 이 메타 데이터는 일반적으로 데이터 자체보다 훨씬 적은 양이며",
                "html": "물론, 각 오퍼레이터는 수신한 입력 데이터가 어떻게 변환되는지를 정의합니다. 이것이 결국 오퍼레이터의 역할입니다. 그러나 RapidMiner Studio의 특별한 점은 이 변환이 실제 데이터뿐만 아니라 해당 데이터에 대한 메타 데이터에 대해서도 수행될 수 있다는 것입니다. 이 메타 데이터는 일반적으로 데이터 자체보다 훨씬 적은 양이며 "
              },
              {
                "type": "paragraph",
                "text": "특정 데이터 세트가 어떤 특성을 가지고 있는지 훌륭하게 파악할 수 있게 해줍니다. RapidMiner Studio의 메타 데이터는 본질적으로 이전에 논의한 개념 설명과 동일합니다. 여기에는 예제 세트의 속성 이름, 값 유형, 속성의 역할, 그리고 일부 기본 통계까지 포함됩니다.",
                "html": "특정 데이터 세트가 어떤 특성을 가지고 있는지 훌륭하게 파악할 수 있게 해줍니다. RapidMiner Studio의 메타 데이터는 본질적으로 이전에 논의한 개념 설명과 동일합니다. 여기에는 예제 세트의 속성 이름, 값 유형, 속성의 역할, 그리고 일부 기본 통계까지 포함됩니다. "
              },
              {
                "type": "paragraph",
                "text": "이론은 충분하고, 실제로 RapidMiner Studio에서 메타 데이터는 어떻게 표시될까요? RapidMiner Studio에서 메타 데이터는 포트에서 제공됩니다. 방금 삽입한 오퍼레이터의 출력 포트 위에 커서를 올려보면 그림 3.5에서 무슨 일이 일어나는지 확인할 수 있습니다.",
                "html": "이론은 충분하고, 실제로 RapidMiner Studio에서 메타 데이터는 어떻게 표시될까요? RapidMiner Studio에서 메타 데이터는 포트에서 제공됩니다. 방금 삽입한 오퍼레이터의 출력 포트 위에 커서를 올려보면 그림 3.5에서 무슨 일이 일어나는지 확인할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "포트의 예상 출력을 설명하는 툴팁이 나타납니다. 먼저 오퍼레이터 이름과 포트 이름, 그다음 메타 데이터의 종류가 표시됩니다. 이 경우 예제 세트의 메타 데이터를 다루고 있습니다. 예제 수(100)와 속성 수(8)도 확인할 수 있습니다. 그런 다음 실행 중에 객체가 프로세스를 통해 이동한 경로에 대한 설명이 나옵니다. 이 경우 경로에는 생성 오퍼레이터의 포트라는 하나의 정거장만 있습니다. 그러나 메타 데이터에서 가장 중요한 부분(적어도 예제 세트의 경우)은 개별 속성의 메타 데이터를 설명하는 테이블입니다. 각 열은 다음과 같습니다:",
                "html": "포트의 예상 출력을 설명하는 툴팁이 나타납니다. 먼저 오퍼레이터 이름과 포트 이름, 그다음 메타 데이터의 종류가 표시됩니다. 이 경우 예제 세트의 메타 데이터를 다루고 있습니다. 예제 수(100)와 속성 수(8)도 확인할 수 있습니다. 그런 다음 실행 중에 객체가 프로세스를 통해 이동한 경로에 대한 설명이 나옵니다. 이 경우 경로에는 생성 오퍼레이터의 포트라는 하나의 정거장만 있습니다. 그러나 메타 데이터에서 가장 중요한 부분(적어도 예제 세트의 경우)은 개별 속성의 메타 데이터를 설명하는 테이블입니다. 각 열은 다음과 같습니다: "
              },
              {
                "type": "paragraph",
                "text": "Role: 속성의 역할입니다. 아무것도 표시되지 않으면 일반 속성입니다",
                "html": "Role: 속성의 역할입니다. 아무것도 표시되지 않으면 일반 속성입니다 "
              },
              {
                "type": "paragraph",
                "text": "Name: 속성의 이름입니다",
                "html": "Name: 속성의 이름입니다 "
              },
              {
                "type": "paragraph",
                "text": "Type: 속성의 값 유형입니다",
                "html": "Type: 속성의 값 유형입니다 "
              },
              {
                "type": "paragraph",
                "text": "Range: 속성의 값 범위로, 수치 속성의 경우 최소값과 최대값이며, 명목 속성의 경우 가능한 값의 일부가 표시됩니다",
                "html": "Range: 속성의 값 범위로, 수치 속성의 경우 최소값과 최대값이며, 명목 속성의 경우 가능한 값의 일부가 표시됩니다 "
              },
              {
                "type": "paragraph",
                "text": "Missings: 이 속성의 값을 알 수 없는 예제의 수입니다 Comment: 속성에 따른 코멘트입니다",
                "html": "Missings: 이 속성의 값을 알 수 없는 예제의 수입니다 Comment: 속성에 따른 코멘트입니다 "
              },
              {
                "type": "paragraph",
                "text": "팁: RapidMiner Studio의 여러 곳에 이처럼 복잡한 툴팁이 있으며, 예를 들어 Operators View에 표시되는 오퍼레이터 설명에도 있습니다. 이 툴팁은",
                "html": "팁: RapidMiner Studio의 여러 곳에 이처럼 복잡한 툴팁이 있으며, 예를 들어 Operators View에 표시되는 오퍼레이터 설명에도 있습니다. 이 툴팁은 "
              },
              {
                "type": "paragraph",
                "text": "그림 3.5: \"Generate Sales Data\" 오퍼레이터의 출력 포트에 대한 메타 데이터.",
                "html": "그림 3.5: \"Generate Sales Data\" 오퍼레이터의 출력 포트에 대한 메타 데이터. "
              },
              {
                "type": "paragraph",
                "text": "Operators View에 툴팁으로 표시됩니다. F3 키를 먼저 누르면 툴팁을 천천히 읽을 수 있으며 크기도 조절할 수 있습니다.",
                "html": "Operators View에 툴팁으로 표시됩니다. F3 키를 먼저 누르면 툴팁을 천천히 읽을 수 있으며 크기도 조절할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "메타 데이터는 종종 추정만 나타낼 수 있으며, 정확한 표시가 항상 가능하지는 않다는 점에 유의하십시오. 이는 메타 데이터의 일부가 알려지지 않았거나 부정확하게만 표시될 수 있기 때문입니다. 예를 들어",
                "html": "메타 데이터는 종종 추정만 나타낼 수 있으며, 정확한 표시가 항상 가능하지는 않다는 점에 유의하십시오. 이는 메타 데이터의 일부가 알려지지 않았거나 부정확하게만 표시될 수 있기 때문입니다. 예를 들어 "
              },
              {
                "type": "paragraph",
                "text": "예제 수에 대해 \"<100 Examples\"와 같이 표시될 수 있습니다. 그럼에도 불구하고, 메타 데이터는 향후 설계 결정과 문제의 자동 인식, 그리고 그 해결 방안 즉 빠른 수정(quick fixes)을 위한 귀중한 도움이 됩니다.",
                "html": "예제 수에 대해 \"<100 Examples\"와 같이 표시될 수 있습니다. 그럼에도 불구하고, 메타 데이터는 향후 설계 결정과 문제의 자동 인식, 그리고 그 해결 방안 즉 빠른 수정(quick fixes)을 위한 귀중한 도움이 됩니다. "
              },
              {
                "type": "paragraph",
                "text": "예제로 돌아가겠습니다. 경험이 있는 분석가라면 이 데이터가 이른바 트랜잭션 데이터이며, 각 트랜잭션이 하나의 구매를 나타낸다는 것을 바로 인식할 것입니다. 예제 세트에 다음과 같은 속성을 부여했습니다:",
                "html": "예제로 돌아가겠습니다. 경험이 있는 분석가라면 이 데이터가 이른바 트랜잭션 데이터이며, 각 트랜잭션이 하나의 구매를 나타낸다는 것을 바로 인식할 것입니다. 예제 세트에 다음과 같은 속성을 부여했습니다: "
              },
              {
                "type": "paragraph",
                "text": "• transaction id: 각 트랜잭션의 고유 ID를 나타냅니다, • store id: 트랜잭션이 발생한 매장을 나타냅니다, • customer id: 트랜잭션이 이루어진 고객을 나타냅니다, • product id: 구매한 제품의 ID를 나타냅니다,",
                "html": "• transaction id: 각 트랜잭션의 고유 ID를 나타냅니다, • store id: 트랜잭션이 발생한 매장을 나타냅니다, • customer id: 트랜잭션이 이루어진 고객을 나타냅니다, • product id: 구매한 제품의 ID를 나타냅니다, "
              },
              {
                "type": "paragraph",
                "text": "• product category: 구매한 제품의 카테고리를 나타냅니다, • date: 트랜잭션 날짜를 나타냅니다,",
                "html": "• product category: 구매한 제품의 카테고리를 나타냅니다, • date: 트랜잭션 날짜를 나타냅니다, "
              },
              {
                "type": "paragraph",
                "text": "• amount: 구매한 물건의 수량을 나타냅니다,",
                "html": "• amount: 구매한 물건의 수량을 나타냅니다, "
              },
              {
                "type": "paragraph",
                "text": "• single price: 개별 물건의 가격을 나타냅니다.",
                "html": "• single price: 개별 물건의 가격을 나타냅니다. "
              },
              {
                "type": "paragraph",
                "text": "마지막 두 속성을 먼저 살펴보면, 트랜잭션 내에서 물건의 수량과 개별 가격은 제공되지만 이에 대한 총 매출은 제공되지 않음을 알 수 있습니다. 따라서 다음으로 \"total price\"라는 이름의 새 속성을 생성하고, 그 값이 amount와 single price의 곱에 해당하도록 하겠습니다. 이를 위해 \"Data Transformation\" – \"Attribute Set Reduction and Transformation\" – \"Generation\" 그룹에 있는 \"Generate Attributes\"라는 오퍼레이터를 사용합니다. 이 오퍼레이터를 첫 번째 오퍼레이터 뒤로 드래그하고, 데이터 생성기의 출력 포트를 새 오퍼레이터의 입력 포트에 연결한 다음, 후자의 출력 포트를 전체 프로세스의 결과 출력에 연결합니다. 화면은 대략 그림 3.6과 같을 것입니다.",
                "html": "마지막 두 속성을 먼저 살펴보면, 트랜잭션 내에서 물건의 수량과 개별 가격은 제공되지만 이에 대한 총 매출은 제공되지 않음을 알 수 있습니다. 따라서 다음으로 \"total <u>p</u>rice\"라는 이름의 새 속성을 생성하고, 그 값이 amount와 single price의 곱에 해당하도록 하겠습니다. 이를 위해 \"Data Transformation\" – \"Attribute Set Reduction and Transformation\" – \"Generation\" 그룹에 있는 \"Generate Attributes\"라는 오퍼레이터를 사용합니다. 이 오퍼레이터를 첫 번째 오퍼레이터 뒤로 드래그하고, 데이터 생성기의 출력 포트를 새 오퍼레이터의 입력 포트에 연결한 다음, 후자의 출력 포트를 전체 프로세스의 결과 출력에 연결합니다. 화면은 대략 그림 3.6과 같을 것입니다. "
              },
              {
                "type": "paragraph",
                "text": "팁: 오퍼레이터를 Process View로 드래그한 후 포트를 다시 연결하는 대신, 61",
                "html": "팁: 오퍼레이터를 Process View로 드래그한 후 포트를 다시 연결하는 대신, 61"
              },
              {
                "type": "paragraph",
                "text": "그림 3.6: 먼저 데이터가 생성된 다음 새 속성이 만들어집니다.",
                "html": "그림 3.6: 먼저 데이터가 생성된 다음 새 속성이 만들어집니다. "
              },
              {
                "type": "paragraph",
                "text": "기존 연결 위에 오퍼레이터를 드래그할 수도 있습니다. 커서 위치를 정확히 연결 위에 놓으면 연결이 강조 표시되며, 새 오퍼레이터가 해당 연결에 직접 삽입됩니다.",
                "html": "기존 연결 위에 오퍼레이터를 드래그할 수도 있습니다. 커서 위치를 정확히 연결 위에 놓으면 연결이 강조 표시되며, 새 오퍼레이터가 해당 연결에 직접 삽입됩니다. "
              },
              {
                "type": "paragraph",
                "text": "이 프로세스는 지금 실행해도 작동하지만(노란색 상태 표시등과 비어 있는 Problems View로 알 수 있듯이), 추가 구성 없이는 두 번째 오퍼레이터가 아무것도 계산하지 않으며 최종 결과는 첫 번째 오퍼레이터의 결과와 동일할 것입니다. 따라서 새로운 \"Generate Attributes\" 오퍼레이터를 선택합니다. 이렇게 하면 파라미터 뷰의 표시가 변경되어 이 오퍼레이터의 파라미터가 표시됩니다. 핵심 파라미터의 이름은 \"function descriptions\"이며, 그림 3.7에서 볼 수 있듯이 관련 버튼을 한 번 클릭하여 구성합니다.",
                "html": "이 프로세스는 지금 실행해도 작동하지만(노란색 상태 표시등과 비어 있는 Problems View로 알 수 있듯이), 추가 구성 없이는 두 번째 오퍼레이터가 아무것도 계산하지 않으며 최종 결과는 첫 번째 오퍼레이터의 결과와 동일할 것입니다. 따라서 새로운 \"Generate Attributes\" 오퍼레이터를 선택합니다. 이렇게 하면 파라미터 뷰의 표시가 변경되어 이 오퍼레이터의 파라미터가 표시됩니다. 핵심 파라미터의 이름은 \"function descriptions\"이며, 그림 3.7에서 볼 수 있듯이 관련 버튼을 한 번 클릭하여 구성합니다. "
              },
              {
                "type": "paragraph",
                "text": "\"Edit List (0)\"라는 이름의 버튼을 누르면, 그림 3.8에서처럼 원하는 계산을 입력할 수 있는 대화상자가 열립니다.",
                "html": "\"Edit List (0)\"라는 이름의 버튼을 누르면, 그림 3.8에서처럼 원하는 계산을 입력할 수 있는 대화상자가 열립니다. "
              },
              {
                "type": "paragraph",
                "text": "이러한 개별 파라미터 목록에서 \"Add Entry\"와 \"Remove Entry\" 두 액션으로 항목을 추가하고 선택한 항목을 삭제할 수 있습니다.",
                "html": "이러한 개별 파라미터 목록에서 \"Add Entry\"와 \"Remove Entry\" 두 액션으로 항목을 추가하고 선택한 항목을 삭제할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 3.7: \"Generate Attributes\" 오퍼레이터의 파라미터.",
                "html": "그림 3.7: \"Generate Attributes\" 오퍼레이터의 파라미터. "
              },
              {
                "type": "paragraph",
                "text": "그림 3.8: 새 속성 \"total price\"를 \"amount\"와 \"single price\"의 곱으로 계산.",
                "html": "그림 3.8: 새 속성 \"total <u>p</u>rice\"를 \"amount\"와 \"single <u>p</u>rice\"의 곱으로 계산. "
              },
              {
                "type": "paragraph",
                "text": "원하는 파라미터의 이름이 테이블 헤더에 있습니다. 행을 추가하고, 왼쪽에 새 속성의 이름을 입력한 다음, 오른쪽에 이 새 속성을 계산하는 함수를 입력합니다. 이 경우에는 단순히 다른 두 속성의 곱입니다. \"Apply\"를 눌러 입력을 확인하면 대화상자가 닫힙니다. \"Edit List\"라고 표시된 버튼에 괄호 안에 \"1\"이 표시되어야 하며, 이를 통해 파라미터 목록에 몇 개의 항목이 있는지, 즉 이 경우 몇 개의 새 속성이 생성되는지 확인할 수 있습니다. 이제",
                "html": "원하는 파라미터의 이름이 테이블 헤더에 있습니다. 행을 추가하고, 왼쪽에 새 속성의 이름을 입력한 다음, 오른쪽에 이 새 속성을 계산하는 함수를 입력합니다. 이 경우에는 단순히 다른 두 속성의 곱입니다. \"Apply\"를 눌러 입력을 확인하면 대화상자가 닫힙니다. \"Edit List\"라고 표시된 버튼에 괄호 안에 \"1\"이 표시되어야 하며, 이를 통해 파라미터 목록에 몇 개의 항목이 있는지, 즉 이 경우 몇 개의 새 속성이 생성되는지 확인할 수 있습니다. 이제 "
              },
              {
                "type": "paragraph",
                "text": "\"Generate Attributes\" 오퍼레이터를 추가한 것이 메타 데이터에 어떤 영향을 미치는지 관찰할 수 있습니다. RapidMiner는 이미 백그라운드에서 메타 데이터를 변환했으며, 오퍼레이터의 출력 포트 위의 툴팁을 통해 새로운 메타 데이터를 확인할 수 있습니다(그림 3.9).",
                "html": "\"Generate Attributes\" 오퍼레이터를 추가한 것이 메타 데이터에 어떤 영향을 미치는지 관찰할 수 있습니다. RapidMiner는 이미 백그라운드에서 메타 데이터를 변환했으며, 오퍼레이터의 출력 포트 위의 툴팁을 통해 새로운 메타 데이터를 확인할 수 있습니다(그림 3.9). "
              },
              {
                "type": "paragraph",
                "text": "그림 3.9: 메타 데이터에는 객체의 전체 경로가 포함되어 있으며, 새로 추가된 속성 \"total price\"를 제외하고는 변경되지 않았습니다.",
                "html": "그림 3.9: 메타 데이터에는 객체의 전체 경로가 포함되어 있으며, 새로 추가된 속성 \"total <u>p</u>rice\"를 제외하고는 변경되지 않았습니다. "
              },
              {
                "type": "paragraph",
                "text": "\"Generated by\" 줄에서 현재 객체가 마지막으로 유래한 곳이 \"Generate Attributes\" 오퍼레이터이며, 그 이전에는 \"Generate Sales Data\" 오퍼레이터였음을 쉽게 알 수 있습니다. 또한, 거의 변경된 것이 없습니다 - 예제 수와 8개의 원래 속성이 모두 그대로 유지되었습니다. 그러나 아홉 번째 속성이 추가되었습니다: 새로 정의한 속성인",
                "html": "\"Generated by\" 줄에서 현재 객체가 마지막으로 유래한 곳이 \"Generate Attributes\" 오퍼레이터이며, 그 이전에는 \"Generate Sales Data\" 오퍼레이터였음을 쉽게 알 수 있습니다. 또한, 거의 변경된 것이 없습니다 - 예제 수와 8개의 원래 속성이 모두 그대로 유지되었습니다. 그러나 아홉 번째 속성이 추가되었습니다: 새로 정의한 속성인 "
              },
              {
                "type": "paragraph",
                "text": "\"total price\"도 이제 테이블에서 찾을 수 있습니다.",
                "html": "\"total <u>p</u>rice\"도 이제 테이블에서 찾을 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "그리고 프로세스는 아직 실행되지 않았습니다. 이는 여전히 노란색인 상태 표시등만 봐도 알 수 있습니다. \"그래서? 프로세스 실행 없이 결과를 미리 알 수 있다는 건데, 그게 무슨 소용이지?\"라고 물을 수 있습니다. 사실, 매우 유용합니다. 이제 특정 오퍼레이터나 (하위)프로세스가 입력 데이터로 무엇을 하는지 한눈에 볼 수 있습니다. 메타 데이터는 전체 데이터 세트보다 상당히 작기 때문에, 이 검사를 전체 데이터에 대해 수행하는 것보다 훨씬 빠르게 할 수 있습니다. 이렇게 하면 몇 시간 동안 실행된 분석 프로세스가 오류로 중단된 후에야 알게 되는 것이 아니라, 가장 짧은 시간 내에 추가 데이터 변환이 필요한 문제가 있는지 피드백을 받을 수 있습니다. 마지막으로, RapidMiner Studio는 메타 데이터의 정보를 계속 처리하여 프로세스 설계를 지속적으로 지원할 수 있습니다. 예를 들어, 속성을 필터링하는 동안 그래픽 사용자 인터페이스에 아직 사용 가능한(그리고 새로 생성된) 속성만 표시됩니다.",
                "html": "그리고 프로세스는 아직 실행되지 않았습니다. 이는 여전히 노란색인 상태 표시등만 봐도 알 수 있습니다. \"그래서? 프로세스 실행 없이 결과를 미리 알 수 있다는 건데, 그게 무슨 소용이지?\"라고 물을 수 있습니다. 사실, 매우 유용합니다. 이제 특정 오퍼레이터나 (하위)프로세스가 입력 데이터로 무엇을 하는지 한눈에 볼 수 있습니다. 메타 데이터는 전체 데이터 세트보다 상당히 작기 때문에, 이 검사를 전체 데이터에 대해 수행하는 것보다 훨씬 빠르게 할 수 있습니다. 이렇게 하면 몇 시간 동안 실행된 분석 프로세스가 오류로 중단된 후에야 알게 되는 것이 아니라, 가장 짧은 시간 내에 추가 데이터 변환이 필요한 문제가 있는지 피드백을 받을 수 있습니다. 마지막으로, RapidMiner Studio는 메타 데이터의 정보를 계속 처리하여 프로세스 설계를 지속적으로 지원할 수 있습니다. 예를 들어, 속성을 필터링하는 동안 그래픽 사용자 인터페이스에 아직 사용 가능한(그리고 새로 생성된) 속성만 표시됩니다. "
              },
              {
                "type": "paragraph",
                "text": "이제 다음을 시도해 보십시오: \"Data Transformation\" – \"Attribute Set Reduction and Transformation\" – \"Selection\" 그룹을 열고, \"Select Attributes\"라는 오퍼레이터를 프로세스에 드래그합니다 - 가능하면 마지막 오퍼레이터 뒤의 연결 위에 직접 놓으십시오. 오퍼레이터를 놓기 전에 연결이 강조 표시되어야 하며, 그러면 즉시 올바르게 다시 연결됩니다. 이제 그림 3.10과 같은 프로세스가 정의되어 있어야 합니다.",
                "html": "이제 다음을 시도해 보십시오: \"Data Transformation\" – \"Attribute Set Reduction and Transformation\" – \"Selection\" 그룹을 열고, \"Select Attributes\"라는 오퍼레이터를 프로세스에 드래그합니다 - 가능하면 마지막 오퍼레이터 뒤의 연결 위에 직접 놓으십시오. 오퍼레이터를 놓기 전에 연결이 강조 표시되어야 하며, 그러면 즉시 올바르게 다시 연결됩니다. 이제 그림 3.10과 같은 프로세스가 정의되어 있어야 합니다. "
              },
              {
                "type": "paragraph",
                "text": "새 오퍼레이터를 선택하고 \"attribute filter type\" 파라미터에서 \"subset\" 옵션을 선택합니다. \"attributes\"라는 새로운 파라미터가 나타났음에 주목하십시오. 이 파라미터는 굵은 글씨로 표시되어 있어, 프로세스를 실행하기 전에 반드시 정의해야 합니다. 오퍼레이터의 빨간색 상태 표시등과 Problems View의 항목에서도 이를 확인할 수 있습니다. Problems View에서 더블 클릭하여 빠른 수정을 선택하거나, 직접 \"attributes\" 파라미터를 구성할 수 있습니다: 이번에는 \"Select Attributes...\"라고 표시된 버튼을 클릭합니다. 파라미터는 그림 3.11과 같아야 합니다.",
                "html": "새 오퍼레이터를 선택하고 \"attribute filter type\" 파라미터에서 \"subset\" 옵션을 선택합니다. \"attributes\"라는 새로운 파라미터가 나타났음에 주목하십시오. 이 파라미터는 굵은 글씨로 표시되어 있어, 프로세스를 실행하기 전에 반드시 정의해야 합니다. 오퍼레이터의 빨간색 상태 표시등과 Problems View의 항목에서도 이를 확인할 수 있습니다. Problems View에서 더블 클릭하여 빠른 수정을 선택하거나, 직접 \"attributes\" 파라미터를 구성할 수 있습니다: 이번에는 \"Select Attributes...\"라고 표시된 버튼을 클릭합니다. 파라미터는 그림 3.11과 같아야 합니다. "
              },
              {
                "type": "paragraph",
                "text": "이제 \"Select Attributes...\" 버튼을 누르고 대화상자의 목록에서 \"product category\", \"store id\", \"total price\" 속성을 선택합니다(그림",
                "html": "이제 \"Select Attributes...\" 버튼을 누르고 대화상자의 목록에서 \"product <u>c</u>ategory\", \"store <u>i</u>d\", \"total <u>p</u>rice\" 속성을 선택합니다(그림 "
              },
              {
                "type": "paragraph",
                "text": "그림 3.10: 데이터 생성, 새 속성 생성, 속성 부분집합 선택.",
                "html": "그림 3.10: 데이터 생성, 새 속성 생성, 속성 부분집합 선택. "
              },
              {
                "type": "paragraph",
                "text": "그림 3.11: \"attributes\" 파라미터는 필터 유형으로 \"subset\"이 선택된 경우에만 나타납니다.",
                "html": "그림 3.11: \"attributes\" 파라미터는 필터 유형으로 \"subset\"이 선택된 경우에만 나타납니다. "
              },
              {
                "type": "paragraph",
                "text": "3.12). 더블 클릭하거나 가운데에 있는 오른쪽 화살표 버튼을 눌러 선택할 수 있습니다.",
                "html": "3.12). 더블 클릭하거나 가운데에 있는 오른쪽 화살표 버튼을 눌러 선택할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 3.12: \"Select Attributes\" 오퍼레이터를 사용하여 개별 속성 또는 부분집합을 선택하거나 삭제할 수 있습니다.",
                "html": "그림 3.12: \"Select Attributes\" 오퍼레이터를 사용하여 개별 속성 또는 부분집합을 선택하거나 삭제할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "눈치채셨나요? 지금까지 메타 데이터 변환 내에서만 계산되었던 새 속성 \"total price\"가 프로세스를 실행하지 않았는데도 이미 여기에서 선택할 수 있었습니다. 출력 포트에서 메타 데이터를 다시 확인하면, 선택한 세 개의 속성과 특별한 역할(ID 역할)을 가진 transaction ID만 남아 있는 것을 볼 수 있습니다. transaction ID는 특별한 역할을 가지고 있으므로 선택에 영향을 받지 않았습니다. 이 ID도 제거하려면 \"Select Attributes\" 오퍼레이터의 파라미터에서 \"include special attributes\" 옵션을 선택하고 메타 데이터를 다시 확인하십시오: 이제 원하는 세 개의 속성만 남아 있습니다. 이러한 파라미터와 다른 모든 파라미터의 효과는 Help View의 파라미터 설명과 오퍼레이터 레퍼런스에서 확인할 수 있습니다.",
                "html": "눈치채셨나요? 지금까지 메타 데이터 변환 내에서만 계산되었던 새 속성 \"total <u>p</u>rice\"가 프로세스를 실행하지 않았는데도 이미 여기에서 선택할 수 있었습니다. 출력 포트에서 메타 데이터를 다시 확인하면, 선택한 세 개의 속성과 특별한 역할(ID 역할)을 가진 transaction ID만 남아 있는 것을 볼 수 있습니다. transaction ID는 특별한 역할을 가지고 있으므로 선택에 영향을 받지 않았습니다. 이 ID도 제거하려면 \"Select Attributes\" 오퍼레이터의 파라미터에서 \"include special attributes\" 옵션을 선택하고 메타 데이터를 다시 확인하십시오: 이제 원하는 세 개의 속성만 남아 있습니다. 이러한 파라미터와 다른 모든 파라미터의 효과는 Help View의 파라미터 설명과 오퍼레이터 레퍼런스에서 확인할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "팁: RapidMiner Studio의 기본 규칙으로, \"Data 67",
                "html": "팁: RapidMiner Studio의 기본 규칙으로, \"Data 67"
              },
              {
                "type": "paragraph",
                "text": "Transformation\" 그룹의 오퍼레이터는 일반적으로 일반 속성, 즉 특별한 역할이 없는 속성에 대해서만 실행됩니다. 그러나 오퍼레이터들은 \"include special attributes\"라는 옵션을 제공하며, 이를 통해 특별한 역할을 가진 속성에도 변경 사항을 적용할 수 있습니다.",
                "html": "Transformation\" 그룹의 오퍼레이터는 일반적으로 일반 속성, 즉 특별한 역할이 없는 속성에 대해서만 실행됩니다. 그러나 오퍼레이터들은 \"include special attributes\"라는 옵션을 제공하며, 이를 통해 특별한 역할을 가진 속성에도 변경 사항을 적용할 수 있습니다. "
              }
            ],
            "subsections": []
          }
        ]
      },
      {
        "id": "3-4-executing-processes",
        "number": "3.4",
        "title": "프로세스 실행",
        "blocks": [
          {
            "type": "paragraph",
            "text": "이제 준비가 되었으니, 방금 생성한 프로세스를 처음으로 실행하겠습니다. 모든 오퍼레이터의 상태 표시등이 노란색이어야 하며 Problems View에 항목이 없어야 합니다. 이러한 경우 세 개의 오퍼레이터(데이터 생성, 각 트랜잭션의 총 매출 계산, 속성 필터링)로 구성된 프로세스를 문제없이 실행할 수 있습니다.",
            "html": "이제 준비가 되었으니, 방금 생성한 프로세스를 처음으로 실행하겠습니다. 모든 오퍼레이터의 상태 표시등이 노란색이어야 하며 Problems View에 항목이 없어야 합니다. 이러한 경우 세 개의 오퍼레이터(데이터 생성, 각 트랜잭션의 총 매출 계산, 속성 필터링)로 구성된 프로세스를 문제없이 실행할 수 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "프로세스를 시작하는 방법은 다음과 같습니다:",
            "html": "프로세스를 시작하는 방법은 다음과 같습니다: "
          },
          {
            "type": "paragraph",
            "text": "1. RapidMiner 툴바의 큰 재생 버튼을 누릅니다, 2. \"Process\" – \"Run\" 메뉴 항목을 선택합니다,",
            "html": "1. RapidMiner 툴바의 큰 재생 버튼을 누릅니다, 2. \"Process\" – \"Run\" 메뉴 항목을 선택합니다, "
          },
          {
            "type": "paragraph",
            "text": "3. F11을 누릅니다.",
            "html": "3. F11을 누릅니다. "
          },
          {
            "type": "paragraph",
            "text": "그림 3.13: 재생 버튼으로 프로세스를 시작하고, 일시 정지 버튼으로 프로세스를 중간에 멈출 수 있으며, 중지 버튼으로 프로세스를 완전히 중단할 수 있습니다.",
            "html": "그림 3.13: 재생 버튼으로 프로세스를 시작하고, 일시 정지 버튼으로 프로세스를 중간에 멈출 수 있으며, 중지 버튼으로 프로세스를 완전히 중단할 수 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "프로세스가 실행되는 동안, 현재 실행 중인 오퍼레이터의 상태 표시등이 작은 녹색 재생 아이콘으로 변합니다. 이를 통해 프로세스가 현재 어디까지 진행되었는지 확인할 수 있습니다. 오퍼레이터가 성공적으로 실행된 후에는 상태 표시등이 녹색으로 변경되어 유지됩니다 - 예를 들어 해당 오퍼레이터의 파라미터를 변경하기 전까지는 말입니다: 그러면 상태 표시등이 다시 노란색이 됩니다. 이후의 모든 오퍼레이터에도 동일하게 적용됩니다. 이를 통해 변경 사항이 어떤 오퍼레이터에 영향을 미칠 수 있는지 매우 빠르게 확인할 수 있습니다.",
            "html": "프로세스가 실행되는 동안, 현재 실행 중인 오퍼레이터의 상태 표시등이 작은 녹색 재생 아이콘으로 변합니다. 이를 통해 프로세스가 현재 어디까지 진행되었는지 확인할 수 있습니다. 오퍼레이터가 성공적으로 실행된 후에는 상태 표시등이 녹색으로 변경되어 유지됩니다 - 예를 들어 해당 오퍼레이터의 파라미터를 변경하기 전까지는 말입니다: 그러면 상태 표시등이 다시 노란색이 됩니다. 이후의 모든 오퍼레이터에도 동일하게 적용됩니다. 이를 통해 변경 사항이 어떤 오퍼레이터에 영향을 미칠 수 있는지 매우 빠르게 확인할 수 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "위에서 정의한 프로세스는 실행 시간이 짧아서, 실행 중인 프로세스를 일시 정지할 기회가 거의 없을 것입니다. 그러나 원칙적으로 일시 정지 기호를 사용하여 실행 중인 프로세스를 잠시 멈출 수 있습니다. 예를 들어 중간 결과를 확인하기 위해서입니다. 현재 실행 중인 오퍼레이터가 완료되면 프로세스가 중지됩니다. 아직 실행 중이지만 현재 일시 정지된 프로세스는 재생 아이콘의 색상이 파란색에서 녹색으로 변하는 것으로 알 수 있습니다. 재생 버튼을 다시 누르면 프로세스 실행이 계속됩니다.",
            "html": "위에서 정의한 프로세스는 실행 시간이 짧아서, 실행 중인 프로세스를 일시 정지할 기회가 거의 없을 것입니다. 그러나 원칙적으로 일시 정지 기호를 사용하여 실행 중인 프로세스를 잠시 멈출 수 있습니다. 예를 들어 중간 결과를 확인하기 위해서입니다. 현재 실행 중인 오퍼레이터가 완료되면 프로세스가 중지됩니다. 아직 실행 중이지만 현재 일시 정지된 프로세스는 재생 아이콘의 색상이 파란색에서 녹색으로 변하는 것으로 알 수 있습니다. 재생 버튼을 다시 누르면 프로세스 실행이 계속됩니다. "
          },
          {
            "type": "paragraph",
            "text": "프로세스를 단순히 일시 정지하는 것이 아니라 완전히 중단하려면, 중지 버튼을 누르면 됩니다. 일시 정지와 마찬가지로 현재 실행 중인 오퍼레이터가 완료된 후 프로세스가 완전히 중단됩니다. 프로세스를 중단한 후에는 백그라운드에서 현재 오퍼레이터의 실행이 완료되는 중에도 즉시 Design Perspective로 전환하여 프로세스를 변경할 수 있습니다. 첫 번째 프로세스가 완료될 때까지 기다릴 필요 없이 추가 프로세스를 시작할 수도 있습니다.",
            "html": "프로세스를 단순히 일시 정지하는 것이 아니라 완전히 중단하려면, 중지 버튼을 누르면 됩니다. 일시 정지와 마찬가지로 현재 실행 중인 오퍼레이터가 완료된 후 프로세스가 완전히 중단됩니다. 프로세스를 중단한 후에는 백그라운드에서 현재 오퍼레이터의 실행이 완료되는 중에도 즉시 Design Perspective로 전환하여 프로세스를 변경할 수 있습니다. 첫 번째 프로세스가 완료될 때까지 기다릴 필요 없이 추가 프로세스를 시작할 수도 있습니다. "
          },
          {
            "type": "paragraph",
            "text": "참고: 위에서 설명했듯이, 중단 시 실행 중인 오퍼레이터는 항상 완료됩니다. 이는 오퍼레이터의 안전한 실행을 보장하기 위해 필요합니다. 그러나 오퍼레이터를 완료하는 데 개별적인 경우에 훨씬 더 많은 시간이 필요할 수 있으며 저장 공간과 같은 다른 리소스도 필요할 수 있습니다. 따라서 매우 복잡한 오퍼레이터를 중단할 때 이 작업에 몇 시간이 걸리고 추가 리소스가 필요한 것을 보게 된다면, 유일한 방법은 애플리케이션을 다시 시작하는 것입니다.",
            "html": "참고: 위에서 설명했듯이, 중단 시 실행 중인 오퍼레이터는 항상 완료됩니다. 이는 오퍼레이터의 안전한 실행을 보장하기 위해 필요합니다. 그러나 오퍼레이터를 완료하는 데 개별적인 경우에 훨씬 더 많은 시간이 필요할 수 있으며 저장 공간과 같은 다른 리소스도 필요할 수 있습니다. 따라서 매우 복잡한 오퍼레이터를 중단할 때 이 작업에 몇 시간이 걸리고 추가 리소스가 필요한 것을 보게 된다면, 유일한 방법은 애플리케이션을 다시 시작하는 것입니다. "
          }
        ],
        "subsections": [
          {
            "id": "3-4-1-looking-at-results",
            "number": "3.4.1",
            "title": "결과 확인",
            "blocks": [
              {
                "type": "paragraph",
                "text": "프로세스가 종료된 후, RapidMiner Studio는 Result Perspective로 전환되어야 합니다(그림 3.14). 전환되지 않았다면, 마지막 오퍼레이터의 출력 포트를 흰색 작업 영역 오른쪽에 있는 프로세스의 결과 포트 중 하나에 연결하지 않았을 가능성이 있습니다. 이를 확인하고 Problems View의 메모를 참고하여 다른 가능한 오류도 확인하십시오.",
                "html": "프로세스가 종료된 후, RapidMiner Studio는 Result Perspective로 전환되어야 합니다(그림 3.14). 전환되지 않았다면, 마지막 오퍼레이터의 출력 포트를 흰색 작업 영역 오른쪽에 있는 프로세스의 결과 포트 중 하나에 연결하지 않았을 가능성이 있습니다. 이를 확인하고 Problems View의 메모를 참고하여 다른 가능한 오류도 확인하십시오. "
              },
              {
                "type": "paragraph",
                "text": "결과를 살펴보는 데 시간을 할애하십시오. 위의 프로세스는 아직 모델링을 수행하지 않고 데이터만 변환했으므로, 결과는 예제 세트만으로 구성됩니다. 이 데이터 세트의 메타 데이터를 살펴보고, 테이블과 Charts 또는 Advanced Charts의 일부 시각화를 시도해 볼 수 있습니다. 다음",
                "html": "결과를 살펴보는 데 시간을 할애하십시오. 위의 프로세스는 아직 모델링을 수행하지 않고 데이터만 변환했으므로, 결과는 예제 세트만으로 구성됩니다. 이 데이터 세트의 메타 데이터를 살펴보고, 테이블과 Charts 또는 Advanced Charts의 일부 시각화를 시도해 볼 수 있습니다. 다음 "
              },
              {
                "type": "paragraph",
                "text": "그림 3.14: 프로세스가 성공적으로 실행된 후 Result Perspective에서 결과를 확인할 수 있습니다.",
                "html": "그림 3.14: 프로세스가 성공적으로 실행된 후 Result Perspective에서 결과를 확인할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "장에서 Result Perspective의 가능성에 대해 자세히 설명하겠습니다. Design Perspective로 돌아가려면 익숙한 전환 방법을 사용하여 언제든지 전환할 수 있습니다.",
                "html": "장에서 Result Perspective의 가능성에 대해 자세히 설명하겠습니다. Design Perspective로 돌아가려면 익숙한 전환 방법을 사용하여 언제든지 전환할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "팁: 어느 정도 시간이 지나면 Design Perspective와 Result Perspective 사이를 자주 전환하고 싶을 것입니다. 아이콘이나 메뉴 항목을 사용하는 대신, 키보드 단축키 F8을 사용하여 Design Perspective로, F9를 사용하여 Result Perspective로 전환할 수 있습니다.",
                "html": "팁: 어느 정도 시간이 지나면 Design Perspective와 Result Perspective 사이를 자주 전환하고 싶을 것입니다. 아이콘이나 메뉴 항목을 사용하는 대신, 키보드 단축키 F8을 사용하여 Design Perspective로, F9를 사용하여 Result Perspective로 전환할 수 있습니다. "
              }
            ],
            "subsections": []
          },
          {
            "id": "3-4-2-breakpoints",
            "number": "3.4.2",
            "title": "브레이크포인트",
            "blocks": [
              {
                "type": "paragraph",
                "text": "메타 데이터 변환은 분석 프로세스의 설계를 지원하고 훨씬 더 편리하게 만드는 매우 강력한 도구입니다. 설계 중에 테스트 목적으로 필요한 것 이상으로 프로세스를 수행할 필요가 더 이상 없습니다. 실제로 예상 결과는 이미",
                "html": "메타 데이터 변환은 분석 프로세스의 설계를 지원하고 훨씬 더 편리하게 만드는 매우 강력한 도구입니다. 설계 중에 테스트 목적으로 필요한 것 이상으로 프로세스를 수행할 필요가 더 이상 없습니다. 실제로 예상 결과는 이미 "
              },
              {
                "type": "paragraph",
                "text": "메타 데이터를 기반으로 추정할 수 있습니다. 따라서 메타 데이터 변환 및 전파는 데이터 분석의 세계를 약간 혁신할 것입니다: 이전에는 다음 오퍼레이터를 구성하기 위해 각 단계를 개별적으로 수행해야 했지만, 이제는 여러 변환의 결과를 실행 없이 직접 예측할 수 있습니다. 이는 특히 대규모 데이터 세트의 분석에 있어 큰 혁신입니다.",
                "html": "메타 데이터를 기반으로 추정할 수 있습니다. 따라서 메타 데이터 변환 및 전파는 데이터 분석의 세계를 약간 혁신할 것입니다: 이전에는 다음 오퍼레이터를 구성하기 위해 각 단계를 개별적으로 수행해야 했지만, 이제는 여러 변환의 결과를 실행 없이 직접 예측할 수 있습니다. 이는 특히 대규모 데이터 세트의 분석에 있어 큰 혁신입니다. "
              },
              {
                "type": "paragraph",
                "text": "그럼에도 불구하고, 경우에 따라 메타 데이터를 넘어서 특정 결과의 모든 세부 사항을 확인해야 할 필요가 있습니다. 설계 중에는 일반적으로 원하는 (중간) 결과를 프로세스의 결과 포트에 배치하고 프로세스를 간단히 실행하면 됩니다. 원하는 결과가 Result Perspective에 표시됩니다. 하지만 프로세스 설계가 이미 완료되어 모든 출력 포트가 연결되어 있다면 어떻게 해야 할까요? 또는 중간 결과가 복잡한 서브프로세스 깊숙이 있다면? RapidMiner Studio에는 이를 위한 정교한 솔루션이 있으며, 프로세스 재설계가 필요하지 않습니다. 그림 3.15에서 볼 수 있듯이, 오퍼레이터의 컨텍스트 메뉴에서 \"Breakpoint Before\" 또는 \"Breakpoint After\" 옵션 중 하나를 선택하여 이른바 브레이크포인트를 삽입하면 됩니다.",
                "html": "그럼에도 불구하고, 경우에 따라 메타 데이터를 넘어서 특정 결과의 모든 세부 사항을 확인해야 할 필요가 있습니다. 설계 중에는 일반적으로 원하는 (중간) 결과를 프로세스의 결과 포트에 배치하고 프로세스를 간단히 실행하면 됩니다. 원하는 결과가 Result Perspective에 표시됩니다. 하지만 프로세스 설계가 이미 완료되어 모든 출력 포트가 연결되어 있다면 어떻게 해야 할까요? 또는 중간 결과가 복잡한 서브프로세스 깊숙이 있다면? RapidMiner Studio에는 이를 위한 정교한 솔루션이 있으며, 프로세스 재설계가 필요하지 않습니다. 그림 3.15에서 볼 수 있듯이, 오퍼레이터의 컨텍스트 메뉴에서 \"Breakpoint Before\" 또는 \"Breakpoint After\" 옵션 중 하나를 선택하여 이른바 브레이크포인트를 삽입하면 됩니다. "
              },
              {
                "type": "paragraph",
                "text": "예를 들어 오퍼레이터 뒤에 브레이크포인트를 삽입한 경우, 프로세스 실행이 이 지점에서 중단되며 연결된 모든 출력 포트의 결과가 Results Perspective에 표시됩니다. 이는 프로세스 설계를 추가로 변경하지 않고도 이러한 결과를 확인할 수 있음을 의미합니다. 오퍼레이터 전의 브레이크포인트는 오퍼레이터 후의 브레이크포인트와 유사하게 작동합니다: 이 경우 해당 오퍼레이터가 실행되기 전에 프로세스가 중단되며, 이 오퍼레이터의 연결된 입력 포트 옆의 객체가 표시됩니다. 오퍼레이터에 브레이크포인트가 있다는 사실은 오퍼레이터 하단 가장자리에 있는 작은 빨간색 기호로 나타납니다(그림 3.16).",
                "html": "예를 들어 오퍼레이터 뒤에 브레이크포인트를 삽입한 경우, 프로세스 실행이 이 지점에서 중단되며 연결된 모든 출력 포트의 결과가 Results Perspective에 표시됩니다. 이는 프로세스 설계를 추가로 변경하지 않고도 이러한 결과를 확인할 수 있음을 의미합니다. 오퍼레이터 전의 브레이크포인트는 오퍼레이터 후의 브레이크포인트와 유사하게 작동합니다: 이 경우 해당 오퍼레이터가 실행되기 전에 프로세스가 중단되며, 이 오퍼레이터의 연결된 입력 포트 옆의 객체가 표시됩니다. 오퍼레이터에 브레이크포인트가 있다는 사실은 오퍼레이터 하단 가장자리에 있는 작은 빨간색 기호로 나타납니다(그림 3.16). "
              },
              {
                "type": "paragraph",
                "text": "팁: 특히 \"Breakpoint After\"의 사용이 비교적 빈번하기 때문에, 이 액션에는 키보드 단축키도 있습니다. 현재 선택된 오퍼레이터 뒤에 브레이크포인트를 추가하거나 현재 설정된 모든 브레이크포인트를 제거하려면 F7 키를 누르십시오.",
                "html": "팁: 특히 \"Breakpoint After\"의 사용이 비교적 빈번하기 때문에, 이 액션에는 키보드 단축키도 있습니다. 현재 선택된 오퍼레이터 뒤에 브레이크포인트를 추가하거나 현재 설정된 모든 브레이크포인트를 제거하려면 F7 키를 누르십시오. "
              },
              {
                "type": "paragraph",
                "text": "RapidMiner Studio는 브레이크포인트의 경우 자동으로 Result Perspective로 전환하고 중간 결과를 표시합니다. 현재",
                "html": "RapidMiner Studio는 브레이크포인트의 경우 자동으로 Result Perspective로 전환하고 중간 결과를 표시합니다. 현재 "
              },
              {
                "type": "paragraph",
                "text": "그림 3.15: 브레이크포인트를 사용하여 프로세스 주기를 중지하고 중간 결과를 검토할 수 있습니다.",
                "html": "그림 3.15: 브레이크포인트를 사용하여 프로세스 주기를 중지하고 중간 결과를 검토할 수 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "그림 3.16: 이 오퍼레이터의 전 또는 후에 브레이크포인트가 정의되어 있습니다.",
                "html": "그림 3.16: 이 오퍼레이터의 전 또는 후에 브레이크포인트가 정의되어 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "현재 브레이크포인트에 있으며 프로세스의 끝이 아님을 두 가지 지표로 알 수 있습니다: 첫째, RapidMiner 메인 창의 왼쪽 하단 모서리에 있는 상태 표시등이 빨간색을 표시합니다. 이는 프로세스가 실행 중이지만 현재 활성 실행 상태가 아님을 의미합니다. 프로세스가 전혀 실행 중이 아니라면 이 표시는 회색일 것입니다. 브레이크포인트의 두 번째 지표는 재생 기호로, 파란색 대신 녹색으로 표시됩니다(그림 3.17).",
                "html": "현재 브레이크포인트에 있으며 프로세스의 끝이 아님을 두 가지 지표로 알 수 있습니다: 첫째, RapidMiner 메인 창의 왼쪽 하단 모서리에 있는 상태 표시등이 빨간색을 표시합니다. 이는 프로세스가 실행 중이지만 현재 활성 실행 상태가 아님을 의미합니다. 프로세스가 전혀 실행 중이 아니라면 이 표시는 회색일 것입니다. 브레이크포인트의 두 번째 지표는 재생 기호로, 파란색 대신 녹색으로 표시됩니다(그림 3.17). "
              },
              {
                "type": "paragraph",
                "text": "3.4. 프로세스 실행",
                "html": "3.4. 프로세스 실행 "
              },
              {
                "type": "paragraph",
                "text": "그림 3.17: 녹색 재생 기호는 프로세스가 현재 브레이크포인트에 있으며, 누르면 계속 실행될 수 있음을 나타냅니다.",
                "html": "그림 3.17: 녹색 재생 기호는 프로세스가 현재 브레이크포인트에 있으며, 누르면 계속 실행될 수 있음을 나타냅니다. "
              },
              {
                "type": "paragraph",
                "text": "녹색 재생 기호를 누르면 프로세스가 다시 시작되어 완료되거나 다음 브레이크포인트까지 계속 실행됩니다. 물론 평소처럼 중지 버튼을 눌러 프로세스를 완전히 중단할 수도 있습니다.",
                "html": "녹색 재생 기호를 누르면 프로세스가 다시 시작되어 완료되거나 다음 브레이크포인트까지 계속 실행됩니다. 물론 평소처럼 중지 버튼을 눌러 프로세스를 완전히 중단할 수도 있습니다. "
              },
              {
                "type": "paragraph",
                "text": "4 데이터 및",
                "html": "4 데이터 및 "
              },
              {
                "type": "paragraph",
                "text": "결과 시각화",
                "html": "결과 시각화 "
              },
              {
                "type": "paragraph",
                "text": "이전 절에서 RapidMiner Studio의 그래픽 사용자 인터페이스가 어떻게 구성되어 있고, 이를 통해 분석 프로세스를 정의하고 실행하는 방법을 살펴보았습니다. 프로세스가 끝나면 프로세스의 결과를 Results Perspective에서 확인할 수 있습니다. 이제 툴바에서 한 번 클릭하여 Results Perspective로 전환하십시오. 이에 대해 이 장에서 자세히 다루겠습니다. 이미 표시 가능한 결과를 생성했는지에 따라, 기본 설정에서는 대략 4.1에 표시된 것과 같은 화면이 보일 것입니다.",
                "html": "이전 절에서 RapidMiner Studio의 그래픽 사용자 인터페이스가 어떻게 구성되어 있고, 이를 통해 분석 프로세스를 정의하고 실행하는 방법을 살펴보았습니다. 프로세스가 끝나면 프로세스의 결과를 Results Perspective에서 확인할 수 있습니다. 이제 툴바에서 한 번 클릭하여 Results Perspective로 전환하십시오. 이에 대해 이 장에서 자세히 다루겠습니다. 이미 표시 가능한 결과를 생성했는지에 따라, 기본 설정에서는 대략 4.1에 표시된 것과 같은 화면이 보일 것입니다. "
              },
              {
                "type": "paragraph",
                "text": "그렇지 않은 경우, 항상 \"View\" – \"Restore Default Perspective\"에서 이 기본 퍼스펙티브를 다시 만들 수 있습니다. Result Perspective는 이미 논의한 Design Perspective와 함께 RapidMiner Studio의 두 번째 핵심 작업 환경입니다. 오른쪽의 Repositories View는 이미 논의했습니다. 이 장에서는 퍼스펙티브의 나머지 구성 요소에 집중하겠습니다.",
                "html": "그렇지 않은 경우, 항상 \"View\" – \"Restore Default Perspective\"에서 이 기본 퍼스펙티브를 다시 만들 수 있습니다. Result Perspective는 이미 논의한 Design Perspective와 함께 RapidMiner Studio의 두 번째 핵심 작업 환경입니다. 오른쪽의 Repositories View는 이미 논의했습니다. 이 장에서는 퍼스펙티브의 나머지 구성 요소에 집중하겠습니다. "
              }
            ],
            "subsections": []
          }
        ]
      }
    ]
  },
  {
    "id": "chapter-4",
    "number": "4",
    "title": "데이터 및 결과 시각화",
    "slug": "chapter-4-data-and-result-visualization",
    "blocks": [],
    "sections": [
      {
        "id": "4-1-result-visualization",
        "number": "4.1",
        "title": "결과 시각화",
        "blocks": [
          {
            "type": "paragraph",
            "text": "프로세스 오른쪽의 결과 포트에 배치된 객체는 프로세스가 완료된 후 Results Perspective(결과 화면)에 자동으로 표시된다는 것을 이미 확인했습니다. 왼쪽 상단의 넓은 영역이 이를 위해 사용되며, 이 장의 마지막에서 논의할 Results Overview(결과 개요)도 여기에 표시됩니다.",
            "html": "프로세스 오른쪽의 결과 포트에 배치된 객체는 프로세스가 완료된 후 Results Perspective(결과 화면)에 자동으로 표시된다는 것을 이미 확인했습니다. 왼쪽 상단의 넓은 영역이 이를 위해 사용되며, 이 장의 마지막에서 논의할 Results Overview(결과 개요)도 여기에 표시됩니다. "
          },
          {
            "type": "paragraph",
            "text": "4. 데이터 및 결과 시각화",
            "html": "4. 데이터 및 결과 시각화 "
          },
          {
            "type": "paragraph",
            "text": "그림 4.1: RapidMiner의 Results Perspective(결과 화면).",
            "html": "그림 4.1: RapidMiner의 Results Perspective(결과 화면). "
          },
          {
            "type": "paragraph",
            "text": "그림 4.2와 같이 현재 열려 있고 표시된 각 결과는 이 영역에서 추가 탭으로 표시됩니다. 엄밀히 말하면, 각 결과도 하나의 뷰이며, 평소처럼 원하는 위치로 이동할 수 있습니다. 이를 통해 여러 결과를 동시에 확인하는 것이 가능합니다.",
            "html": "그림 4.2와 같이 현재 열려 있고 표시된 각 결과는 이 영역에서 추가 탭으로 표시됩니다. 엄밀히 말하면, 각 결과도 하나의 뷰이며, 평소처럼 원하는 위치로 이동할 수 있습니다. 이를 통해 여러 결과를 동시에 확인하는 것이 가능합니다. "
          },
          {
            "type": "paragraph",
            "text": "물론 탭의 닫기(X) 버튼을 클릭하여 개별 뷰, 즉 탭을 닫을 수도 있습니다. 최대화 등 뷰의 다른 기능들도 여기서 완전히 사용할 수 있습니다. RapidMiner Studio는 새 결과가 표시되기 전에 이전 결과를 닫습니다.",
            "html": "물론 탭의 닫기(X) 버튼을 클릭하여 개별 뷰, 즉 탭을 닫을 수도 있습니다. 최대화 등 뷰의 다른 기능들도 여기서 완전히 사용할 수 있습니다. RapidMiner Studio는 새 결과가 표시되기 전에 이전 결과를 닫습니다. "
          }
        ],
        "subsections": [
          {
            "id": "4-1-1-sources-for-displaying-results",
            "number": "4.1.1",
            "title": "결과 표시를 위한 소스",
            "blocks": [
              {
                "type": "paragraph",
                "text": "결과를 표시할 수 있는 여러 소스가 있습니다. 다음에서 모든 방법을 소개하겠습니다:",
                "html": "결과를 표시할 수 있는 여러 소스가 있습니다. 다음에서 모든 방법을 소개하겠습니다: "
              },
              {
                "type": "paragraph",
                "text": "결과를 표시할 수 있는 여러 소스가 있습니다. 다음에서 모든 방법을 소개하겠습니다:",
                "html": "결과를 표시할 수 있는 여러 소스가 있습니다. 다음에서 모든 방법을 소개하겠습니다:"
              },
              {
                "type": "image",
                "caption": "그림 4.2: 열린 각 결과는 왼쪽 넓은 영역에서 추가 탭으로 표시됩니다",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "왼쪽에 표시됩니다.",
                "html": "왼쪽에 표시됩니다."
              },
              {
                "type": "paragraph",
                "text": "1. 자동 열기 프로세스의 최종 결과, 즉 프로세스 오른쪽의 결과 포트에 제공된 객체가 자동으로 표시된다는 것은 이미 확인했습니다. 브레이크포인트의 경우 연결된 포트의 결과에도 동일하게 적용됩니다. 분석 프로세스가 끝날 때 보고 싶은 모든 프로세스 결과를 결과 포트에 모아두기만 하면, Results Perspective의 탭에서 모두 함께 표시됩니다.",
                "html": "1. 자동 열기 프로세스의 최종 결과, 즉 프로세스 오른쪽의 결과 포트에 제공된 객체가 자동으로 표시된다는 것은 이미 확인했습니다. 브레이크포인트의 경우 연결된 포트의 결과에도 동일하게 적용됩니다. 분석 프로세스가 끝날 때 보고 싶은 모든 프로세스 결과를 결과 포트에 모아두기만 하면, Results Perspective의 탭에서 모두 함께 표시됩니다."
              },
              {
                "type": "paragraph",
                "text": "2. 리포지토리의 결과 결과를 표시하는 두 번째 방법은 리포지토리에서 결과를 불러오는 것입니다. 리포지토리 항목의 컨텍스트 메뉴를 통해 또는 항목을 더블클릭하여 이를 수행할 수 있습니다. 물론 이 방법은 결과를 검토하는 것뿐만 아니라",
                "html": "2. 리포지토리의 결과 결과를 표시하는 두 번째 방법은 리포지토리에서 결과를 불러오는 것입니다. 리포지토리 항목의 컨텍스트 메뉴를 통해 또는 항목을 더블클릭하여 이를 수행할 수 있습니다. 물론 이 방법은 결과를 검토하는 것뿐만 아니라"
              },
              {
                "type": "paragraph",
                "text": "이전 결과와 비교하는 데에도 유용합니다.",
                "html": "이전 결과와 비교하는 데에도 유용합니다."
              },
              {
                "type": "paragraph",
                "text": "3. 포트의 결과 결과와 중간 결과를 확인하는 세 번째 방법은 아직 포트에 남아 있는 결과를 표시하는 것입니다. RapidMiner는 개별 오퍼레이터에 의해 생성된 결과를 해당 포트에 잠시 동안 저장해 둡니다. 포트에 아직 결과가 남아 있다면, 포트의 컨텍스트 메뉴를 통해 해당 결과를 선택하여 볼 수 있습니다:",
                "html": "3. 포트의 결과 결과와 중간 결과를 확인하는 세 번째 방법은 아직 포트에 남아 있는 결과를 표시하는 것입니다. RapidMiner는 개별 오퍼레이터에 의해 생성된 결과를 해당 포트에 잠시 동안 저장해 둡니다. 포트에 아직 결과가 남아 있다면, 포트의 컨텍스트 메뉴를 통해 해당 결과를 선택하여 볼 수 있습니다:"
              },
              {
                "type": "image",
                "caption": "그림 4.3: 아직 포트에 남아 있는 결과 표시.",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "이 방식은 다른 데이터 분석 도구에서 익숙할 수 있습니다: 오퍼레이터를 추가하고, 실행한 다음 컨텍스트 메뉴나 전용 오퍼레이터를 통해 결과를 표시하는 것입니다. 이 방식이 작은 데이터 세트에서는 직관적이고 사용하기 쉬워 보일 수 있지만, 대용량 데이터 세트를 분석할 때에는 문제가 발생할 수 있으므로 이 방법은 피하시기를 권장합니다. 이 경우 각 포트에 데이터의 복사본을 보관해야 하므로 나중에 해당 결과를 제공할 수 있어야 합니다. RapidMiner Studio는 여기서 완전히 다른 방식을 취하며, 장기적으로도 더 큰 성공을 약속하는 방식입니다: 메타 데이터가 프로세스에 의해 변환되고 전파되며, 데이터는 절대적으로 필요한 곳에서만 제공됩니다. 이러한 RapidMiner Studio의 분석 방식은 확립된 메타 데이터가 허용하는 상호작용성과 대용량 데이터 세트를 포함한 데이터 세트 분석을 위한 간단한 프로세스 정의를 결합합니다. 참고: RapidMiner Studio는 여기서 정교한 메모리 관리를 사용합니다. 위에서 이미 언급했듯이 결과는 포트에 \"잠시 동안\" 유지됩니다. 이러한 결과는 RapidMiner Studio 또는 다른 프로",
                "html": "이 방식은 다른 데이터 분석 도구에서 익숙할 수 있습니다: 오퍼레이터를 추가하고, 실행한 다음 컨텍스트 메뉴나 전용 오퍼레이터를 통해 결과를 표시하는 것입니다. 이 방식이 작은 데이터 세트에서는 직관적이고 사용하기 쉬워 보일 수 있지만, 대용량 데이터 세트를 분석할 때에는 문제가 발생할 수 있으므로 이 방법은 피하시기를 권장합니다. 이 경우 각 포트에 데이터의 복사본을 보관해야 하므로 나중에 해당 결과를 제공할 수 있어야 합니다. RapidMiner Studio는 여기서 완전히 다른 방식을 취하며, 장기적으로도 더 큰 성공을 약속하는 방식입니다: 메타 데이터가 프로세스에 의해 변환되고 전파되며, 데이터는 절대적으로 필요한 곳에서만 제공됩니다. 이러한 RapidMiner Studio의 분석 방식은 확립된 메타 데이터가 허용하는 상호작용성과 대용량 데이터 세트를 포함한 데이터 세트 분석을 위한 간단한 프로세스 정의를 결합합니다. 참고: RapidMiner Studio는 여기서 정교한 메모리 관리를 사용합니다. 위에서 이미 언급했듯이 결과는 포트에 \"잠시 동안\" 유지됩니다. 이러한 결과는 RapidMiner Studio 또는 다른 프로"
              },
              {
                "type": "paragraph",
                "text": "그램에 필요한 메모리가 부족해지면 삭제됩니다. 즉, 결과가 포트에서 사라져 더 이상 시각화에 사용할 수 없게 될 수 있습니다. 이것이 RapidMiner Studio의 효율성의 이유 중 하나이며, 따라서 위에서 설명한 대로 연결된 포트를 통한 자동 표시를 권장합니다. 이 방식에서는 결과 제공이 보장되기 때문입니다.",
                "html": "그램에 필요한 메모리가 부족해지면 삭제됩니다. 즉, 결과가 포트에서 사라져 더 이상 시각화에 사용할 수 없게 될 수 있습니다. 이것이 RapidMiner Studio의 효율성의 이유 중 하나이며, 따라서 위에서 설명한 대로 연결된 포트를 통한 자동 표시를 권장합니다. 이 방식에서는 결과 제공이 보장되기 때문입니다."
              }
            ],
            "subsections": []
          }
        ]
      },
      {
        "id": "4-2-about-data-copies-and-views",
        "number": "4.2",
        "title": "데이터 복사본과 뷰에 대하여",
        "blocks": [
          {
            "type": "paragraph",
            "text": "불필요한 데이터 복사본이 생성되지 않는다는 사실은 때때로 혼란의 원인이 됩니다. 이는 특히 위에서 언급한 두 번째 결과 표시 방법, 즉 포트의 컨텍스트 메뉴를 통한 표시에 해당합니다. 데이터 세트가 있고 정규화를 위한 오퍼레이터를 추가한다고 가정해 봅시다. 기본 설정에서 정규화 오퍼레이터는 기본 데이터를 변경합니다. 프로세스 흐름에서 정규화 이전의 포트에 있는 데이터 세트를 확인하더라도, 시간적으로 정규화가 이미 수행된 후라면, 이전 포트의 데이터도 이미 변경되어 있을 것입니다. 이 동작은 사실 상당히 명확해야 합니다",
            "html": "불필요한 데이터 복사본이 생성되지 않는다는 사실은 때때로 혼란의 원인이 됩니다. 이는 특히 위에서 언급한 두 번째 결과 표시 방법, 즉 포트의 컨텍스트 메뉴를 통한 표시에 해당합니다. 데이터 세트가 있고 정규화를 위한 오퍼레이터를 추가한다고 가정해 봅시다. 기본 설정에서 정규화 오퍼레이터는 기본 데이터를 변경합니다. 프로세스 흐름에서 정규화 이전의 포트에 있는 데이터 세트를 확인하더라도, 시간적으로 정규화가 이미 수행된 후라면, 이전 포트의 데이터도 이미 변경되어 있을 것입니다. 이 동작은 사실 상당히 명확해야 합니다"
          },
          {
            "type": "list",
            "items": [
              "앞서 언급했듯이, 데이터의 복사본이 생성되지 않았으므로 동일한"
            ]
          },
          {
            "type": "paragraph",
            "text": "데이터 세트가 계속 변경된 것입니다. 그럼에도 불구하고 이러한 \"이상한\" \"제어되지 않는 데이터 변경\" 동작은 때때로 혼란을 야기합니다. 하지만 이 동작에 영향을 줄 수 있는 두 가지 방법이 있습니다:",
            "html": "데이터 세트가 계속 변경된 것입니다. 그럼에도 불구하고 이러한 \"이상한\" \"제어되지 않는 데이터 변경\" 동작은 때때로 혼란을 야기합니다. 하지만 이 동작에 영향을 줄 수 있는 두 가지 방법이 있습니다:"
          },
          {
            "type": "paragraph",
            "text": "1. 뷰의 사용: 데이터 변환을 위한 수많은 오퍼레이터들이 \"create view\" 파라미터를 제공합니다. 이 파라미터는 데이터를 직접 변경하는 대신 데이터에 뷰를 추가하여 데이터 접근 시 즉석에서(on-the-fly) 데이터를 변경합니다. 따라서 이러한 연산은 이전 포트나 프로세스의 다른 병렬 분기에 있는 포트에 영향을 미치지 않습니다.",
            "html": "1. 뷰의 사용: 데이터 변환을 위한 수많은 오퍼레이터들이 \"create view\" 파라미터를 제공합니다. 이 파라미터는 데이터를 직접 변경하는 대신 데이터에 뷰를 추가하여 데이터 접근 시 즉석에서(on-the-fly) 데이터를 변경합니다. 따라서 이러한 연산은 이전 포트나 프로세스의 다른 병렬 분기에 있는 포트에 영향을 미치지 않습니다."
          },
          {
            "type": "paragraph",
            "text": "2. 명시적 복사: 특히 작은 데이터 세트의 경우, \"Multiply\" 오퍼레이터와 \"Materialize Data\" 오퍼레이터의 조합이 해결책이 될 수 있습니다. 분석가로서 먼저 \"Multiply\"를 통해 데이터 세트에 대한 참조를 복제한 다음 \"Materialize Data\"를 통해 두 가상 데이터 세트를 테이블로 명시적으로 재생성하여 데이터 복사본을 원한다는 의사를 명시적으로 정의할 수 있습니다.",
            "html": "2. 명시적 복사: 특히 작은 데이터 세트의 경우, \"Multiply\" 오퍼레이터와 \"Materialize Data\" 오퍼레이터의 조합이 해결책이 될 수 있습니다. 분석가로서 먼저 \"Multiply\"를 통해 데이터 세트에 대한 참조를 복제한 다음 \"Materialize Data\"를 통해 두 가상 데이터 세트를 테이블로 명시적으로 재생성하여 데이터 복사본을 원한다는 의사를 명시적으로 정의할 수 있습니다."
          },
          {
            "type": "paragraph",
            "text": "포트를 통해 결과에 접근하기 위해 이러한 작업을 진지하게 수행하는 분석가는 없을 것입니다. 그러나 이러한 상호연결은 프로세스의 병렬 분기에서도 때때로 발생할 수 있으며, 데이터 세트의 크기에 따라 뷰 또는 명시적 복사를 통해 해결할 수 있습니다.",
            "html": "포트를 통해 결과에 접근하기 위해 이러한 작업을 진지하게 수행하는 분석가는 없을 것입니다. 그러나 이러한 상호연결은 프로세스의 병렬 분기에서도 때때로 발생할 수 있으며, 데이터 세트의 크기에 따라 뷰 또는 명시적 복사를 통해 해결할 수 있습니다."
          }
        ],
        "subsections": []
      },
      {
        "id": "4-3-display-formats",
        "number": "4.3",
        "title": "표시 형식",
        "blocks": [
          {
            "type": "paragraph",
            "text": "결과가 어떤 방식으로 Results Perspective에 들어왔든, 각 결과는 자체 파일 카드 내에 표시됩니다. 또한 RapidMiner Studio 내에서 뷰라고도 하는 다양한 결과 표시 방법이 있습니다:",
            "html": "결과가 어떤 방식으로 Results Perspective에 들어왔든, 각 결과는 자체 파일 카드 내에 표시됩니다. 또한 RapidMiner Studio 내에서 뷰라고도 하는 다양한 결과 표시 방법이 있습니다:"
          },
          {
            "type": "image",
            "caption": "그림 4.4: 데이터 세트에 대해 \"Data\"(현재 표시됨), \"Statistics\", \"Charts\" 및 \"Ad-",
            "src": ""
          },
          {
            "type": "paragraph",
            "text": "vanced Charts\" 뷰가 존재합니다. 예를 들어 데이터 세트에는 세 가지 뷰가 있습니다. 즉, 데이터 자체의 표시(\"Data View\"), 메타 데이터 및 통계(\"Statistics View\"), 다양한 시각화의 표시(\"Charts View\"), 그리고 고급 시각화 표시입니다. 위 예시에서는 데이터 세트의 Data View를",
            "html": "vanced Charts\" 뷰가 존재합니다. 예를 들어 데이터 세트에는 세 가지 뷰가 있습니다. 즉, 데이터 자체의 표시(\"Data View\"), 메타 데이터 및 통계(\"Statistics View\"), 다양한 시각화의 표시(\"Charts View\"), 그리고 고급 시각화 표시입니다. 위 예시에서는 데이터 세트의 Data View를"
          },
          {
            "type": "paragraph",
            "text": "테이블 형태로 볼 수 있습니다. 이러한 테이블 외에도 추가 표준 표시 형식이 제공되며, 다음에서 이를 설명하겠습니다.",
            "html": "테이블 형태로 볼 수 있습니다. 이러한 테이블 외에도 추가 표준 표시 형식이 제공되며, 다음에서 이를 설명하겠습니다."
          }
        ],
        "subsections": [
          {
            "id": "4-3-1-description",
            "number": "4.3.1",
            "title": "설명",
            "blocks": [
              {
                "type": "paragraph",
                "text": "가장 기본적인 시각화 형태는 텍스트 형식입니다. 일부 모델과 다양한 결과는 텍스트 형태로 표시될 수 있습니다. 이는 일반적으로 \"Description View\"라 불리는 뷰에서 이루어지며, 해당 객체에 여러 뷰가 있는 경우 탭 왼쪽의 버튼을 사용하여 선택할 수 있습니다. RapidMiner Studio에서는 항상 마우스로 이러한 텍스트를 선택하고 Ctrl+C로 클립보드에 복사할 수 있습니다. 그러면 다른 애플리케이션에서도 결과를 사용할 수 있습니다. 텍스트 영역을 클릭한 후 Ctrl+A로 전체 텍스트를 선택한 다음 복사할 수도 있습니다.",
                "html": "가장 기본적인 시각화 형태는 텍스트 형식입니다. 일부 모델과 다양한 결과는 텍스트 형태로 표시될 수 있습니다. 이는 일반적으로 \"Description View\"라 불리는 뷰에서 이루어지며, 해당 객체에 여러 뷰가 있는 경우 탭 왼쪽의 버튼을 사용하여 선택할 수 있습니다. RapidMiner Studio에서는 항상 마우스로 이러한 텍스트를 선택하고 Ctrl+C로 클립보드에 복사할 수 있습니다. 그러면 다른 애플리케이션에서도 결과를 사용할 수 있습니다. 텍스트 영역을 클릭한 후 Ctrl+A로 전체 텍스트를 선택한 다음 복사할 수도 있습니다."
              },
              {
                "type": "image",
                "caption": "그림 4.5: 일부 모델은 텍스트 형태로 표시됩니다. 다양한",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "다른 객체들도 읽을 수 있는 텍스트 형태의 표시를 제공합니다.",
                "html": "다른 객체들도 읽을 수 있는 텍스트 형태의 표시를 제공합니다."
              }
            ],
            "subsections": []
          },
          {
            "id": "4-3-2-tables",
            "number": "4.3.2",
            "title": "테이블",
            "blocks": [
              {
                "type": "paragraph",
                "text": "RapidMiner에서 가장 빈번한 정보 표시 형식 중 하나는 테이블 형태입니다. 테이블 구조의 데이터 분석을 주요 목표로 하는 소프트웨어 솔루션으로서 이는 놀라운 일이 아닙니다. 그러나 테이블은 데이터 세트 표시뿐만 아니라 메타 데이터, 영향 인자의 가중치, 모든 속성 간의 상관관계와 같은 행렬 등 다양한 용도에",
                "html": "RapidMiner에서 가장 빈번한 정보 표시 형식 중 하나는 테이블 형태입니다. 테이블 구조의 데이터 분석을 주요 목표로 하는 소프트웨어 솔루션으로서 이는 놀라운 일이 아닙니다. 그러나 테이블은 데이터 세트 표시뿐만 아니라 메타 데이터, 영향 인자의 가중치, 모든 속성 간의 상관관계와 같은 행렬 등 다양한 용도에"
              },
              {
                "type": "paragraph",
                "text": "사용됩니다. 이러한 뷰는 특히 혼동이 우려되는 경우 이름에 \"Table\"이라는 용어가 자주 포함됩니다. 그 외에는 \"Data View\"나 \"Statistics View\"와 같은 용어로 간단히 지칭됩니다. 색상 구성표 RapidMiner의 거의 모든 테이블은 개요를 향상시키는 특정 색상 코딩을 사용합니다. 예를 들어 데이터 세트에서 행은 교대로 다른 색상으로 표시됩니다. 특별한 역할을 가진 속성은 연한 노란색 배경이 지정되고 일반 속성은 연한 파란색 배경이 지정됩니다:",
                "html": "사용됩니다. 이러한 뷰는 특히 혼동이 우려되는 경우 이름에 \"Table\"이라는 용어가 자주 포함됩니다. 그 외에는 \"Data View\"나 \"Statistics View\"와 같은 용어로 간단히 지칭됩니다. 색상 구성표 RapidMiner의 거의 모든 테이블은 개요를 향상시키는 특정 색상 코딩을 사용합니다. 예를 들어 데이터 세트에서 행은 교대로 다른 색상으로 표시됩니다. 특별한 역할을 가진 속성은 연한 노란색 배경이 지정되고 일반 속성은 연한 파란색 배경이 지정됩니다:"
              },
              {
                "type": "image",
                "caption": "그림 4.6: 색상 코딩과 교대 행 배경이 테이블 내 탐색을 용이하게",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "합니다. 이 색상 코딩은 메타 데이터에도 적용됩니다: 특별한 역할을 가진 속성은 일관되게 연한 노란색 배경을 가지며, 일반 속성은 교대로 연한 파란색과 흰색 배경을 가집니다. 그러나 그림 4.7과 같이 다른 객체에서는 이 색상 구성이 완전히 다를 수 있습니다. 예를 들어 상관관계 행렬에서는 개별 셀에 색상이 지정될 수 있으며, 색상이 진할수록 해당 속성 간의 상관관계가 강합니다.",
                "html": "합니다. 이 색상 코딩은 메타 데이터에도 적용됩니다: 특별한 역할을 가진 속성은 일관되게 연한 노란색 배경을 가지며, 일반 속성은 교대로 연한 파란색과 흰색 배경을 가집니다. 그러나 그림 4.7과 같이 다른 객체에서는 이 색상 구성이 완전히 다를 수 있습니다. 예를 들어 상관관계 행렬에서는 개별 셀에 색상이 지정될 수 있으며, 색상이 진할수록 해당 속성 간의 상관관계가 강합니다."
              },
              {
                "type": "image",
                "caption": "그림 4.7: RapidMiner의 테이블은 종종 색상으로 흥미로운 정보를",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "표시합니다. 이 경우 진한 배경은 속성 간의 강한 상관관계를 강조합니다. 정렬 RapidMiner에서 대부분의 테이블은 간단한 클릭으로 정렬할 수 있습니다. 커서를 열 머리글 중앙 부근으로 이동하고 머리글을 클릭합니다. 이제 작은 삼각형이 정렬 순서를 나타냅니다. 다시 클릭하면 정렬 순서가 변경되고, 세 번째 클릭하면 정렬이 비활성화됩니다. 여러 열을 동시에 기준으로 정렬할 수도 있습니다. 즉, 먼저 한 열로 정렬한 다음 해당 정렬 내에서 최대 두 개의 추가 열로 정렬합니다. 이렇게 하려면 먼저 첫 번째 열을 원하는 순서로 정렬합니다. 그런 다음 Ctrl 키를 누른 상태에서 정렬에 추가 열을 추가합니다. 다음 예시에서는 먼저 매장 ID에 따라 거래를 정렬한 다음 상품 카테고리에 따라 정렬했습니다. 이 정렬 내에서 열의 순서는 크기가 큰 것에서",
                "html": "표시합니다. 이 경우 진한 배경은 속성 간의 강한 상관관계를 강조합니다. 정렬 RapidMiner에서 대부분의 테이블은 간단한 클릭으로 정렬할 수 있습니다. 커서를 열 머리글 중앙 부근으로 이동하고 머리글을 클릭합니다. 이제 작은 삼각형이 정렬 순서를 나타냅니다. 다시 클릭하면 정렬 순서가 변경되고, 세 번째 클릭하면 정렬이 비활성화됩니다. 여러 열을 동시에 기준으로 정렬할 수도 있습니다. 즉, 먼저 한 열로 정렬한 다음 해당 정렬 내에서 최대 두 개의 추가 열로 정렬합니다. 이렇게 하려면 먼저 첫 번째 열을 원하는 순서로 정렬합니다. 그런 다음 Ctrl 키를 누른 상태에서 정렬에 추가 열을 추가합니다. 다음 예시에서는 먼저 매장 ID에 따라 거래를 정렬한 다음 상품 카테고리에 따라 정렬했습니다. 이 정렬 내에서 열의 순서는 크기가 큰 것에서"
              },
              {
                "type": "paragraph",
                "text": "작은 것으로 다양한 크기의 삼각형으로 표시됩니다(그림 4.8).",
                "html": "작은 것으로 다양한 크기의 삼각형으로 표시됩니다(그림 4.8)."
              },
              {
                "type": "image",
                "caption": "그림 4.8: 이 테이블에서 먼저 \"store id\" 속성에 따라 오름차순으로 정렬이",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "수행된 다음, 매장 ID 블록 내에서 상품 카테고리에 따라 역시 오름차순으로 정렬되었습니다. 참고: 정렬은 시간이 많이 소요될 수 있습니다. 따라서 큰 테이블에서는 실수로 정렬이 시작되어 프로그램을 사용할 수 없게 되는 것을 방지하기 위해 정렬이 비활성화됩니다. 정렬이 비활성화되는 임계값은 \"Tools\" - \"Preferences\" 아래의 설정에서 설정할 수 있습니다. 열 이동 대부분의 테이블에서 열 머리글을 클릭하고 마우스 버튼을 누른 상태로 열을 새 위치로 드래그하여 열의 순서를 변경할 수 있습니다. 큰 테이블에서 두 열의 내용을 서로 비교하고자 할 때 유용할 수 있습니다. 열 너비 조정 두 열 사이의 영역에 커서를 놓고 마우스 버튼을 누른 상태에서 구분선 왼쪽 열의 너비를",
                "html": "수행된 다음, 매장 ID 블록 내에서 상품 카테고리에 따라 역시 오름차순으로 정렬되었습니다. 참고: 정렬은 시간이 많이 소요될 수 있습니다. 따라서 큰 테이블에서는 실수로 정렬이 시작되어 프로그램을 사용할 수 없게 되는 것을 방지하기 위해 정렬이 비활성화됩니다. 정렬이 비활성화되는 임계값은 \"Tools\" - \"Preferences\" 아래의 설정에서 설정할 수 있습니다. 열 이동 대부분의 테이블에서 열 머리글을 클릭하고 마우스 버튼을 누른 상태로 열을 새 위치로 드래그하여 열의 순서를 변경할 수 있습니다. 큰 테이블에서 두 열의 내용을 서로 비교하고자 할 때 유용할 수 있습니다. 열 너비 조정 두 열 사이의 영역에 커서를 놓고 마우스 버튼을 누른 상태에서 구분선 왼쪽 열의 너비를"
              },
              {
                "type": "paragraph",
                "text": "변경하여 열 너비를 조정할 수 있습니다. 또는 이 간격을 더블클릭하면 간격 왼쪽 열의 너비가 필요한 최소 크기로 자동 조정됩니다. 마지막으로, Ctrl 키를 누른 상태에서 간격을 더블클릭하면 모든 열의 크기가 자동으로 조정됩니다. 팁: 열 너비를 빠르게 조정할 수 있도록 이 조합(CTRL + 열 머리글 영역의 간격 더블클릭)을 기억해 두세요. 컨텍스트 메뉴의 동작 대부분의 테이블에서 테이블 셀을 마우스 오른쪽 버튼으로 클릭하여 추가 동작이 포함된 컨텍스트 메뉴를 열 수 있습니다. 이러한 동작의 세부 사항은 다음과 같습니다:",
                "html": "변경하여 열 너비를 조정할 수 있습니다. 또는 이 간격을 더블클릭하면 간격 왼쪽 열의 너비가 필요한 최소 크기로 자동 조정됩니다. 마지막으로, Ctrl 키를 누른 상태에서 간격을 더블클릭하면 모든 열의 크기가 자동으로 조정됩니다. 팁: 열 너비를 빠르게 조정할 수 있도록 이 조합(CTRL + 열 머리글 영역의 간격 더블클릭)을 기억해 두세요. 컨텍스트 메뉴의 동작 대부분의 테이블에서 테이블 셀을 마우스 오른쪽 버튼으로 클릭하여 추가 동작이 포함된 컨텍스트 메뉴를 열 수 있습니다. 이러한 동작의 세부 사항은 다음과 같습니다:"
              },
              {
                "type": "paragraph",
                "text": "1. Select Row: 행 선택,",
                "html": "1. Select Row: 행 선택,"
              },
              {
                "type": "paragraph",
                "text": "2. Select Column: 열 선택",
                "html": "2. Select Column: 열 선택"
              },
              {
                "type": "paragraph",
                "text": "3. Fit Column Width: 선택한 열의 너비 조정",
                "html": "3. Fit Column Width: 선택한 열의 너비 조정"
              },
              {
                "type": "paragraph",
                "text": "4. Fit all Column Widths: 모든 열 너비 조정",
                "html": "4. Fit all Column Widths: 모든 열 너비 조정"
              },
              {
                "type": "paragraph",
                "text": "5. Equal Column Widths: 모든 열에 동일한 표준 너비 적용",
                "html": "5. Equal Column Widths: 모든 열에 동일한 표준 너비 적용"
              },
              {
                "type": "paragraph",
                "text": "6. Sort by Column (Ascending): 이 열을 기준으로 오름차순 정렬",
                "html": "6. Sort by Column (Ascending): 이 열을 기준으로 오름차순 정렬"
              },
              {
                "type": "paragraph",
                "text": "7. Sort by Column (Descending): 이 열을 기준으로 내림차순 정렬",
                "html": "7. Sort by Column (Descending): 이 열을 기준으로 내림차순 정렬"
              },
              {
                "type": "paragraph",
                "text": "8. Add to Sorting Columns (Ascending): 정렬 열에 추가 (오름차순)",
                "html": "8. Add to Sorting Columns (Ascending): 정렬 열에 추가 (오름차순)"
              },
              {
                "type": "paragraph",
                "text": "9. Add to Sorting Columns (Descending): 정렬 열에 추가 (내림차순)",
                "html": "9. Add to Sorting Columns (Descending): 정렬 열에 추가 (내림차순)"
              },
              {
                "type": "paragraph",
                "text": "10. Sort Columns by Names: 열 머리글을 알파벳순으로 정렬하여 열 재배치",
                "html": "10. Sort Columns by Names: 열 머리글을 알파벳순으로 정렬하여 열 재배치"
              },
              {
                "type": "paragraph",
                "text": "11. Restore Column Order: 원래 열 순서 복원.",
                "html": "11. Restore Column Order: 원래 열 순서 복원."
              },
              {
                "type": "image",
                "caption": "그림 4.9: 행 또는 열 선택, 열별 내용 정렬과 같은 동작",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "또는 열 너비 조정이 컨텍스트 메뉴에서 제공됩니다. 테이블 내용 복사 위의 텍스트 뷰에서와 마찬가지로, 테이블 내에서도 마우스를 사용하여 개별 셀을 선택하거나 테이블을 클릭한 후 Ctrl+A를 사용하여 전체 테이블을 선택할 수 있습니다. 전체 행이나 열을 선택하기 위한 동작도 컨텍스트 메뉴에서 제공됩니다. 그런 다음 Ctrl+C로 선택한 영역을 클립보드에 복사하여 다른 애플리케이션에 붙여넣을 수 있습니다. 예를 들어 Microsoft Excel과 같이 테이블 형식의 데이터를 지원하는 애플리케이션에 붙여넣으면 테이블 구조가 그대로 유지됩니다.",
                "html": "또는 열 너비 조정이 컨텍스트 메뉴에서 제공됩니다. 테이블 내용 복사 위의 텍스트 뷰에서와 마찬가지로, 테이블 내에서도 마우스를 사용하여 개별 셀을 선택하거나 테이블을 클릭한 후 Ctrl+A를 사용하여 전체 테이블을 선택할 수 있습니다. 전체 행이나 열을 선택하기 위한 동작도 컨텍스트 메뉴에서 제공됩니다. 그런 다음 Ctrl+C로 선택한 영역을 클립보드에 복사하여 다른 애플리케이션에 붙여넣을 수 있습니다. 예를 들어 Microsoft Excel과 같이 테이블 형식의 데이터를 지원하는 애플리케이션에 붙여넣으면 테이블 구조가 그대로 유지됩니다."
              }
            ],
            "subsections": []
          },
          {
            "id": "4-3-3-charts",
            "number": "4.3.3",
            "title": "차트",
            "blocks": [
              {
                "type": "paragraph",
                "text": "RapidMiner Studio의 가장 강력한 기능 중 하나는 \"Charts View\"와 \"Advanced Charts View\"에서 제공하는 데이터, 기타 테이블, 모델 및 결과에 대한 수많은 시각화 방법입니다.",
                "html": "RapidMiner Studio의 가장 강력한 기능 중 하나는 \"Charts View\"와 \"Advanced Charts View\"에서 제공하는 데이터, 기타 테이블, 모델 및 결과에 대한 수많은 시각화 방법입니다."
              },
              {
                "type": "paragraph",
                "text": "차트 구성 RapidMiner Studio에서 모든 차트의 구조는 기본적으로 동일합니다. 왼쪽에 익숙한 여러 요소로 구성된 구성 영역이 있습니다:",
                "html": "차트 구성 RapidMiner Studio에서 모든 차트의 구조는 기본적으로 동일합니다. 왼쪽에 익숙한 여러 요소로 구성된 구성 영역이 있습니다:"
              },
              {
                "type": "image",
                "caption": "그림 4.10: 데이터 세트의 시각화와 왼쪽의 차트 구성",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "영역. 가장 중요한 설정은 왼쪽 상단에 있으며 시각화 유형에 해당합니다. 데이터와 결과를 표시하기 위해 30가지 이상의 다양한 2D, 3D, 심지어 고차원 시각화 방법이 제공됩니다. 위 이미지에서는 \"Scatter\" 유형의 플롯을 볼 수 있습니다. 선택한 차트 유형에 따라 모든 추가 설정 필드가 변경됩니다. 예를 들어 산점도에서는 x축과 y축의 속성을 지정하고 세 번째 속성을 사용하여 점에 색상을 지정할 수 있습니다. 축을 로그 스케일로 조정할지 여부를 지정하는 등 산점도에 특화된 추가 작업도 수행할 수 있습니다.",
                "html": "영역. 가장 중요한 설정은 왼쪽 상단에 있으며 시각화 유형에 해당합니다. 데이터와 결과를 표시하기 위해 30가지 이상의 다양한 2D, 3D, 심지어 고차원 시각화 방법이 제공됩니다. 위 이미지에서는 \"Scatter\" 유형의 플롯을 볼 수 있습니다. 선택한 차트 유형에 따라 모든 추가 설정 필드가 변경됩니다. 예를 들어 산점도에서는 x축과 y축의 속성을 지정하고 세 번째 속성을 사용하여 점에 색상을 지정할 수 있습니다. 축을 로그 스케일로 조정할지 여부를 지정하는 등 산점도에 특화된 추가 작업도 수행할 수 있습니다."
              },
              {
                "type": "paragraph",
                "text": "팁: \"Jitter\" 기능은 숫자뿐만 아니라 명목(nominal) 값도 포함하는 데이터 세트에서 특히 유용합니다. 점을 원래 위치에서 임의의 방향으로 얼마나 멀리 이동시킬지 여부를 지정합니다. 이를 통해 다른 점에 의해 가려질 수 있는 점을 쉽게 확인할 수 있습니다. 많은 차트는 x축의 텍스트를 회전시켜 긴 텍스트도 읽을 수 있도록 하는 등의 추가 표시 설정도 제공합니다. 다양한 설정과 가능성을 조금 실험해 보면 곧 수많은 시각화 방법에 익숙해질 것입니다. 팁: 사용되는 색상은 \"Tools\" - \"Preferences\" 아래의 설정에서 변경할 수 있습니다. 차트 유형 변경 차트 유형의 선택은 설정할 수 있는 파라미터를 크게 좌우합니다. 그림 4.11에서는 \"Bars Stacked\" 유형 차트의 예시를 볼 수 있습니다. 서로 다른 축 대신에 데이터를 그룹화할 속성(여기서는: \"store id\")과 스택을 정의하는 데 사용할 속성(여기서는: \"product category\")을 설정합니다. 막대의 높이는 값 열로 정의된 속성(여기서는: \"amount\")의 합계(여기서는: \"Aggregation\"이 \"sum\"으로 설정됨)에 해당합니다. 시각화 계산 마지막으로, 너무 복잡하여 특별히 계산해야 하는 시각화도 있다는 점을 언급해야 합니다. Self-Organizing Map(SOM)과 같은 이러한 시각화는 그림 4.12에 표시된 계산과 시각화를 시작할 수 있는 \"Calculate\" 버튼을 제공합니다.",
                "html": "팁: \"Jitter\" 기능은 숫자뿐만 아니라 명목(nominal) 값도 포함하는 데이터 세트에서 특히 유용합니다. 점을 원래 위치에서 임의의 방향으로 얼마나 멀리 이동시킬지 여부를 지정합니다. 이를 통해 다른 점에 의해 가려질 수 있는 점을 쉽게 확인할 수 있습니다. 많은 차트는 x축의 텍스트를 회전시켜 긴 텍스트도 읽을 수 있도록 하는 등의 추가 표시 설정도 제공합니다. 다양한 설정과 가능성을 조금 실험해 보면 곧 수많은 시각화 방법에 익숙해질 것입니다. 팁: 사용되는 색상은 \"Tools\" - \"Preferences\" 아래의 설정에서 변경할 수 있습니다. 차트 유형 변경 차트 유형의 선택은 설정할 수 있는 파라미터를 크게 좌우합니다. 그림 4.11에서는 \"Bars Stacked\" 유형 차트의 예시를 볼 수 있습니다. 서로 다른 축 대신에 데이터를 그룹화할 속성(여기서는: \"store id\")과 스택을 정의하는 데 사용할 속성(여기서는: \"product category\")을 설정합니다. 막대의 높이는 값 열로 정의된 속성(여기서는: \"amount\")의 합계(여기서는: \"Aggregation\"이 \"sum\"으로 설정됨)에 해당합니다. 시각화 계산 마지막으로, 너무 복잡하여 특별히 계산해야 하는 시각화도 있다는 점을 언급해야 합니다. Self-Organizing Map(SOM)과 같은 이러한 시각화는 그림 4.12에 표시된 계산과 시각화를 시작할 수 있는 \"Calculate\" 버튼을 제공합니다."
              },
              {
                "type": "image",
                "caption": "그림 4.11: 차트 유형에 따라 차트 구성이 변경됩니다.",
                "src": ""
              }
            ],
            "subsections": []
          },
          {
            "id": "4-3-4-graphs",
            "number": "4.3.4",
            "title": "그래프",
            "blocks": [
              {
                "type": "paragraph",
                "text": "그래프는 RapidMiner에서 비교적 자주 볼 수 있는 또 다른 표시 형식입니다. 그래프는 기본적으로 노드와 그 관계를 보여주는 모든 시각화를 의미합니다. 이는 계층적 클러스터링 내의 노드이거나 그림 4.13과 같은 의사결정 트리의 노드일 수 있습니다. 의사결정 트리와 같은 그래프는 대부분 \"Graph View\"라고 지칭되며 이 이름으로 사용할 수 있습니다. 확대/축소 마우스 휠이 있는 경우 마우스 휠을 사용하여 그래프를 확대 및 축소할 수 있습니다. 또는 구성 영역 왼쪽 상단에 있는 두 개의 버튼을 사용하여 그래프의 확대/축소 수준을 높이거나 줄일 수 있습니다.",
                "html": "그래프는 RapidMiner에서 비교적 자주 볼 수 있는 또 다른 표시 형식입니다. 그래프는 기본적으로 노드와 그 관계를 보여주는 모든 시각화를 의미합니다. 이는 계층적 클러스터링 내의 노드이거나 그림 4.13과 같은 의사결정 트리의 노드일 수 있습니다. 의사결정 트리와 같은 그래프는 대부분 \"Graph View\"라고 지칭되며 이 이름으로 사용할 수 있습니다. 확대/축소 마우스 휠이 있는 경우 마우스 휠을 사용하여 그래프를 확대 및 축소할 수 있습니다. 또는 구성 영역 왼쪽 상단에 있는 두 개의 버튼을 사용하여 그래프의 확대/축소 수준을 높이거나 줄일 수 있습니다."
              },
              {
                "type": "image",
                "caption": "그림 4.12: SOM과 같은 복잡한 시각화는 \"Calculate\" 버튼을 제공하여",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "계산을 시작합니다. 진행 상황은 막대로 표시됩니다.",
                "html": "계산을 시작합니다. 진행 상황은 막대로 표시됩니다."
              },
              {
                "type": "image",
                "caption": "그림 4.13: Graph View에서의 의사결정 트리.",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "모드 그래프에서는 모드라고도 하는 두 가지 기본 탐색 방법을 사용할 수 있습니다:",
                "html": "모드 그래프에서는 모드라고도 하는 두 가지 기본 탐색 방법을 사용할 수 있습니다:"
              },
              {
                "type": "paragraph",
                "text": "1. 이동: 그래프 이동 모드는 모드 상자의 왼쪽 버튼을 누르면 선택됩니다. 이 경우 마우스 왼쪽 버튼을 누른 상태에서 그래프의 영역을 이동하여 그래프의 다양한 부분을 자세히 볼 수 있습니다.",
                "html": "1. 이동: 그래프 이동 모드는 모드 상자의 왼쪽 버튼을 누르면 선택됩니다. 이 경우 마우스 왼쪽 버튼을 누른 상태에서 그래프의 영역을 이동하여 그래프의 다양한 부분을 자세히 볼 수 있습니다."
              },
              {
                "type": "paragraph",
                "text": "2. 선택: 개별 노드 선택 모드는 모드 상자의 오른쪽 버튼을 누르면 선택됩니다. 이제 개별 노드를 클릭하여 선택하거나, 빈 영역에서 마우스 버튼을 누른 상태로 여러 노드를 동시에 선택하는 선택 상자를 정의할 수 있습니다. Shift 키를 누른 상태에서 개별 노드를 선택에 추가하거나 선택에서 제외할 수 있습니다. 현재 선택된 노드는 마우스 버튼을 누른 상태에서 이동할 수 있습니다. 이 두 가지 모드에서의 그래프 처리에 대한 추가 안내는 그래프 구성 영역의 \"Help\" 버튼을 클릭하면 표시되는 도움말 대화 상자에서 확인할 수 있습니다. 추가 설정 노드와 에지의 캡션을 표시할지 여부를 설정할 수 있습니다. 트리에서는 반드시 그렇지 않지만 다른 그래프에서 가장 중요한 설정은 적절한 레이아웃의 선택이며, 모드 상자 바로 아래의 선택 상자에서 설정할 수 있습니다. 서로 다른 알고리즘은 각각의 장단점이 있으며, 현재 그래프에 가장 적합한 표시를 제공하는 알고리즘을 직접 시도해 보아야 합니다.",
                "html": "2. 선택: 개별 노드 선택 모드는 모드 상자의 오른쪽 버튼을 누르면 선택됩니다. 이제 개별 노드를 클릭하여 선택하거나, 빈 영역에서 마우스 버튼을 누른 상태로 여러 노드를 동시에 선택하는 선택 상자를 정의할 수 있습니다. Shift 키를 누른 상태에서 개별 노드를 선택에 추가하거나 선택에서 제외할 수 있습니다. 현재 선택된 노드는 마우스 버튼을 누른 상태에서 이동할 수 있습니다. 이 두 가지 모드에서의 그래프 처리에 대한 추가 안내는 그래프 구성 영역의 \"Help\" 버튼을 클릭하면 표시되는 도움말 대화 상자에서 확인할 수 있습니다. 추가 설정 노드와 에지의 캡션을 표시할지 여부를 설정할 수 있습니다. 트리에서는 반드시 그렇지 않지만 다른 그래프에서 가장 중요한 설정은 적절한 레이아웃의 선택이며, 모드 상자 바로 아래의 선택 상자에서 설정할 수 있습니다. 서로 다른 알고리즘은 각각의 장단점이 있으며, 현재 그래프에 가장 적합한 표시를 제공하는 알고리즘을 직접 시도해 보아야 합니다."
              }
            ],
            "subsections": []
          },
          {
            "id": "4-3-5-special-views",
            "number": "4.3.5",
            "title": "특수 뷰",
            "blocks": [
              {
                "type": "paragraph",
                "text": "위에서 설명한 설명, 테이블, 차트, 그래프 뷰 외에도 때때로 추가 표시 구성 요소가 있지만 이들은 드물며 자명합니다. 예를 들어 빈발 항목 집합(Frequent Itemsets)에는 관련 연관 규칙을 위한 또 다른 특별한 종류의 테이블이나 그래프가 있습니다.",
                "html": "위에서 설명한 설명, 테이블, 차트, 그래프 뷰 외에도 때때로 추가 표시 구성 요소가 있지만 이들은 드물며 자명합니다. 예를 들어 빈발 항목 집합(Frequent Itemsets)에는 관련 연관 규칙을 위한 또 다른 특별한 종류의 테이블이나 그래프가 있습니다."
              }
            ],
            "subsections": []
          }
        ]
      },
      {
        "id": "4-4-result-overview",
        "number": "4.4",
        "title": "결과 개요",
        "blocks": [
          {
            "type": "paragraph",
            "text": "처음에 이미 언급한 Result Overview(결과 개요, 그림 4.14)는 나머지 결과들이 표시되는 곳에서 항상 일종의 자리 표시자로 찾을 수 있습니다:",
            "html": "처음에 이미 언급한 Result Overview(결과 개요, 그림 4.14)는 나머지 결과들이 표시되는 곳에서 항상 일종의 자리 표시자로 찾을 수 있습니다:"
          },
          {
            "type": "image",
            "caption": "그림 4.14: Result Overview는 마지막 분석의 결과를 표시합니다",
            "src": ""
          },
          {
            "type": "paragraph",
            "text": "프로세스.",
            "html": "프로세스."
          },
          {
            "type": "paragraph",
            "text": "Result Overview는 현재 RapidMiner 세션의 모든 프로세스 실행에 대한 간략한 개요 역할을 합니다. 각 두 줄짜리 항목은 프로세스 이름, 결과 수, 프로세스가 완료된 시점 및 실행 시간에 대한 정보로 구성됩니다. 동일한 프로세스의 결과를 표시하는 각 블록은 교대 색상으로 표시됩니다. 항목을 클릭하면 결과의 상세 보기를 볼 수 있습니다. 위의 경우 결과는 예시 세트와 의사결정 트리로 구성됩니다. 항목을 다시 클릭하면 닫힙니다. 물론 여러 항목을 동시에 열어 결과를 편리하게 비교할 수도 있습니다. 각 항목의 오른쪽 상단에는 두 가지 동작이 제공됩니다:",
            "html": "Result Overview는 현재 RapidMiner 세션의 모든 프로세스 실행에 대한 간략한 개요 역할을 합니다. 각 두 줄짜리 항목은 프로세스 이름, 결과 수, 프로세스가 완료된 시점 및 실행 시간에 대한 정보로 구성됩니다. 동일한 프로세스의 결과를 표시하는 각 블록은 교대 색상으로 표시됩니다. 항목을 클릭하면 결과의 상세 보기를 볼 수 있습니다. 위의 경우 결과는 예시 세트와 의사결정 트리로 구성됩니다. 항목을 다시 클릭하면 닫힙니다. 물론 여러 항목을 동시에 열어 결과를 편리하게 비교할 수도 있습니다. 각 항목의 오른쪽 상단에는 두 가지 동작이 제공됩니다:"
          },
          {
            "type": "list",
            "items": [
              "해당 항목에 속한 프로세스를 이 형태로 복원하는 것과",
              "Result Overview에서 해당 항목을 삭제하는 것."
            ]
          },
          {
            "type": "paragraph",
            "text": "또한, Overview 및 개별 항목의 컨텍스트 메뉴에서 전체 개요를 삭제하는 옵션도 있습니다.",
            "html": "또한, Overview 및 개별 항목의 컨텍스트 메뉴에서 전체 개요를 삭제하는 옵션도 있습니다."
          }
        ],
        "subsections": []
      }
    ]
  },
  {
    "id": "chapter-5",
    "number": "5",
    "title": "리포지토리",
    "slug": "chapter-5-repository",
    "blocks": [
      {
        "type": "paragraph",
        "text": "테이블, 데이터베이스, 텍스트 모음, 로그 파일, 웹사이트, 측정값 등 이와 같은 것들이 모든 데이터 마이닝 프로세스의 시작점입니다. 데이터는 준비되고, 변환되고, 병합되며, 최종적으로 새롭거나 다르게 표현된 데이터, 모델 또는 보고서를 얻게 됩니다. 이 장에서는 RapidMiner Studio를 사용하여 이러한 모든 객체를 다루는 방법을 알아봅니다.",
        "html": "테이블, 데이터베이스, 텍스트 모음, 로그 파일, 웹사이트, 측정값 등 이와 같은 것들이 모든 데이터 마이닝 프로세스의 시작점입니다. 데이터는 준비되고, 변환되고, 병합되며, 최종적으로 새롭거나 다르게 표현된 데이터, 모델 또는 보고서를 얻게 됩니다. 이 장에서는 RapidMiner Studio를 사용하여 이러한 모든 객체를 다루는 방법을 알아봅니다."
      }
    ],
    "sections": [
      {
        "id": "5-1-the-rapidminer-studio-repository",
        "number": "5.1",
        "title": "RapidMiner Studio 리포지토리",
        "blocks": [
          {
            "type": "paragraph",
            "text": "프로세스와 관련 파일의 모음이 일정 규모를 넘어서면, 이를 일관되고 체계적인 방식으로 관리하는 것이 현명하다는 것을 알게 될 것입니다. 한 가지 방법은 파일 수준에서 프로젝트를 구성하는 것입니다. 파일은 프로젝트별로 묶이고, 출력 데이터, 중간 결과, 보고서 등을 위한 디렉터리가 각각 생성됩니다. 체계적인 프로젝트 구조를 만드는 것은 합리적이지만, 일반 파일 시스템을 사용하는 것은 극히 드문 경우에만 권장되며, 데이터 마이닝 솔루션의 요구 사항을 충족하기에는 거의 충분하지 않습니다. 기밀성이나 제한된 저장 공간 등 다양한 이유로 로컬 컴퓨터에 파일을 만드는 것이 불가능할 수 있습니다. 로컬 컴퓨터에서 만든 프로세스를 원격 서버에서 실행하려면 프로세스를 복사하고 경로를 수정하는 등의 수동 작업이 필요합니다. 프로세스의 공동 작성, 데이터 조작 및 결과 평가에는",
            "html": "프로세스와 관련 파일의 모음이 일정 규모를 넘어서면, 이를 일관되고 체계적인 방식으로 관리하는 것이 현명하다는 것을 알게 될 것입니다. 한 가지 방법은 파일 수준에서 프로젝트를 구성하는 것입니다. 파일은 프로젝트별로 묶이고, 출력 데이터, 중간 결과, 보고서 등을 위한 디렉터리가 각각 생성됩니다. 체계적인 프로젝트 구조를 만드는 것은 합리적이지만, 일반 파일 시스템을 사용하는 것은 극히 드문 경우에만 권장되며, 데이터 마이닝 솔루션의 요구 사항을 충족하기에는 거의 충분하지 않습니다. 기밀성이나 제한된 저장 공간 등 다양한 이유로 로컬 컴퓨터에 파일을 만드는 것이 불가능할 수 있습니다. 로컬 컴퓨터에서 만든 프로세스를 원격 서버에서 실행하려면 프로세스를 복사하고 경로를 수정하는 등의 수동 작업이 필요합니다. 프로세스의 공동 작성, 데이터 조작 및 결과 평가에는"
          },
          {
            "type": "paragraph",
            "text": "외부 권한 및 버전 관리가 필요합니다. 다양한 형식으로 저장된 파일은 새로 로드할 때마다 구분자나 인코딩 같은 매개변수를 올바르게 설정해야 합니다. 중간 결과와 프로세스 변형은 곧 상당한 수로 늘어나 쉽게 추적이 어려워집니다. 전체 현황을 다시 파악하기 위해 데이터를 로드하고 확인하는 작업에는 오랜 시간이 걸리거나 외부 애플리케이션을 실행해야 할 수도 있습니다. 이를 쉽게 해줄 수 있는 파일 주석 기능은 일반 파일 시스템에서 지원되지 않습니다. 이러한 모든 문제에 대한 RapidMiner의 해결책이 바로 모든 데이터와 프로세스를 담는 리포지토리입니다. 예를 들어 ETL 프로세스 실행에 필요한 경우처럼 리포지토리 외부에서 데이터를 프로세스에 도입할 수도 있지만, 리포지토리를 사용하면 놓치고 싶지 않은 다음과 같은 여러 가지 이점이 있습니다:",
            "html": "외부 권한 및 버전 관리가 필요합니다. 다양한 형식으로 저장된 파일은 새로 로드할 때마다 구분자나 인코딩 같은 매개변수를 올바르게 설정해야 합니다. 중간 결과와 프로세스 변형은 곧 상당한 수로 늘어나 쉽게 추적이 어려워집니다. 전체 현황을 다시 파악하기 위해 데이터를 로드하고 확인하는 작업에는 오랜 시간이 걸리거나 외부 애플리케이션을 실행해야 할 수도 있습니다. 이를 쉽게 해줄 수 있는 파일 주석 기능은 일반 파일 시스템에서 지원되지 않습니다. 이러한 모든 문제에 대한 RapidMiner의 해결책이 바로 모든 데이터와 프로세스를 담는 리포지토리입니다. 예를 들어 ETL 프로세스 실행에 필요한 경우처럼 리포지토리 외부에서 데이터를 프로세스에 도입할 수도 있지만, 리포지토리를 사용하면 놓치고 싶지 않은 다음과 같은 여러 가지 이점이 있습니다:"
          },
          {
            "type": "list",
            "items": [
              "데이터, 프로세스, 결과 및 보고서가 서로에 대해 상대적으로 표시된 위치에 저장됩니다."
            ]
          },
          {
            "type": "paragraph",
            "text": "이 메커니즘은 사용자에게 투명하게 작동합니다.",
            "html": "이 메커니즘은 사용자에게 투명하게 작동합니다."
          },
          {
            "type": "list",
            "items": [
              "파일을 열거나 로드하는 데 추가 설정이 필요하지 않습니다. 데이터를"
            ]
          },
          {
            "type": "paragraph",
            "text": "한 번의 클릭으로 열고, 확인하거나 프로세스에 통합할 수 있습니다. 파일을 별도로 열지 않고도 언제든지 저장된 데이터의 개요, 특성 및 자신이 작성한 메모를 확인할 수 있습니다.",
            "html": "한 번의 클릭으로 열고, 확인하거나 프로세스에 통합할 수 있습니다. 파일을 별도로 열지 않고도 언제든지 저장된 데이터의 개요, 특성 및 자신이 작성한 메모를 확인할 수 있습니다."
          },
          {
            "type": "list",
            "items": [
              "모든 입출력 데이터와 중간 결과에는 메타 정보가"
            ]
          },
          {
            "type": "paragraph",
            "text": "첨부됩니다. 이를 통해 데이터의 일관성과 무결성이 보장되며, 개발 시점에 프로세스를 검증하고 상황에 맞는 도우미를 제공하는 것이 가능해집니다. 리포지토리는 로컬 또는 공유 파일 시스템에 있거나 외부 RapidMiner Server를 통해 제공될 수 있습니다. 다음 그림은 리포지토리의 내용을 표시하는 리포지토리 뷰를 보여줍니다. RapidMiner Studio는 처음 생성된 리포지토리에서 찾을 수 있는 예제 프로세스와 예제 데이터 세트를 제공합니다. 그 중 일부는 그림 5.1에서 볼 수 있습니다.",
            "html": "첨부됩니다. 이를 통해 데이터의 일관성과 무결성이 보장되며, 개발 시점에 프로세스를 검증하고 상황에 맞는 도우미를 제공하는 것이 가능해집니다. 리포지토리는 로컬 또는 공유 파일 시스템에 있거나 외부 RapidMiner Server를 통해 제공될 수 있습니다. 다음 그림은 리포지토리의 내용을 표시하는 리포지토리 뷰를 보여줍니다. RapidMiner Studio는 처음 생성된 리포지토리에서 찾을 수 있는 예제 프로세스와 예제 데이터 세트를 제공합니다. 그 중 일부는 그림 5.1에서 볼 수 있습니다."
          },
          {
            "type": "image",
            "caption": "그림 5.1: 예제 디렉터리가 열린 리포지토리 뷰.",
            "src": ""
          }
        ],
        "subsections": [
          {
            "id": "5-1-1-creating-a-new-repository",
            "number": "5.1.1",
            "title": "새 리포지토리 만들기",
            "blocks": [
              {
                "type": "paragraph",
                "text": "리포지토리를 사용하려면 먼저 리포지토리를 만들어야 합니다. RapidMiner Studio는 처음 시작할 때 이를 수행하도록 안내합니다. 이후에는",
                "html": "리포지토리를 사용하려면 먼저 리포지토리를 만들어야 합니다. RapidMiner Studio는 처음 시작할 때 이를 수행하도록 안내합니다. 이후에는"
              },
              {
                "type": "paragraph",
                "text": "리포지토리 뷰의 도구 모음에 있는 첫 번째 버튼을 사용하여 추가 리포지토리를 만들 수 있습니다. 다음 그림은 간단한 절차를 보여줍니다. RapidMiner Server를 사용하지 않는 경우, 첫 번째 옵션을 선택하여 로컬 리포지토리를 만든 다음 Next(다음)를 선택합니다. 리포지토리에 이름을 지정하고 생성할 디렉터리를 선택합니다. Finish(완료)로 대화 상자를 닫습니다. 이제 리포지토리를 사용할 수 있습니다.",
                "html": "리포지토리 뷰의 도구 모음에 있는 첫 번째 버튼을 사용하여 추가 리포지토리를 만들 수 있습니다. 다음 그림은 간단한 절차를 보여줍니다. RapidMiner Server를 사용하지 않는 경우, 첫 번째 옵션을 선택하여 로컬 리포지토리를 만든 다음 Next(다음)를 선택합니다. 리포지토리에 이름을 지정하고 생성할 디렉터리를 선택합니다. Finish(완료)로 대화 상자를 닫습니다. 이제 리포지토리를 사용할 수 있습니다."
              },
              {
                "type": "image",
                "caption": "그림 5.2: 공유 RapidMiner Server의 리포지토리를 사용하거나 로컬",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "리포지토리를 선택할 수 있습니다.",
                "html": "리포지토리를 선택할 수 있습니다."
              },
              {
                "type": "image",
                "caption": "그림 5.3: RapidMiner Studio가 새로 생성할 로컬 리포지토리의 이름과",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "디렉터리를 묻습니다.",
                "html": "디렉터리를 묻습니다."
              }
            ],
            "subsections": []
          }
        ]
      },
      {
        "id": "5-2-using-the-repository",
        "number": "5.2",
        "title": "리포지토리 사용하기",
        "blocks": [
          {
            "type": "paragraph",
            "text": "프로젝트에 통일된 디렉터리 구조를 사용하는 것이 좋습니다. 예를 들어 프로젝트 이름의 프로젝트 폴더와 프로세스, 입력 데이터, 결과를 위한 각각의 폴더로 구성합니다. 이 매뉴얼의 모든 예제는 이 구조를 따릅니다. 리포지토리 뷰의 컨텍스트 메뉴나 뷰 상단의 도구 모음에 있는 버튼을 사용하여 디렉터리를 만들 수 있습니다.",
            "html": "프로젝트에 통일된 디렉터리 구조를 사용하는 것이 좋습니다. 예를 들어 프로젝트 이름의 프로젝트 폴더와 프로세스, 입력 데이터, 결과를 위한 각각의 폴더로 구성합니다. 이 매뉴얼의 모든 예제는 이 구조를 따릅니다. 리포지토리 뷰의 컨텍스트 메뉴나 뷰 상단의 도구 모음에 있는 버튼을 사용하여 디렉터리를 만들 수 있습니다."
          }
        ],
        "subsections": [
          {
            "id": "5-2-1-processes-and-relative-repository-descriptions",
            "number": "5.2.1",
            "title": "프로세스와 상대 리포지토리 경로 표기",
            "blocks": [
              {
                "type": "paragraph",
                "text": "다음 절에서 리포지토리에 데이터와 프로세스를 저장하고 다시 접근하는 방법을 논의하기에 앞서, 리포지토리 내에서 이러한 객체를 참조하는 방법에 대한 몇 가지 기본적인 팁을 먼저 제공하고자 합니다. 컨텍스트 메뉴에서 \"Store Process\"(프로세스 저장) 항목을 선택하거나 \"File\"(파일) 메뉴에서 해당 항목을 선택하여 프로세스를 리포지토리에 저장할 수 있습니다. 후자의 경우 리포지토리 브라우저가 열리며, 여기서 프로세스의 저장 위치를 지정할 수 있습니다. 프로세스가 리포지토리에 저장된 후에는 오퍼레이터의 매개변수로 설정된 모든 리포지토리 항목 참조가 프로세스의 위치를 기준으로 해석됩니다. 이것은 무엇을 의미할까요? 리포지토리의 항목은 다음과 같이 표기됩니다: //RepositoryName/Folder/Subfolder/File 앞의 두 슬래시는 먼저 리포지토리 이름이 따라온다는 것을 나타냅니다. 그 다음에 폴더 이름이 이어지고 마지막으로 파일 이름이 옵니다. 이러한 표기를 절대 경로라고 합니다. 다음 표기에서는 /Folder/Subfolder/File 앞에 리포지토리 지정이 빠져 있습니다. 이 표기는 따라서 리포지토리 상대 경로입니다. 이 표기를 사용하는 프로세스가 위치한 동일 리포지토리 내의 파일을 참조합니다. 앞의 슬래시는 절대 경로 표기를 나타냅니다. 이것도 없으면 상대 표기로 해석됩니다:",
                "html": "다음 절에서 리포지토리에 데이터와 프로세스를 저장하고 다시 접근하는 방법을 논의하기에 앞서, 리포지토리 내에서 이러한 객체를 참조하는 방법에 대한 몇 가지 기본적인 팁을 먼저 제공하고자 합니다. 컨텍스트 메뉴에서 \"Store Process\"(프로세스 저장) 항목을 선택하거나 \"File\"(파일) 메뉴에서 해당 항목을 선택하여 프로세스를 리포지토리에 저장할 수 있습니다. 후자의 경우 리포지토리 브라우저가 열리며, 여기서 프로세스의 저장 위치를 지정할 수 있습니다. 프로세스가 리포지토리에 저장된 후에는 오퍼레이터의 매개변수로 설정된 모든 리포지토리 항목 참조가 프로세스의 위치를 기준으로 해석됩니다. 이것은 무엇을 의미할까요? 리포지토리의 항목은 다음과 같이 표기됩니다: //RepositoryName/Folder/Subfolder/File 앞의 두 슬래시는 먼저 리포지토리 이름이 따라온다는 것을 나타냅니다. 그 다음에 폴더 이름이 이어지고 마지막으로 파일 이름이 옵니다. 이러한 표기를 절대 경로라고 합니다. 다음 표기에서는 /Folder/Subfolder/File 앞에 리포지토리 지정이 빠져 있습니다. 이 표기는 따라서 리포지토리 상대 경로입니다. 이 표기를 사용하는 프로세스가 위치한 동일 리포지토리 내의 파일을 참조합니다. 앞의 슬래시는 절대 경로 표기를 나타냅니다. 이것도 없으면 상대 표기로 해석됩니다:"
              },
              {
                "type": "paragraph",
                "text": "../RelativeFolder/File은 예를 들어 현재 프로세스가 포함된 파일에서 한 디렉터리 위로 올라가(\"..\" 사용) \"RelativeFolder\" 폴더를 찾아 그 안의 파일을 가리킵니다. 따라서 프로세스가 예를 들어 //MyRepository/ProjectA/Processes/ProcessB 파일에 있다면, 이 표기는 //MyRepository/ProjectA/RelativeFolder/File을 가리키게 됩니다. 참고: 위의 설명이 실제보다 복잡하게 들릴 수 있습니다. 무엇보다 먼저 각 새 프로세스에 대해 리포지토리 내 위치를 정의한 다음, 리포지토리 항목이 필요한 모든 오퍼레이터 매개변수에 대해 리포지토리 브라우저를 사용하기만 하면, RapidMiner Studio가 가능한 한 항상 상대 경로를 사용하도록 완전 자동으로 처리해 줍니다. 이는 특히 리포지토리 재구성과 다른 사용자를 위한 복사본 만들기를 용이하게 하며, 절대 경로 표기에서는 이러한 작업이 어려울 수 있습니다.",
                "html": "../RelativeFolder/File은 예를 들어 현재 프로세스가 포함된 파일에서 한 디렉터리 위로 올라가(\"..\" 사용) \"RelativeFolder\" 폴더를 찾아 그 안의 파일을 가리킵니다. 따라서 프로세스가 예를 들어 //MyRepository/ProjectA/Processes/ProcessB 파일에 있다면, 이 표기는 //MyRepository/ProjectA/RelativeFolder/File을 가리키게 됩니다. 참고: 위의 설명이 실제보다 복잡하게 들릴 수 있습니다. 무엇보다 먼저 각 새 프로세스에 대해 리포지토리 내 위치를 정의한 다음, 리포지토리 항목이 필요한 모든 오퍼레이터 매개변수에 대해 리포지토리 브라우저를 사용하기만 하면, RapidMiner Studio가 가능한 한 항상 상대 경로를 사용하도록 완전 자동으로 처리해 줍니다. 이는 특히 리포지토리 재구성과 다른 사용자를 위한 복사본 만들기를 용이하게 하며, 절대 경로 표기에서는 이러한 작업이 어려울 수 있습니다."
              }
            ],
            "subsections": []
          },
          {
            "id": "5-2-2-importing-data-and-objects-into-the-repository",
            "number": "5.2.2",
            "title": "리포지토리로 데이터 및 객체 가져오기",
            "blocks": [
              {
                "type": "paragraph",
                "text": "데이터 및 모델과 같은 기타 객체를 리포지토리로 가져오는 방법은 다양합니다. 여기서는 가장 중요한 방법들을 설명합니다. 마법사를 사용한 예제 세트 가져오기 특정 형식의 데이터를 RapidMiner Studio 프로세스에서 사용하려는 경우, 많은 파일 형식과 데이터베이스에 대해 소위 마법사가 제공됩니다. 마법사는 로딩 과정을 단계별로 안내하는 대화 상자입니다. 모든 마법사에서 속성 유형, 값 범위, 개별 열의 역할과 같은 특정 메타데이터를 할당할 수 있습니다. 리포지토리 상단 영역에서 선택한 파일 유형에 적합한 마법사를 시작하는 아이콘을 찾을 수 있습니다. RapidMiner Studio의 \"File\"(파일) 메뉴에서도 동일한 작업을 찾을 수 있습니다. 마지막으로,",
                "html": "데이터 및 모델과 같은 기타 객체를 리포지토리로 가져오는 방법은 다양합니다. 여기서는 가장 중요한 방법들을 설명합니다. 마법사를 사용한 예제 세트 가져오기 특정 형식의 데이터를 RapidMiner Studio 프로세스에서 사용하려는 경우, 많은 파일 형식과 데이터베이스에 대해 소위 마법사가 제공됩니다. 마법사는 로딩 과정을 단계별로 안내하는 대화 상자입니다. 모든 마법사에서 속성 유형, 값 범위, 개별 열의 역할과 같은 특정 메타데이터를 할당할 수 있습니다. 리포지토리 상단 영역에서 선택한 파일 유형에 적합한 마법사를 시작하는 아이콘을 찾을 수 있습니다. RapidMiner Studio의 \"File\"(파일) 메뉴에서도 동일한 작업을 찾을 수 있습니다. 마지막으로,"
              },
              {
                "type": "paragraph",
                "text": "파일을 가져오는 또 다른 특히 간단한 방법이 있습니다: 마우스 버튼을 누른 채로 가져올 파일을 프로세스 뷰로 끌어다 놓기만 하면 됩니다. 가능한 경우 적절한 오퍼레이터가 자동으로 생성됩니다. \"Store\" 오퍼레이터 ETL 프로세스나 그 결과를 리포지토리에 저장하려는 다른 프로세스가 있는 경우, \"Store\" 오퍼레이터를 프로세스에 통합하여 이를 수행할 수 있습니다.",
                "html": "파일을 가져오는 또 다른 특히 간단한 방법이 있습니다: 마우스 버튼을 누른 채로 가져올 파일을 프로세스 뷰로 끌어다 놓기만 하면 됩니다. 가능한 경우 적절한 오퍼레이터가 자동으로 생성됩니다. \"Store\" 오퍼레이터 ETL 프로세스나 그 결과를 리포지토리에 저장하려는 다른 프로세스가 있는 경우, \"Store\" 오퍼레이터를 프로세스에 통합하여 이를 수행할 수 있습니다."
              },
              {
                "type": "image",
                "caption": "그림 5.4: \"Store\" 오퍼레이터를 사용하여 모든 데이터와 객체를 리포지토리에",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "저장할 수 있습니다. 이 대화 상자는 저장 위치를 지정할 수 있는 리포지토리 브라우저를 보여주며, \"Directory\"(디렉터리) 버튼을 클릭하면 오퍼레이터의 매개변수에 나타납니다. \"Generate Data\" 오퍼레이터를 사용하여 이 그림의 예제 프로세스는 리포지토리에 저장할 데이터 세트를 생성합니다. \"Store\" 오퍼레이터에는 \"repository location\"(리포지토리 위치)이라는 하나의 매개변수만 있습니다. 이 매개변수 옆의 폴더 버튼을",
                "html": "저장할 수 있습니다. 이 대화 상자는 저장 위치를 지정할 수 있는 리포지토리 브라우저를 보여주며, \"Directory\"(디렉터리) 버튼을 클릭하면 오퍼레이터의 매개변수에 나타납니다. \"Generate Data\" 오퍼레이터를 사용하여 이 그림의 예제 프로세스는 리포지토리에 저장할 데이터 세트를 생성합니다. \"Store\" 오퍼레이터에는 \"repository location\"(리포지토리 위치)이라는 하나의 매개변수만 있습니다. 이 매개변수 옆의 폴더 버튼을"
              },
              {
                "type": "paragraph",
                "text": "누르면 리포지토리에서 폴더를 먼저 지정한 다음 데이터 세트의 이름을 지정할 수 있는 대화 상자가 나타납니다(그림 5.4). 프로세스를 실행하면 생성된 데이터 세트가 포함된 새 항목이 리포지토리에 나타나는 것을 볼 수 있습니다. 따라서 Store 오퍼레이터는 자동으로 또는 정기적으로 수행해야 하는 데이터 통합 및 변환 프로세스에 특히 유용합니다. 예를 들어 RapidMiner Server의 프로세스 스케줄러 내에서 사용할 수 있습니다. 위에서 설명한 마법사를 사용하는 것이 일회성 및 상당히 대화형 데이터 통합에는 확실히 더 자주 사용되는 방법입니다. 참고: Store 오퍼레이터에는 데이터 세트뿐만 아니라 모델 및 기타 모든 RapidMiner Studio 객체도 연결할 수 있습니다. 따라서 모든 결과를 리포지토리에 저장할 수 있습니다. 오퍼레이터를 사용한 다른 형식 가져오기 리포지토리는 RapidMiner Studio에 필요한 모든 데이터와 메타데이터를 포함하는 형식으로 데이터 세트를 저장합니다. 처음에 데이터는 아마도 CSV, Excel, SQL 데이터베이스 등 다른 형식으로 되어 있을 것입니다. 위에서 설명한 대로 이러한 파일을 리포지토리로 전송할 수 있습니다. 그러나 RapidMiner Studio는 프로세스 내에서 다양한 다른 형식도 가져올 수 있습니다. 이를 위한 오퍼레이터는 \"Import\" 그룹에서 찾을 수 있습니다. 그러나 이러한 오퍼레이터를 사용할 때는 주의가 필요합니다: 이러한 오퍼레이터에서는 메타데이터의 가용성이 보장되지 않으므로, 특정 속성 값의 존재를 전제로 하는 프로세스가 런타임에서야 오류를 발견하게 될 수 있습니다. 그럼에도 불구하고 이러한 파일 형식의 사용은 때로 피할 수 없습니다. 예를 들어 ETL 프로세스의 정기적 실행 시에 그렇습니다. 그러나 이러한 프로세스의 목표는 후속 Store 오퍼레이터를 통해 데이터를 리포지토리로 전송하여 이후의 실제 분석 프로세스에서 사용할 수 있도록 하는 것이어야 합니다. \"Import\" 그룹의 오퍼레이터에는 각 형식에 맞는 다양한 매개변수가 있습니다. 해당 설명은 각 오퍼레이터 문서를 참조하십시오.",
                "html": "누르면 리포지토리에서 폴더를 먼저 지정한 다음 데이터 세트의 이름을 지정할 수 있는 대화 상자가 나타납니다(그림 5.4). 프로세스를 실행하면 생성된 데이터 세트가 포함된 새 항목이 리포지토리에 나타나는 것을 볼 수 있습니다. 따라서 Store 오퍼레이터는 자동으로 또는 정기적으로 수행해야 하는 데이터 통합 및 변환 프로세스에 특히 유용합니다. 예를 들어 RapidMiner Server의 프로세스 스케줄러 내에서 사용할 수 있습니다. 위에서 설명한 마법사를 사용하는 것이 일회성 및 상당히 대화형 데이터 통합에는 확실히 더 자주 사용되는 방법입니다. 참고: Store 오퍼레이터에는 데이터 세트뿐만 아니라 모델 및 기타 모든 RapidMiner Studio 객체도 연결할 수 있습니다. 따라서 모든 결과를 리포지토리에 저장할 수 있습니다. 오퍼레이터를 사용한 다른 형식 가져오기 리포지토리는 RapidMiner Studio에 필요한 모든 데이터와 메타데이터를 포함하는 형식으로 데이터 세트를 저장합니다. 처음에 데이터는 아마도 CSV, Excel, SQL 데이터베이스 등 다른 형식으로 되어 있을 것입니다. 위에서 설명한 대로 이러한 파일을 리포지토리로 전송할 수 있습니다. 그러나 RapidMiner Studio는 프로세스 내에서 다양한 다른 형식도 가져올 수 있습니다. 이를 위한 오퍼레이터는 \"Import\" 그룹에서 찾을 수 있습니다. 그러나 이러한 오퍼레이터를 사용할 때는 주의가 필요합니다: 이러한 오퍼레이터에서는 메타데이터의 가용성이 보장되지 않으므로, 특정 속성 값의 존재를 전제로 하는 프로세스가 런타임에서야 오류를 발견하게 될 수 있습니다. 그럼에도 불구하고 이러한 파일 형식의 사용은 때로 피할 수 없습니다. 예를 들어 ETL 프로세스의 정기적 실행 시에 그렇습니다. 그러나 이러한 프로세스의 목표는 후속 Store 오퍼레이터를 통해 데이터를 리포지토리로 전송하여 이후의 실제 분석 프로세스에서 사용할 수 있도록 하는 것이어야 합니다. \"Import\" 그룹의 오퍼레이터에는 각 형식에 맞는 다양한 매개변수가 있습니다. 해당 설명은 각 오퍼레이터 문서를 참조하십시오."
              },
              {
                "type": "paragraph",
                "text": "결과 뷰 또는 프로세스 뷰에서 객체 저장하기 프로세스를 실행한 후, 기본 설정에서는 동일한 이름의 탭이 있는 Results Perspective(결과 관점)가 표시됩니다. 도구 모음의 오른쪽에는 현재 선택된 결과를 리포지토리에 저장할 수 있는 버튼이 있습니다. 여기서도 폴더와 이름을 선택할 수 있는 대화 상자가 나타납니다. 프로세스에 Results Perspective에 표시되지 않는(또는 더 이상 표시되지 않는) 중간 결과가 있는 경우, Process View(프로세스 뷰)에서도 이를 저장할 수 있습니다. 이를 위해 데이터가 있는 포트에서 마우스 오른쪽 버튼을 클릭합니다. 이미 실행된 모든 오퍼레이터의 출력 포트에서 이러한 경우에 해당합니다. 더 어두운 색상과 컨텍스트 도움말의 적절한 항목으로 이를 확인할 수 있습니다. 여기서 \"Store in Repository\"(리포지토리에 저장) 메뉴 항목을 선택하여 객체를 저장합니다. 그러나 포트의 데이터는 메모리 절약을 위해 일정 시간 후에 해제될 수 있으며, 따라서 포트에 무한히 유지되는 것이 보장되지 않는다는 점에 유의하십시오. 이전 장의 설명도 참조하십시오.",
                "html": "결과 뷰 또는 프로세스 뷰에서 객체 저장하기 프로세스를 실행한 후, 기본 설정에서는 동일한 이름의 탭이 있는 Results Perspective(결과 관점)가 표시됩니다. 도구 모음의 오른쪽에는 현재 선택된 결과를 리포지토리에 저장할 수 있는 버튼이 있습니다. 여기서도 폴더와 이름을 선택할 수 있는 대화 상자가 나타납니다. 프로세스에 Results Perspective에 표시되지 않는(또는 더 이상 표시되지 않는) 중간 결과가 있는 경우, Process View(프로세스 뷰)에서도 이를 저장할 수 있습니다. 이를 위해 데이터가 있는 포트에서 마우스 오른쪽 버튼을 클릭합니다. 이미 실행된 모든 오퍼레이터의 출력 포트에서 이러한 경우에 해당합니다. 더 어두운 색상과 컨텍스트 도움말의 적절한 항목으로 이를 확인할 수 있습니다. 여기서 \"Store in Repository\"(리포지토리에 저장) 메뉴 항목을 선택하여 객체를 저장합니다. 그러나 포트의 데이터는 메모리 절약을 위해 일정 시간 후에 해제될 수 있으며, 따라서 포트에 무한히 유지되는 것이 보장되지 않는다는 점에 유의하십시오. 이전 장의 설명도 참조하십시오."
              }
            ],
            "subsections": []
          },
          {
            "id": "5-2-3-access-to-and-administration-of-the-repository",
            "number": "5.2.3",
            "title": "리포지토리 접근 및 관리",
            "blocks": [
              {
                "type": "paragraph",
                "text": "데이터를 리포지토리에 가져온 후에는 Retrieve 오퍼레이터를 사용하여 프로세스에서 사용할 수 있습니다. 평소처럼 Operators View(오퍼레이터 뷰)에서 오퍼레이터를 프로세스로 끌어다 놓고 거기서 리포지토리 항목에 대한 매개변수를 정의할 수 있습니다. 하지만 더 쉬운 방법이 있습니다: 마우스를 사용하여 리포지토리의 항목(예: 데이터 세트)을 Process View(프로세스 뷰)로 끌어다 놓기만 하면 됩니다. 이 항목에 대한 참조가 구성된 오퍼레이터가 자동으로 삽입됩니다. 항목이 객체인 경우 \"Retrieve\" 유형의 새 오퍼레이터가 생성되고 그에 따라 구성됩니다. 그러나 리포지토리 항목이 프로세스인 경우 \"Execute Process\" 유형의 새 오퍼레이터가 생성되며, 해당 매개변수가 리포지토리에서 선택한 프로세스를 자동으로 참조합니다. 리포지토리의 항목을 마우스 오른쪽 버튼으로 한 번 클릭하면 리포지토리에 접근하는 추가 방법을 찾을 수 있습니다. 이러한 기능들은 컴퓨터의 파일",
                "html": "데이터를 리포지토리에 가져온 후에는 Retrieve 오퍼레이터를 사용하여 프로세스에서 사용할 수 있습니다. 평소처럼 Operators View(오퍼레이터 뷰)에서 오퍼레이터를 프로세스로 끌어다 놓고 거기서 리포지토리 항목에 대한 매개변수를 정의할 수 있습니다. 하지만 더 쉬운 방법이 있습니다: 마우스를 사용하여 리포지토리의 항목(예: 데이터 세트)을 Process View(프로세스 뷰)로 끌어다 놓기만 하면 됩니다. 이 항목에 대한 참조가 구성된 오퍼레이터가 자동으로 삽입됩니다. 항목이 객체인 경우 \"Retrieve\" 유형의 새 오퍼레이터가 생성되고 그에 따라 구성됩니다. 그러나 리포지토리 항목이 프로세스인 경우 \"Execute Process\" 유형의 새 오퍼레이터가 생성되며, 해당 매개변수가 리포지토리에서 선택한 프로세스를 자동으로 참조합니다. 리포지토리의 항목을 마우스 오른쪽 버튼으로 한 번 클릭하면 리포지토리에 접근하는 추가 방법을 찾을 수 있습니다. 이러한 기능들은 컴퓨터의 파일"
              },
              {
                "type": "paragraph",
                "text": "관리에서 익숙하실 것입니다. 이러한 작업은 리포지토리 뷰의 도구 모음을 통해서도 사용할 수 있으며 대부분 자명합니다: Store Process here(여기에 프로세스 저장) 현재 프로세스를 지정된 위치에 저장합니다. Rename(이름 바꾸기) 항목 또는 디렉터리의 이름을 변경합니다. Create Folder(폴더 만들기) 여기에 새 폴더를 만듭니다. Delete(삭제) 선택한 리포지토리 항목 또는 디렉터리를 삭제합니다. Copy(복사) 선택한 항목을 복사하여 나중에 다른 위치에 붙여넣을 수 있도록 합니다. Paste(붙여넣기) 이전에 복사한 항목을 이 위치에 붙여넣습니다. Copy Location to Clipboard(위치를 클립보드에 복사) 이 항목에 대한 고유 식별자를 클립보드에 복사하여 오퍼레이터의 매개변수, 웹 인터페이스 등에서 사용할 수 있습니다. Open Process(프로세스 열기) 프로세스를 선택한 경우, 현재 프로세스가 닫히고 선택한 프로세스가 로드됩니다. Refresh(새로 고침) 리포지토리가 공유 파일 시스템에 있거나 RapidMiner Server를 사용하는 경우, 즉 다른 사용자가 동시에 데이터를 변경할 수 있는 경우 이 기능으로 리포지토리 뷰를 새로 고칠 수 있습니다.",
                "html": "관리에서 익숙하실 것입니다. 이러한 작업은 리포지토리 뷰의 도구 모음을 통해서도 사용할 수 있으며 대부분 자명합니다: Store Process here(여기에 프로세스 저장) 현재 프로세스를 지정된 위치에 저장합니다. Rename(이름 바꾸기) 항목 또는 디렉터리의 이름을 변경합니다. Create Folder(폴더 만들기) 여기에 새 폴더를 만듭니다. Delete(삭제) 선택한 리포지토리 항목 또는 디렉터리를 삭제합니다. Copy(복사) 선택한 항목을 복사하여 나중에 다른 위치에 붙여넣을 수 있도록 합니다. Paste(붙여넣기) 이전에 복사한 항목을 이 위치에 붙여넣습니다. Copy Location to Clipboard(위치를 클립보드에 복사) 이 항목에 대한 고유 식별자를 클립보드에 복사하여 오퍼레이터의 매개변수, 웹 인터페이스 등에서 사용할 수 있습니다. Open Process(프로세스 열기) 프로세스를 선택한 경우, 현재 프로세스가 닫히고 선택한 프로세스가 로드됩니다. Refresh(새로 고침) 리포지토리가 공유 파일 시스템에 있거나 RapidMiner Server를 사용하는 경우, 즉 다른 사용자가 동시에 데이터를 변경할 수 있는 경우 이 기능으로 리포지토리 뷰를 새로 고칠 수 있습니다."
              }
            ],
            "subsections": []
          },
          {
            "id": "5-2-4-the-process-context",
            "number": "5.2.4",
            "title": "프로세스 컨텍스트",
            "blocks": [
              {
                "type": "paragraph",
                "text": "이전에 프로세스 뷰 오른쪽에 있는 프로세스의 출력 포트를 사용하여 프로세스 결과를 Result Perspective(결과 관점)에 표시한 적이 있습니다. 프로세스의 출력 포트 외에 Process View(프로세스 뷰)의 왼쪽에 있는 입력 포트도 있습니다. 이전에는 이것을 연결한 적이 없습니다. 기본 설정에서는 적어도 소스에 대해서는 연결할 필요가 없는데, 프로세스 자체에 입력이 없기 때문입니다. 그러나 내부 싱크를 연결하면 효과가 있습니다: 프로세스 끝에서 싱크에 도달하는 모든 객체가 Result Perspective에 프로세스의 결과로 표시됩니다.",
                "html": "이전에 프로세스 뷰 오른쪽에 있는 프로세스의 출력 포트를 사용하여 프로세스 결과를 Result Perspective(결과 관점)에 표시한 적이 있습니다. 프로세스의 출력 포트 외에 Process View(프로세스 뷰)의 왼쪽에 있는 입력 포트도 있습니다. 이전에는 이것을 연결한 적이 없습니다. 기본 설정에서는 적어도 소스에 대해서는 연결할 필요가 없는데, 프로세스 자체에 입력이 없기 때문입니다. 그러나 내부 싱크를 연결하면 효과가 있습니다: 프로세스 끝에서 싱크에 도달하는 모든 객체가 Result Perspective에 프로세스의 결과로 표시됩니다."
              },
              {
                "type": "paragraph",
                "text": "이러한 프로세스의 입력 및 출력 포트에는 또 다른 기능이 있습니다. 일반적인 프로세스는 Retrieve 오퍼레이터 세트로 시작하여 처리 오퍼레이터 세트가 이어지고 Store 오퍼레이터 세트로 끝납니다. Context View(컨텍스트 뷰)를 사용하면 이러한 오퍼레이터를 만들 필요가 없습니다. Context View는 \"View\"(보기) 메뉴에서 찾을 수 있습니다. 그림 5.5는 이 Context View를 보여줍니다.",
                "html": "이러한 프로세스의 입력 및 출력 포트에는 또 다른 기능이 있습니다. 일반적인 프로세스는 Retrieve 오퍼레이터 세트로 시작하여 처리 오퍼레이터 세트가 이어지고 Store 오퍼레이터 세트로 끝납니다. Context View(컨텍스트 뷰)를 사용하면 이러한 오퍼레이터를 만들 필요가 없습니다. Context View는 \"View\"(보기) 메뉴에서 찾을 수 있습니다. 그림 5.5는 이 Context View를 보여줍니다."
              },
              {
                "type": "image",
                "caption": "그림 5.5: 프로세스 컨텍스트. \"Input\"(입력)에서 프로세스의 입력으로 사용되어",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "프로세스의 입력 포트에 배치될 리포지토리 항목을 지정합니다. \"Output\"(출력)에서 결과를 리포지토리의 어디에 저장할지 지정합니다. Context View에서는 리포지토리의 데이터를 입력 포트에 배치하고 출력을 다시 리포지토리에 기록할 수 있습니다. 각 포트에 대해 이러한 지정을 할 수 있습니다. 이에는 두 가지 장점이 있습니다:",
                "html": "프로세스의 입력 포트에 배치될 리포지토리 항목을 지정합니다. \"Output\"(출력)에서 결과를 리포지토리의 어디에 저장할지 지정합니다. Context View에서는 리포지토리의 데이터를 입력 포트에 배치하고 출력을 다시 리포지토리에 기록할 수 있습니다. 각 포트에 대해 이러한 지정을 할 수 있습니다. 이에는 두 가지 장점이 있습니다:"
              },
              {
                "type": "paragraph",
                "text": "1. Retrieve와 Store를 위한 오퍼레이터를 생략할 수 있어 프로세스가 다소 명확해지는 경우가 많습니다.",
                "html": "1. Retrieve와 Store를 위한 오퍼레이터를 생략할 수 있어 프로세스가 다소 명확해지는 경우가 많습니다."
              },
              {
                "type": "paragraph",
                "text": "2. 컨텍스트를 사용하면 \"Execute Process\" 오퍼레이터를 통해 통합될 프로세스를 테스트하는 데에도 실용적입니다: 이 오퍼레이터의 데이터가 프로세스 컨텍스트에 정의된 값을 덮어씁니다.",
                "html": "2. 컨텍스트를 사용하면 \"Execute Process\" 오퍼레이터를 통해 통합될 프로세스를 테스트하는 데에도 실용적입니다: 이 오퍼레이터의 데이터가 프로세스 컨텍스트에 정의된 값을 덮어씁니다."
              }
            ],
            "subsections": []
          }
        ]
      },
      {
        "id": "5-3-data-and-meta-data",
        "number": "5.3",
        "title": "데이터와 메타데이터",
        "blocks": [
          {
            "type": "paragraph",
            "text": "RapidMiner Studio는 실제 데이터 외에도 리포지토리에 다른 정보를 저장합니다: 데이터에 대한 데이터, 소위 메타데이터입니다. 이러한 메타데이터는 각 객체 유형에 대해 사용할 수 있으며, 모델과 데이터 세트에 특히 유용합니다. 데이터 세트에 대해 저장되는 메타 정보에는 예를 들어 다음이 포함됩니다:",
            "html": "RapidMiner Studio는 실제 데이터 외에도 리포지토리에 다른 정보를 저장합니다: 데이터에 대한 데이터, 소위 메타데이터입니다. 이러한 메타데이터는 각 객체 유형에 대해 사용할 수 있으며, 모델과 데이터 세트에 특히 유용합니다. 데이터 세트에 대해 저장되는 메타 정보에는 예를 들어 다음이 포함됩니다:"
          },
          {
            "type": "list",
            "items": [
              "예제의 수",
              "속성의 수",
              "속성의 유형, 이름 및 역할",
              "속성의 값 범위 또는 일부 기본 통계",
              "속성별 결측값의 수"
            ]
          },
          {
            "type": "paragraph",
            "text": "이 정보는 데이터 세트를 사전에 로드하지 않고도 리포지토리에서 볼 수 있으며, 데이터 세트의 크기에 따라 로드에는 시간이 걸릴 수 있습니다. 리포지토리 항목 위에 커서를 올려놓고 몇 초간 유지하기만 하면 됩니다: 메타데이터가 소위 툴팁 형태로 표시됩니다. 다른 프로그램과 달리, 이 도움말 정보는 일반적인 것보다 훨씬 강력합니다: F3 키를 눌러 이러한 툴팁을 이동하고 크기를 변경할 수 있는 적절한 대화 상자로 전환할 수 있습니다. 또한, 이러한 RapidMiner Studio 툴팁은 메타데이터와 함께 텍스트 정보 외에도 테이블과 같은 다른 요소를 포함할 수 있습니다. 메타 정보가 반드시 즉시 사용 가능한 것은 아닙니다. 먼저 툴팁 내의 링크를 한 번 클릭하여 메타데이터 로딩을 시작해야 할 수도 있습니다. 이는 리포지토리 항목의 툴팁을 실수로 보게 되는 경우에 잠재적으로 상당히 큰 메타",
            "html": "이 정보는 데이터 세트를 사전에 로드하지 않고도 리포지토리에서 볼 수 있으며, 데이터 세트의 크기에 따라 로드에는 시간이 걸릴 수 있습니다. 리포지토리 항목 위에 커서를 올려놓고 몇 초간 유지하기만 하면 됩니다: 메타데이터가 소위 툴팁 형태로 표시됩니다. 다른 프로그램과 달리, 이 도움말 정보는 일반적인 것보다 훨씬 강력합니다: F3 키를 눌러 이러한 툴팁을 이동하고 크기를 변경할 수 있는 적절한 대화 상자로 전환할 수 있습니다. 또한, 이러한 RapidMiner Studio 툴팁은 메타데이터와 함께 텍스트 정보 외에도 테이블과 같은 다른 요소를 포함할 수 있습니다. 메타 정보가 반드시 즉시 사용 가능한 것은 아닙니다. 먼저 툴팁 내의 링크를 한 번 클릭하여 메타데이터 로딩을 시작해야 할 수도 있습니다. 이는 리포지토리 항목의 툴팁을 실수로 보게 되는 경우에 잠재적으로 상당히 큰 메타"
          },
          {
            "type": "paragraph",
            "text": "데이터를 즉시 로드하여 RapidMiner Studio가 느려지는 것을 방지합니다. 팁: 리포지토리 항목 위에 커서를 잠시 올려놓으면 메타데이터를 확인하거나 먼저 로드할 수 있습니다. 항목이 예를 들어 중간 결과인 경우 어떤 전처리가 이미 수행되었는지 쉽게 파악할 수 있습니다. 다음 그림은 RapidMiner Studio와 함께 제공되는 Sample 리포지토리의 예제 디렉터리에 있는 골프 데이터 세트의 메타데이터가 어떻게 보이는지 보여줍니다(그림 5.6). 먼저 데이터 세트에 14개의 예제(\"Number of examples\")와 5개의 속성(\"Number of attributes\")이 포함되어 있음을 알 수 있습니다. \"Outlook\"이라는 이름의 속성은 명목형이며 \"overcast\", \"rain\", \"sunny\"의 세 가지 값을 가집니다. 반면 \"Temperature\" 속성은 수치형이며 64에서 85 사이의 값을 가집니다 - 물론 화씨 단위입니다. 마지막으로, \"Play\" 속성은 다시 명목형이지만 특별한 역할을 가지고 있습니다: \"label\"로 표시되어 있습니다. 역할은 기울임꼴로 표시되며 속성 이름 앞에 주어집니다.",
            "html": "데이터를 즉시 로드하여 RapidMiner Studio가 느려지는 것을 방지합니다. 팁: 리포지토리 항목 위에 커서를 잠시 올려놓으면 메타데이터를 확인하거나 먼저 로드할 수 있습니다. 항목이 예를 들어 중간 결과인 경우 어떤 전처리가 이미 수행되었는지 쉽게 파악할 수 있습니다. 다음 그림은 RapidMiner Studio와 함께 제공되는 Sample 리포지토리의 예제 디렉터리에 있는 골프 데이터 세트의 메타데이터가 어떻게 보이는지 보여줍니다(그림 5.6). 먼저 데이터 세트에 14개의 예제(\"Number of examples\")와 5개의 속성(\"Number of attributes\")이 포함되어 있음을 알 수 있습니다. \"Outlook\"이라는 이름의 속성은 명목형이며 \"overcast\", \"rain\", \"sunny\"의 세 가지 값을 가집니다. 반면 \"Temperature\" 속성은 수치형이며 64에서 85 사이의 값을 가집니다 - 물론 화씨 단위입니다. 마지막으로, \"Play\" 속성은 다시 명목형이지만 특별한 역할을 가지고 있습니다: \"label\"로 표시되어 있습니다. 역할은 기울임꼴로 표시되며 속성 이름 앞에 주어집니다."
          },
          {
            "type": "image",
            "caption": "그림 5.6: RapidMiner Studio와 함께 제공되는 리포지토리의 예제 디렉터리에 있는",
            "src": ""
          },
          {
            "type": "paragraph",
            "text": "\"Sample\" 리포지토리의 골프 데이터 세트의 메타데이터. 이 리포지토리의 \"data\" 디렉터리에서 \"Golf\"라는 이름의 데이터 세트를 찾을 수 있습니다.",
            "html": "\"Sample\" 리포지토리의 골프 데이터 세트의 메타데이터. 이 리포지토리의 \"data\" 디렉터리에서 \"Golf\"라는 이름의 데이터 세트를 찾을 수 있습니다."
          }
        ],
        "subsections": [
          {
            "id": "5-3-1-propagating-meta-data-from-the-repository-and",
            "number": "5.3.1",
            "title": "리포지토리에서 프로세스를 통한 메타데이터 전파",
            "blocks": [
              {
                "type": "paragraph",
                "text": "프로세스를 생성할 때 위에서 설명한 메타데이터가 실제 데이터와 함께 RapidMiner Studio 프로세스를 통해 전달되는 것을 이미 확인하셨습니다. 앞서 언급했듯이, 이러한 메타데이터 전파와 변환을 위해서는 RapidMiner Studio 리포지토리에서 데이터를 관리하고 여기에서 메타데이터를 얻을 수 있어야 합니다. 이러한 이유로 프로세스 설계 중 지원을 제공하기 위해 데이터 및 프로세스 관리에 리포지토리를 사용하는 것의 필요성을 다시 한번 상기시키고 강조하고자 합니다. 이 절에서는 프로세스 설계에 대한 추가 예제를 수행하겠지만, 이번에는 RapidMiner Studio 리포지토리의 데이터 세트를 사용합니다. 따라서 데이터 검색부터 결과 생성까지의 전체 프로세스를 처음으로 수행하게 됩니다. 물론, 이 프로세스에는 일반적으로 위에서 제시한 방법 중 하나를 사용하여 리포지토리로 데이터를 가져오는 과정이 선행되지만, 이 경우에는 이 단계를 건너뛰고 RapidMiner Studio에서 이미 제공하는 데이터 세트 중 하나를 사용하겠습니다. 예를 들어 제공된 Iris 데이터 세트를 Retrieve 오퍼레이터를 사용하여 로드합니다. 해당 항목(위에서 이미 사용한 골프 데이터 세트와 같은 디렉터리에 있음)을 Process View(프로세스 뷰)로 끌어다 놓기만 하면 됩니다. 아직 프로세스를 실행하지 마십시오. Normalise 오퍼레이터를 삽입하고 입력을 Retrieve 오퍼레이터의 출력에 연결합니다. 매개변수 \"method\"를 \"range transformation\"으로 설정합니다. 이 설정에서 오퍼레이터는 수치 값을 현재 최솟값이 0이고 최댓값이 1이 되도록 재조정하는 역할을 합니다. 이 변환을 적용할 개별 속성을 선택합니다(예: 속성 \"a3\"). 이를 위해 필터 유형 \"attribute filter type\"을 \"single\"로 설정하고 매개변수 \"attribute\"에서 속성 \"a3\"을 선택합니다. 이제 먼저 Retrieve의 출력 포트 위로 마우스를 가져간 다음 Normalise 오퍼레이터의 상단 출력 포트 위로 이동합니다. 두 경우 모두 Iris 데이터 세트의 메타데이터를 볼 수 있습니다. 그러나 선택한 속성의 메타데이터가 변경된 것을 알 수 있습니다: \"a3\"의 값 범위가 변환 후 [0,1] 구간으로 정규화되었습니다. 더 정확히 말하면: a3의 값 범위는 실행 시에 정규화될 것입니다.",
                "html": "프로세스를 생성할 때 위에서 설명한 메타데이터가 실제 데이터와 함께 RapidMiner Studio 프로세스를 통해 전달되는 것을 이미 확인하셨습니다. 앞서 언급했듯이, 이러한 메타데이터 전파와 변환을 위해서는 RapidMiner Studio 리포지토리에서 데이터를 관리하고 여기에서 메타데이터를 얻을 수 있어야 합니다. 이러한 이유로 프로세스 설계 중 지원을 제공하기 위해 데이터 및 프로세스 관리에 리포지토리를 사용하는 것의 필요성을 다시 한번 상기시키고 강조하고자 합니다. 이 절에서는 프로세스 설계에 대한 추가 예제를 수행하겠지만, 이번에는 RapidMiner Studio 리포지토리의 데이터 세트를 사용합니다. 따라서 데이터 검색부터 결과 생성까지의 전체 프로세스를 처음으로 수행하게 됩니다. 물론, 이 프로세스에는 일반적으로 위에서 제시한 방법 중 하나를 사용하여 리포지토리로 데이터를 가져오는 과정이 선행되지만, 이 경우에는 이 단계를 건너뛰고 RapidMiner Studio에서 이미 제공하는 데이터 세트 중 하나를 사용하겠습니다. 예를 들어 제공된 Iris 데이터 세트를 Retrieve 오퍼레이터를 사용하여 로드합니다. 해당 항목(위에서 이미 사용한 골프 데이터 세트와 같은 디렉터리에 있음)을 Process View(프로세스 뷰)로 끌어다 놓기만 하면 됩니다. 아직 프로세스를 실행하지 마십시오. Normalise 오퍼레이터를 삽입하고 입력을 Retrieve 오퍼레이터의 출력에 연결합니다. 매개변수 \"method\"를 \"range transformation\"으로 설정합니다. 이 설정에서 오퍼레이터는 수치 값을 현재 최솟값이 0이고 최댓값이 1이 되도록 재조정하는 역할을 합니다. 이 변환을 적용할 개별 속성을 선택합니다(예: 속성 \"a3\"). 이를 위해 필터 유형 \"attribute filter type\"을 \"single\"로 설정하고 매개변수 \"attribute\"에서 속성 \"a3\"을 선택합니다. 이제 먼저 Retrieve의 출력 포트 위로 마우스를 가져간 다음 Normalise 오퍼레이터의 상단 출력 포트 위로 이동합니다. 두 경우 모두 Iris 데이터 세트의 메타데이터를 볼 수 있습니다. 그러나 선택한 속성의 메타데이터가 변경된 것을 알 수 있습니다: \"a3\"의 값 범위가 변환 후 [0,1] 구간으로 정규화되었습니다. 더 정확히 말하면: a3의 값 범위는 실행 시에 정규화될 것입니다."
              },
              {
                "type": "paragraph",
                "text": "[0,1] 구간으로 정규화됩니다. 추가로 \"Discretize by Frequency\" 오퍼레이터를 삽입합니다. 이것을 Normalise 오퍼레이터와 연결합니다. 매개변수 \"range name type\"을 \"short\"로 설정하고 이번에는 위와 같은 메커니즘으로 다른 속성(예: \"a2\")을 선택합니다. 이제 새 오퍼레이터의 출력 포트 위로 마우스를 가져가서 메타데이터가 어떻게 변경되었는지 관찰합니다: 선택한 속성이 이제 더 이상 수치형이 아니라 명목형이며 \"range1\"과 \"range2\" 값을 가집니다. 이산화 오퍼레이터는 수치 값 범위를 임계값에서 분리하여 이 값 아래의 값을 \"range1\"로, 이 값 위의 값을 \"range2\"로 대체합니다. 임계값은 위와 아래에 동일한 수의 값이 있도록 자동으로 선택됩니다. 값을 두 개 이상의 값 범위로 나누려면 매개변수 \"number of bins\"를 적절히 조정하십시오. 프로세스와 표시된 메타데이터를 다음 그림에서 볼 수 있습니다:",
                "html": "[0,1] 구간으로 정규화됩니다. 추가로 \"Discretize by Frequency\" 오퍼레이터를 삽입합니다. 이것을 Normalise 오퍼레이터와 연결합니다. 매개변수 \"range name type\"을 \"short\"로 설정하고 이번에는 위와 같은 메커니즘으로 다른 속성(예: \"a2\")을 선택합니다. 이제 새 오퍼레이터의 출력 포트 위로 마우스를 가져가서 메타데이터가 어떻게 변경되었는지 관찰합니다: 선택한 속성이 이제 더 이상 수치형이 아니라 명목형이며 \"range1\"과 \"range2\" 값을 가집니다. 이산화 오퍼레이터는 수치 값 범위를 임계값에서 분리하여 이 값 아래의 값을 \"range1\"로, 이 값 위의 값을 \"range2\"로 대체합니다. 임계값은 위와 아래에 동일한 수의 값이 있도록 자동으로 선택됩니다. 값을 두 개 이상의 값 범위로 나누려면 매개변수 \"number of bins\"를 적절히 조정하십시오. 프로세스와 표시된 메타데이터를 다음 그림에서 볼 수 있습니다:"
              },
              {
                "type": "image",
                "caption": "그림 5.7: RapidMiner에서의 메타데이터 변환.",
                "src": ""
              },
              {
                "type": "paragraph",
                "text": "매개변수 \"range name type\"을 왜 \"short\"로 설정해야 했는지 궁금하실 것입니다. 직접 확인해 보고 \"long\"으로 설정해 보십시오. 프로세스를 실행하면 명목 값이 이제 더 많은 정보를 제공하는 것을 볼 수 있습니다: 생성된 구간의 한계가 추가로 포함됩니다. 이는 편리하지만 프로세스에는 중요하지 않습니다. 그러나 구간 한계에 대한 정보는 이산화가 실제로 수행되기 전까지는 사용할 수 없습니다. 따라서 프로세스 개발 시점의 메타데이터 표시에서는 고려될 수 없습니다. 그때는 이산화된 속성의 값 범위가 공집합의 상위집합, 즉 비어 있지 않다는 것만 메타데이터에 나타낼 수 있습니다. 이는 메타데이터가 완전히 알려지지 않았음을 의미합니다. 따라서 이 경우 명목 값의 집합이 공집합의 상위집합이라는 것 외에는 예상되는 메타데이터에 대해 사실상 아무것도 말할 수 없습니다. 사소한 진술이지만 그럼에도 불구하고 정확합니다. 메타데이터는 개발 시점에 모든 경우에 완전히 결정될 수 없습니다. 이는 일반적으로 여기서처럼 메타데이터가 실제 데이터에 의존하는 경우에 해당합니다. 이 경우 RapidMiner Studio는 데이터에 대해 가능한 한 많은 정보를 얻으려고 시도합니다.",
                "html": "매개변수 \"range name type\"을 왜 \"short\"로 설정해야 했는지 궁금하실 것입니다. 직접 확인해 보고 \"long\"으로 설정해 보십시오. 프로세스를 실행하면 명목 값이 이제 더 많은 정보를 제공하는 것을 볼 수 있습니다: 생성된 구간의 한계가 추가로 포함됩니다. 이는 편리하지만 프로세스에는 중요하지 않습니다. 그러나 구간 한계에 대한 정보는 이산화가 실제로 수행되기 전까지는 사용할 수 없습니다. 따라서 프로세스 개발 시점의 메타데이터 표시에서는 고려될 수 없습니다. 그때는 이산화된 속성의 값 범위가 공집합의 상위집합, 즉 비어 있지 않다는 것만 메타데이터에 나타낼 수 있습니다. 이는 메타데이터가 완전히 알려지지 않았음을 의미합니다. 따라서 이 경우 명목 값의 집합이 공집합의 상위집합이라는 것 외에는 예상되는 메타데이터에 대해 사실상 아무것도 말할 수 없습니다. 사소한 진술이지만 그럼에도 불구하고 정확합니다. 메타데이터는 개발 시점에 모든 경우에 완전히 결정될 수 없습니다. 이는 일반적으로 여기서처럼 메타데이터가 실제 데이터에 의존하는 경우에 해당합니다. 이 경우 RapidMiner Studio는 데이터에 대해 가능한 한 많은 정보를 얻으려고 시도합니다."
              },
              {
                "type": "paragraph",
                "text": "예측 분석 소프트웨어의 글로벌 리더. Boston | London | Dortmund | Budapest www.rapidminer.com",
                "html": "예측 분석 소프트웨어의 글로벌 리더. Boston | London | Dortmund | Budapest www.rapidminer.com"
              }
            ],
            "subsections": []
          }
        ]
      }
    ]
  }
]